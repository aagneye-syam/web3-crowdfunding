import { download } from "../../storage/download.js";
/**
 * Fetches the deployment metadata.
 * @param options - The options for fetching the deploy metadata.
 * @returns An object containing the compiler metadata and extended metadata.
 * @internal
 */
export async function fetchDeployMetadata(options) {
    const [compilerMetadata, extendedMetadata] = await Promise.all([
        fetchCompilerMetadata(options),
        fetchExtendedMetadata(options).catch(() => undefined),
    ]);
    return { compilerMetadata, extendedMetadata };
}
// helpers
/**
 * Fetches the published metadata.
 * @param options - The options for fetching the published metadata.
 * @internal
 */
async function fetchExtendedMetadata(options) {
    return download({
        uri: options.uri,
        client: options.client,
    }).then((r) => r.json());
}
async function fetchCompilerMetadata(options) {
    const rawMeta = await download({
        uri: options.uri,
        client: options.client,
    }).then((r) => r.json());
    const [deployBytecode, parsedMeta] = await Promise.all([
        download({ uri: rawMeta.bytecodeUri, client: options.client }).then((res) => res.text()),
        fetchAndParseCompilerMetadata({
            client: options.client,
            uri: rawMeta.metadataUri,
        }),
    ]);
    return {
        ...rawMeta,
        ...parsedMeta,
        bytecode: deployBytecode,
    };
}
const CONTRACT_METADATA_TIMEOUT_SEC = 2 * 1000;
async function fetchAndParseCompilerMetadata(options) {
    // short timeout to avoid hanging on unpinned contract metadata CIDs
    const metadata = await (await download({
        ...options,
        requestTimeoutMs: CONTRACT_METADATA_TIMEOUT_SEC,
    })).json();
    if (!metadata || !metadata.output) {
        throw new Error(`Could not resolve metadata for contract at ${options.uri}`);
    }
    return formatCompilerMetadata(metadata);
}
// biome-ignore lint/suspicious/noExplicitAny: TODO: fix later
function formatCompilerMetadata(metadata) {
    const abi = metadata.output.abi;
    const compilationTarget = metadata.settings.compilationTarget;
    const targets = Object.keys(compilationTarget);
    const name = compilationTarget[targets[0]];
    const info = {
        title: metadata.output.devdoc.title,
        author: metadata.output.devdoc.author,
        details: metadata.output.devdoc.detail,
        notice: metadata.output.userdoc.notice,
    };
    const licenses = [
        ...new Set(
        // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later
        Object.entries(metadata.sources).map(([, src]) => src.license)),
    ];
    return {
        name,
        abi,
        metadata,
        info,
        licenses,
        isPartialAbi: metadata.isPartialAbi,
    };
}
//# sourceMappingURL=deploy-metadata.js.map