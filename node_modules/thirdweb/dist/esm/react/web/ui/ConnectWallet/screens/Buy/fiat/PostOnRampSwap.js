import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useQuery } from "@tanstack/react-query";
import { useEffect, useState } from "react";
import { getPostOnRampQuote } from "../../../../../../../pay/buyWithFiat/getPostOnRampQuote.js";
import { useActiveAccount } from "../../../../../../core/hooks/wallets/wallet-hooks.js";
import { Spacer } from "../../../../components/Spacer.js";
import { Spinner } from "../../../../components/Spinner.js";
import { Container, ModalHeader } from "../../../../components/basic.js";
import { Button } from "../../../../components/buttons.js";
import { Text } from "../../../../components/text.js";
import { iconSize } from "../../../../design-system/index.js";
import { AccentFailIcon } from "../../../icons/AccentFailIcon.js";
import { SwapFlow } from "../swap/SwapFlow.js";
export function PostOnRampSwap(props) {
    const account = useActiveAccount();
    const [lockedOnRampQuote, setLockedOnRampQuote] = useState(undefined);
    const postOnRampQuoteQuery = useQuery({
        queryKey: ["getPostOnRampQuote", props.buyWithFiatStatus],
        queryFn: async () => {
            return await getPostOnRampQuote({
                client: props.client,
                buyWithFiatStatus: props.buyWithFiatStatus,
            });
        },
        // stop fetching if a quote is already locked
        enabled: !lockedOnRampQuote,
        refetchOnWindowFocus: false,
    });
    useEffect(() => {
        if (postOnRampQuoteQuery.data &&
            !lockedOnRampQuote &&
            !postOnRampQuoteQuery.isRefetching) {
            setLockedOnRampQuote(postOnRampQuoteQuery.data);
        }
    }, [
        postOnRampQuoteQuery.data,
        lockedOnRampQuote,
        postOnRampQuoteQuery.isRefetching,
    ]);
    if (postOnRampQuoteQuery.isError) {
        return (_jsxs(Container, { fullHeight: true, children: [_jsx(Container, { p: "lg", children: _jsx(ModalHeader, { title: "Buy", onBack: props.onBack }) }), _jsxs(Container, { style: {
                        minHeight: "300px",
                    }, flex: "column", center: "both", p: "lg", children: [_jsx(AccentFailIcon, { size: iconSize["3xl"] }), _jsx(Spacer, { y: "xl" }), _jsx(Text, { color: "primaryText", children: "Failed to get a price quote" }), _jsx(Spacer, { y: "lg" }), _jsx(Button, { fullWidth: true, variant: "primary", onClick: () => {
                                postOnRampQuoteQuery.refetch();
                            }, children: "Try Again" })] }), _jsx(Spacer, { y: "xxl" })] }));
    }
    if (!lockedOnRampQuote || !account) {
        return (_jsxs(Container, { fullHeight: true, children: [_jsx(Container, { p: "lg", children: _jsx(ModalHeader, { title: "Buy", onBack: props.onBack }) }), _jsxs(Container, { style: {
                        minHeight: "300px",
                    }, flex: "column", center: "both", children: [_jsx(Spinner, { size: "xxl", color: "accentText" }), _jsx(Spacer, { y: "xl" }), _jsx(Text, { color: "primaryText", children: "Getting price quote" })] }), _jsx(Spacer, { y: "xxl" })] }));
    }
    return (_jsx(SwapFlow, { account: account, buyWithCryptoQuote: lockedOnRampQuote, client: props.client, onBack: props.onBack, onViewPendingTx: props.onViewPendingTx, isFiatFlow: true, onDone: props.onDone, onTryAgain: () => {
            setLockedOnRampQuote(undefined);
            postOnRampQuoteQuery.refetch();
        }, isBuyForTx: props.isBuyForTx, isEmbed: props.isEmbed }));
}
//# sourceMappingURL=PostOnRampSwap.js.map