"use client";
import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import styled from "@emotion/styled";
import { CrossCircledIcon, MagnifyingGlassIcon } from "@radix-ui/react-icons";
import Fuse from "fuse.js";
import { memo, useCallback, useEffect, useMemo, useState } from "react";
import { convertApiChainToChain } from "../../../../chains/utils.js";
import { useChainQuery, useChainsQuery, } from "../../../core/hooks/others/useChainQuery.js";
import { useActiveWalletChain, useSwitchActiveWalletChain, } from "../../../core/hooks/wallets/wallet-hooks.js";
import { ChainIcon } from "../components/ChainIcon.js";
import { Skeleton } from "../components/Skeleton.js";
import { Spacer } from "../components/Spacer.js";
import { Spinner } from "../components/Spinner.js";
import { Container, Line, ModalHeader } from "../components/basic.js";
import { Button } from "../components/buttons.js";
import { Input } from "../components/formElements.js";
import { ModalTitle } from "../components/modalElements.js";
import { Text } from "../components/text.js";
import { useCustomTheme } from "../design-system/CustomThemeProvider.js";
import { StyledButton, StyledP, StyledUl } from "../design-system/elements.js";
import { fontSize, iconSize, media, radius, spacing, } from "../design-system/index.js";
import { useDebouncedValue } from "../hooks/useDebouncedValue.js";
import { useShowMore } from "../hooks/useShowMore.js";
let fuseInstances = undefined;
let fuseInitializationStarted = false;
// initialize fuse instances if not already initialized
function initializeFuseInstances() {
    if (fuseInitializationStarted) {
        return;
    }
    fuseInitializationStarted = true;
    const fuseConfig = {
        threshold: 0.4,
        keys: [
            {
                name: "name",
                weight: 1,
            },
            {
                name: "chainId",
                weight: 1,
            },
        ],
    };
    fuseInstances = {
        all: new Fuse([], fuseConfig),
        popular: new Fuse([], fuseConfig),
        recent: new Fuse([], fuseConfig),
    };
}
function useLoadChains(allChainsInput, popularChainIds, recentChainIds) {
    // load all chains with react query
    const chainsQueries = useChainsQuery(allChainsInput, 50);
    const isLoading = chainsQueries.some((q) => q.isLoading);
    const { allChains, chainsMap } = useMemo(() => {
        const _chains = [];
        const _chainsMap = new Map();
        if (isLoading) {
            return { allChains: [], chainsMap: _chainsMap };
        }
        for (const chainQuery of chainsQueries) {
            if (chainQuery.data) {
                _chains.push({
                    ...chainQuery.data,
                });
            }
        }
        for (const chain of _chains) {
            _chainsMap.set(chain.chainId, chain);
        }
        return { allChains: _chains, chainsMap: _chainsMap, isLoading: false };
    }, [chainsQueries, isLoading]);
    const recentChains = useMemo(() => {
        if (!recentChainIds) {
            return [];
        }
        const _recentChains = [];
        for (const chainId of recentChainIds) {
            const _chain = chainsMap.get(chainId);
            if (_chain) {
                _recentChains.push(_chain);
            }
        }
        return _recentChains;
    }, [recentChainIds, chainsMap]);
    const popularChains = useMemo(() => {
        if (!popularChainIds) {
            return [];
        }
        const _popularChains = [];
        for (const chainId of popularChainIds) {
            const _chain = chainsMap.get(chainId);
            if (_chain) {
                _popularChains.push(_chain);
            }
        }
        return _popularChains;
    }, [popularChainIds, chainsMap]);
    return {
        allChains,
        popularChains,
        recentChains,
        isLoading,
    };
}
/**
 * @internal
 */
export function NetworkSelectorContent(props) {
    const chainsData = useLoadChains(props.chains, props.networkSelector?.popularChainIds || [], props.networkSelector?.recentChainIds || []);
    initializeFuseInstances();
    return _jsx(NetworkSelectorContentInner, { ...props, chainsData: chainsData });
}
function NetworkSelectorContentInner(props) {
    const { chainsData, connectLocale } = props;
    const chainMap = useMemo(() => {
        const _chainMap = new Map();
        for (const chain of props.chains) {
            _chainMap.set(chain.id, chain);
        }
        return _chainMap;
    }, [props.chains]);
    const locale = connectLocale.networkSelector;
    const [searchTerm, setSearchTerm] = useState("");
    const [selectedTab, setSelectedTab] = useState("all");
    const deferredSearchTerm = useDebouncedValue(searchTerm, 300);
    const { onSwitch, onCustomClick } = props.networkSelector || {};
    const allChainsTab = useMemo(() => {
        return filterChainByType(chainsData.allChains, selectedTab);
    }, [chainsData.allChains, selectedTab]);
    const popularChainsTab = useMemo(() => {
        return filterChainByType(chainsData.popularChains, selectedTab);
    }, [chainsData.popularChains, selectedTab]);
    const recentChainsTab = useMemo(() => {
        return filterChainByType(chainsData.recentChains, selectedTab);
    }, [chainsData.recentChains, selectedTab]);
    // chains filtered by search term + type
    const allChainsFiltered = useMemo(() => {
        if (!fuseInstances) {
            return allChainsTab;
        }
        if (deferredSearchTerm === "") {
            return allChainsTab;
        }
        fuseInstances.all.setCollection(allChainsTab);
        return fuseInstances.all.search(deferredSearchTerm).map((r) => r.item);
    }, [allChainsTab, deferredSearchTerm]);
    const popularChainsFiltered = useMemo(() => {
        if (!fuseInstances) {
            return popularChainsTab;
        }
        if (deferredSearchTerm === "") {
            return popularChainsTab;
        }
        fuseInstances.popular.setCollection(popularChainsTab);
        return fuseInstances.popular.search(deferredSearchTerm).map((r) => r.item);
    }, [deferredSearchTerm, popularChainsTab]);
    const recentChainsFiltered = useMemo(() => {
        if (!fuseInstances) {
            return recentChainsTab;
        }
        if (deferredSearchTerm === "") {
            return recentChainsTab;
        }
        fuseInstances.recent.setCollection(recentChainsTab);
        return fuseInstances.recent.search(deferredSearchTerm).map((r) => r.item);
    }, [deferredSearchTerm, recentChainsTab]);
    const handleSwitch = useCallback((chain) => {
        if (onSwitch) {
            onSwitch(chain);
        }
        props.closeModal();
    }, [onSwitch, props]);
    const allChainsToShow = useMemo(() => {
        if (chainsData.isLoading) {
            return props.chains;
        }
        return allChainsFiltered.map(convertApiChainToChain);
    }, [allChainsFiltered, chainsData.isLoading, props.chains]);
    const popularChainsToShow = useMemo(() => {
        if (chainsData.isLoading) {
            return (props.networkSelector?.popularChainIds?.map((id) => chainMap.get(id)) || []);
        }
        return popularChainsFiltered.map(convertApiChainToChain);
    }, [
        chainMap,
        chainsData.isLoading,
        popularChainsFiltered,
        props.networkSelector?.popularChainIds,
    ]);
    const recentChainsToShow = useMemo(() => {
        if (chainsData.isLoading) {
            return (props.networkSelector?.recentChainIds?.map((id) => chainMap.get(id)) || []);
        }
        return recentChainsFiltered.map(convertApiChainToChain);
    }, [
        chainMap,
        chainsData.isLoading,
        props.networkSelector?.recentChainIds,
        recentChainsFiltered,
    ]);
    return (_jsxs(Container, { children: [_jsx(Container, { p: "lg", children: props.onBack ? (_jsx(ModalHeader, { title: locale.title, onBack: props.onBack })) : (_jsx(ModalTitle, { children: locale.title })) }), props.showTabs !== false && (_jsxs(_Fragment, { children: [_jsx(Container, { px: "lg", children: _jsxs(Container, { flex: "row", gap: "xxs", children: [_jsx(TabButton, { onClick: () => setSelectedTab("all"), "data-active": selectedTab === "all", children: locale.allNetworks }), _jsx(TabButton, { onClick: () => setSelectedTab("mainnet"), "data-active": selectedTab === "mainnet", children: locale.mainnets }), _jsx(TabButton, { onClick: () => setSelectedTab("testnet"), "data-active": selectedTab === "testnet", children: locale.testnets })] }) }), _jsx(Spacer, { y: "lg" })] })), props.showTabs === false && _jsx(Spacer, { y: "xxs" }), _jsx(Container, { px: "lg", children: _jsxs("div", { style: {
                        display: "flex",
                        alignItems: "center",
                        position: "relative",
                    }, children: [_jsx(StyledMagnifyingGlassIcon, { width: iconSize.md, height: iconSize.md }), _jsx(Input, { style: {
                                padding: `${spacing.sm} ${spacing.md} ${spacing.sm} ${spacing.xxl}`,
                            }, tabIndex: -1, variant: "outline", disabled: chainsData.isLoading, placeholder: chainsData.isLoading
                                ? "Loading chains..."
                                : locale.inputPlaceholder, value: searchTerm, onChange: (e) => {
                                setSearchTerm(e.target.value);
                            } }), (deferredSearchTerm !== searchTerm || chainsData.isLoading) && (_jsx("div", { style: {
                                position: "absolute",
                                right: spacing.md,
                            }, children: _jsx(Spinner, { size: "md", color: "accentText" }) }))] }) }), _jsx(Spacer, { y: "lg" }), _jsx(Container, { px: "md", children: _jsx(NetworkTabContent, { allChainIds: allChainsToShow, popularChainIds: popularChainsToShow, recentChainIds: recentChainsToShow, onSwitch: handleSwitch, renderChain: props.networkSelector?.renderChain, connectLocale: connectLocale, client: props.client }) }), onCustomClick && (_jsxs(_Fragment, { children: [_jsx(Line, {}), _jsx(Container, { p: "lg", children: _jsx(Button, { fullWidth: true, variant: "link", onClick: () => {
                                onCustomClick();
                            }, style: {
                                display: "flex",
                                fontSize: fontSize.sm,
                                boxShadow: "none",
                            }, children: locale.addCustomNetwork }) })] }))] }));
}
/**
 *
 * @internal
 */
const filterChainByType = (chains, type) => {
    if (type === "all") {
        return chains;
    }
    if (type === "testnet") {
        return chains.filter((c) => c.testnet);
    }
    return chains.filter((c) => !c.testnet);
};
/**
 *
 * @internal
 */
const NetworkTabContent = (props) => {
    const locale = props.connectLocale.networkSelector.categoryLabel;
    const { recentChainIds, popularChainIds, allChainIds } = props;
    const noChainsToShow = recentChainIds?.length === 0 &&
        popularChainIds?.length === 0 &&
        allChainIds.length === 0;
    return (_jsxs(Container, { scrollY: true, animate: "fadein", style: {
            height: "330px",
            paddingBottom: spacing.lg,
        }, children: [recentChainIds && recentChainIds.length > 0 && (_jsxs("div", { children: [_jsx(SectionLabel, { children: locale.recentlyUsed }), _jsx(Spacer, { y: "sm" }), _jsx(NetworkList, { chains: recentChainIds, onSwitch: props.onSwitch, renderChain: props.renderChain, close: props.close, client: props.client, connectLocale: props.connectLocale }), _jsx(Spacer, { y: "lg" })] })), popularChainIds && popularChainIds.length > 0 && (_jsxs("div", { children: [_jsx(SectionLabel, { children: locale.popular }), _jsx(Spacer, { y: "sm" }), _jsx(NetworkList, { chains: popularChainIds, onSwitch: props.onSwitch, renderChain: props.renderChain, close: props.close, client: props.client, connectLocale: props.connectLocale }), _jsx(Spacer, { y: "lg" })] })), ((popularChainIds && popularChainIds.length > 0) ||
                (recentChainIds && recentChainIds.length > 0)) && (_jsxs(_Fragment, { children: [_jsx(SectionLabel, { children: locale.others }), _jsx(Spacer, { y: "sm" })] })), _jsx(NetworkList, { chains: allChainIds, onSwitch: props.onSwitch, renderChain: props.renderChain, close: props.close, client: props.client, connectLocale: props.connectLocale }), noChainsToShow && (_jsxs(Container, { flex: "column", gap: "md", center: "both", color: "secondaryText", children: [_jsx(Spacer, { y: "xl" }), _jsx(CrossCircledIcon, { width: iconSize.xl, height: iconSize.xl }), _jsx(Text, { children: " No Results " })] }))] }));
};
const NetworkList = /* @__PURE__ */ memo(function NetworkList(props) {
    // show 10 items first, when reaching the last item, show 10 more
    const { itemsToShow, lastItemRef } = useShowMore(10, 10);
    const switchChain = useSwitchActiveWalletChain();
    const activeChain = useActiveWalletChain();
    const [switchingChainId, setSwitchingChainId] = useState(-1);
    const [errorSwitchingChainId, setErrorSwitchingChainId] = useState(-1);
    const close = props.close;
    useEffect(() => {
        // if switching and switched successfully - close modal
        if (switchingChainId !== -1 && activeChain?.id === switchingChainId) {
            if (close) {
                close();
            }
        }
    }, [switchingChainId, close, activeChain?.id]);
    const handleSwitch = async (chain) => {
        setErrorSwitchingChainId(-1);
        setSwitchingChainId(chain.id);
        try {
            await switchChain(chain);
            props.onSwitch(chain);
        }
        catch (e) {
            setErrorSwitchingChainId(chain.id);
            console.error(e);
        }
        finally {
            setSwitchingChainId(-1);
        }
    };
    const RenderChain = props.renderChain;
    const chainsToShow = props.chains.slice(0, itemsToShow);
    return (_jsx(NetworkListUl, { children: chainsToShow.map((chain, i) => {
            if (!chain) {
                return null;
            }
            const confirming = switchingChainId === chain.id;
            const switchingFailed = errorSwitchingChainId === chain.id;
            const isLast = i === chainsToShow.length - 1;
            return (_jsx("li", { ref: isLast ? lastItemRef : undefined, children: RenderChain ? (_jsx(RenderChain, { switchChain: () => {
                        handleSwitch(chain);
                    }, chain: chain, switching: switchingChainId === chain.id, switchFailed: errorSwitchingChainId === chain.id, close: props.close })) : (_jsx(ChainButton, { chain: chain, confirming: confirming, onClick: () => handleSwitch(chain), switchingFailed: switchingFailed, client: props.client, connectLocale: props.connectLocale })) }, chain.id));
        }) }));
});
export const ChainButton = /* @__PURE__ */ memo(function ChainButton(props) {
    const locale = props.connectLocale;
    const { chain, confirming, switchingFailed } = props;
    const activeChain = useActiveWalletChain();
    const { data: fetchedChain } = useChainQuery(chain);
    let chainName;
    if (fetchedChain) {
        chainName = _jsxs("span", { children: [fetchedChain.name, " "] });
    }
    else {
        chainName = _jsx(Skeleton, { width: "150px", height: "20px" });
    }
    return (_jsxs(NetworkButton, { "data-active": activeChain?.id === chain.id, onClick: props.onClick, children: [fetchedChain ? (_jsx(ChainIcon, { chainIcon: fetchedChain.icon, size: iconSize.lg, active: activeChain?.id === chain.id, loading: "lazy", client: props.client })) : (_jsx(Skeleton, { width: `${iconSize.lg}px`, height: `${iconSize.lg}px` })), confirming || switchingFailed ? (_jsxs("div", { style: {
                    display: "flex",
                    flexDirection: "column",
                    gap: spacing.xs,
                }, children: [chainName, _jsxs(Container, { animate: "fadein", flex: "row", gap: "xs", children: [confirming && (_jsxs(_Fragment, { children: [_jsx(Text, { size: "xs", color: "accentText", children: locale.confirmInWallet }), _jsx(Spinner, { size: "xs", color: "accentText" })] })), switchingFailed && (_jsx(Container, { animate: "fadein", children: _jsx(Text, { size: "xs", color: "danger", children: locale.networkSelector.failedToSwitch }) }))] })] })) : (chainName)] }));
});
const TabButton = /* @__PURE__ */ (() => styled.button(() => {
    const theme = useCustomTheme();
    return {
        all: "unset",
        fontSize: fontSize.sm,
        fontWeight: 500,
        color: theme.colors.secondaryText,
        cursor: "pointer",
        padding: `${spacing.sm} ${spacing.sm}`,
        WebkitTapHighlightColor: "transparent",
        borderRadius: radius.lg,
        transition: "background 0.2s ease, color 0.2s ease",
        "&[data-active='true']": {
            background: theme.colors.secondaryButtonBg,
            color: theme.colors.primaryText,
        },
    };
}))();
const SectionLabel = /* @__PURE__ */ StyledP(() => {
    const theme = useCustomTheme();
    return {
        fontSize: fontSize.sm,
        color: theme.colors.secondaryText,
        margin: 0,
        display: "block",
        padding: `0 ${spacing.xs}`,
    };
});
const NetworkListUl = /* @__PURE__ */ StyledUl({
    padding: 0,
    margin: 0,
    listStyle: "none",
    display: "flex",
    flexDirection: "column",
    gap: spacing.xs,
    boxSizing: "border-box",
});
const NetworkButton = /* @__PURE__ */ StyledButton(() => {
    const theme = useCustomTheme();
    return {
        all: "unset",
        display: "flex",
        width: "100%",
        boxSizing: "border-box",
        alignItems: "center",
        gap: spacing.md,
        padding: `${spacing.xs} ${spacing.sm}`,
        borderRadius: radius.md,
        cursor: "pointer",
        transition: "background 0.2s ease",
        color: theme.colors.primaryText,
        fontWeight: 500,
        fontSize: fontSize.md,
        "&:hover": {
            background: theme.colors.secondaryButtonBg,
        },
        [media.mobile]: {
            fontSize: fontSize.sm,
        },
    };
});
const StyledMagnifyingGlassIcon = /* @__PURE__ */ styled(MagnifyingGlassIcon)(() => {
    const theme = useCustomTheme();
    return {
        color: theme.colors.secondaryText,
        position: "absolute",
        left: spacing.sm,
    };
});
//# sourceMappingURL=NetworkSelector.js.map