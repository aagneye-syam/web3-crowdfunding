import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { CrossCircledIcon } from "@radix-ui/react-icons";
import { useState } from "react";
import { waitForReceipt } from "../../../../../../../transaction/actions/wait-for-tx-receipt.js";
import { formatNumber } from "../../../../../../../utils/formatNumber.js";
import { useSendTransactionCore } from "../../../../../../core/hooks/contract/useSendTransaction.js";
import { useChainQuery } from "../../../../../../core/hooks/others/useChainQuery.js";
import { useActiveWallet, useActiveWalletChain, } from "../../../../../../core/hooks/wallets/wallet-hooks.js";
import { Skeleton } from "../../../../components/Skeleton.js";
import { Spacer } from "../../../../components/Spacer.js";
import { Spinner } from "../../../../components/Spinner.js";
import { StepBar } from "../../../../components/StepBar.js";
import { SwitchNetworkButton } from "../../../../components/SwitchNetwork.js";
import { TokenIcon } from "../../../../components/TokenIcon.js";
import { Container, Line, ModalHeader } from "../../../../components/basic.js";
import { Button } from "../../../../components/buttons.js";
import { Text } from "../../../../components/text.js";
import { useCustomTheme } from "../../../../design-system/CustomThemeProvider.js";
import { StyledDiv } from "../../../../design-system/elements.js";
import { fontSize, iconSize } from "../../../../design-system/index.js";
import { Step } from "../Stepper.js";
import { SwapFees } from "./Fees.js";
import { formatSeconds } from "./formatSeconds.js";
import { addPendingTx } from "./pendingSwapTx.js";
/**
 * @internal
 */
export function SwapConfirmationScreen(props) {
    const sendTransactionMutation = useSendTransactionCore();
    const activeChain = useActiveWalletChain();
    const activeWallet = useActiveWallet();
    const isApprovalRequired = props.quote.approval !== undefined;
    const initialStep = isApprovalRequired ? "approval" : "swap";
    const [step, setStep] = useState(initialStep);
    const [status, setStatus] = useState("idle");
    return (_jsxs(Container, { p: "lg", children: [_jsx(ModalHeader, { title: "Buy", onBack: props.onBack }), props.isFiatFlow ? (_jsxs(_Fragment, { children: [_jsx(Spacer, { y: "lg" }), _jsx(StepBar, { steps: 2, currentStep: 2 }), _jsx(Spacer, { y: "sm" }), _jsxs(Text, { size: "xs", children: ["Step 2 of 2 - Converting ", props.fromTokenSymbol, " to", " ", props.toTokenSymbol] }), _jsx(Spacer, { y: "md" })] })) : (_jsx(Spacer, { y: "lg" })), _jsx(ConfirmItem, { label: "Receive", children: _jsx(RenderTokenInfo, { chain: props.toChain, amount: String(formatNumber(Number(props.toAmount), 4)), symbol: props.toTokenSymbol, token: props.toToken, client: props.client }) }), _jsx(ConfirmItem, { label: "Pay", children: _jsx(RenderTokenInfo, { chain: props.fromChain, amount: String(formatNumber(Number(props.fromAmount), 4)), symbol: props.fromTokenSymbol || "", token: props.fromToken, client: props.client }) }), _jsx(ConfirmItem, { label: "Fees", children: _jsx(SwapFees, { quote: props.quote, align: "right" }) }), _jsx(ConfirmItem, { label: "Time", children: _jsxs(Text, { color: "primaryText", children: ["~", formatSeconds(props.quote.swapDetails.estimated.durationSeconds || 0)] }) }), _jsx(Spacer, { y: "xl" }), isApprovalRequired && (_jsxs(_Fragment, { children: [_jsx(Spacer, { y: "sm" }), _jsxs(Container, { gap: "sm", flex: "row", style: {
                            justifyContent: "space-between",
                        }, center: "y", color: "accentText", children: [_jsx(Step, { isDone: step === "swap", isActive: step === "approval", label: step === "approval" ? "Approve" : "Approved" }), _jsx(ConnectorLine, {}), _jsx(Step, { isDone: false, label: "Confirm", isActive: step === "swap" })] }), _jsx(Spacer, { y: "lg" })] })), status === "error" && (_jsxs(_Fragment, { children: [_jsxs(Container, { flex: "row", gap: "xs", center: "both", color: "danger", children: [_jsx(CrossCircledIcon, { width: iconSize.sm, height: iconSize.sm }), _jsx(Text, { color: "danger", size: "sm", children: step === "approval" ? "Failed to Approve" : "Failed to Confirm" })] }), _jsx(Spacer, { y: "md" })] })), activeChain && activeChain.id !== props.fromChain.id ? (_jsx(SwitchNetworkButton, { fullWidth: true, chain: props.fromChain, variant: "accent" })) : (_jsxs(Button, { variant: "accent", fullWidth: true, disabled: status === "pending", onClick: async () => {
                    if (step === "approval" && props.quote.approval) {
                        try {
                            setStatus("pending");
                            const tx = await sendTransactionMutation.mutateAsync(props.quote.approval);
                            await waitForReceipt({ ...tx, maxBlocksWaitTime: 50 });
                            // props.onQuoteFinalized(props.quote);
                            setStep("swap");
                            setStatus("idle");
                        }
                        catch (e) {
                            console.error(e);
                            setStatus("error");
                        }
                    }
                    if (step === "swap") {
                        setStatus("pending");
                        try {
                            let tx = props.quote.transactionRequest;
                            // Fix for inApp wallet
                            // Ideally - the pay server sends a non-legacy transaction to avoid this issue
                            if (activeWallet?.id === "inApp" ||
                                activeWallet?.id === "embedded") {
                                tx = {
                                    ...props.quote.transactionRequest,
                                    gasPrice: undefined,
                                };
                            }
                            const _swapTx = await sendTransactionMutation.mutateAsync(tx);
                            await waitForReceipt({ ..._swapTx, maxBlocksWaitTime: 50 });
                            // do not add pending tx if the swap is part of fiat flow
                            if (!props.isFiatFlow) {
                                addPendingTx({
                                    type: "swap",
                                    txHash: _swapTx.transactionHash,
                                });
                            }
                            props.setSwapTxHash(_swapTx.transactionHash);
                        }
                        catch (e) {
                            console.error(e);
                            setStatus("error");
                        }
                    }
                }, gap: "xs", children: [step === "approval" &&
                        (status === "pending" ? "Approving" : "Approve"), step === "swap" && (status === "pending" ? "Confirming" : "Confirm"), status === "pending" && (_jsx(Spinner, { size: "sm", color: "accentButtonText" }))] }))] }));
}
const ConnectorLine = /* @__PURE__ */ StyledDiv(() => {
    const theme = useCustomTheme();
    return {
        height: "4px",
        background: theme.colors.borderColor,
        flex: 1,
    };
});
function RenderTokenInfo(props) {
    const chainQuery = useChainQuery(props.chain);
    return (_jsxs(Container, { flex: "column", gap: "xxs", style: {
            alignItems: "flex-end",
        }, children: [_jsxs(Container, { flex: "row", center: "y", gap: "xs", children: [_jsxs(Text, { color: "primaryText", size: "md", children: [props.amount, " ", props.symbol] }), _jsx(TokenIcon, { token: props.token, chain: props.chain, size: "sm", client: props.client })] }), chainQuery.data ? (_jsx(Text, { size: "sm", children: chainQuery.data.name })) : (_jsx(Skeleton, { width: "100px", height: fontSize.sm }))] }));
}
function ConfirmItem(props) {
    return (_jsxs(_Fragment, { children: [_jsxs(Container, { flex: "row", gap: "md", py: "md", style: {
                    justifyContent: "space-between",
                }, children: [_jsx(Text, { size: "md", color: "secondaryText", children: props.label }), props.children] }), _jsx(Line, {})] }));
}
//# sourceMappingURL=ConfirmationScreen.js.map