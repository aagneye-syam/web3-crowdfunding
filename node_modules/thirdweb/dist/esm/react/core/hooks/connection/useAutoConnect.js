"use client";
import { jsx as _jsx } from "react/jsx-runtime";
import { useEffect } from "react";
import { getLastConnectedChain, getStoredActiveWalletId, getStoredConnectedWalletIds, } from "../../../../wallets/manager/index.js";
import { asyncLocalStorage } from "../../../../wallets/storage/asyncLocalStorage.js";
import { connectionManager } from "../../connectionManager.js";
import { timeoutPromise } from "../../utils/timeoutPromise.js";
import { useConnect, useSetActiveWalletConnectionStatus, } from "../wallets/wallet-hooks.js";
let autoConnectAttempted = false;
/**
 * AutoConnect last connected wallet on page reload or revisit.
 * Note: If you are using `ConnectButton` or `ConnectEmbed` components, You don't need to use this component as it is already included.
 *
 * This is useful if you are manually connecting the wallets using the [`useConnect`](https://portal.thirdweb.com/references/typescript/v5/useConnect) hook and want to auto connect the last connected wallets on page reload or revisit.
 * @param props - Object of type `AutoConnectProps`. Refer to [`AutoConnectProps`](https://portal.thirdweb.com/references/typescript/v5/AutoConnectProps)
 * @example
 * ```tsx
 * import { AutoConnect } from "thirdweb/react";
 * import { createWallet, inAppWallet } from "thirdweb/wallets";
 *
 *
 * // list of wallets that your app uses
 * const wallets = [
 *  inAppWallet(),
 *  createWallet('io.metamask'),
 *  createWallet("me.rainbow"),
 * ]
 *
 * function Example() {
 *  return (
 *    <AutoConnect
 *      wallets={wallets}
 *      client={client}
 *      appMetadata={appMetadata}
 *    />
 *  );
 * }
 * ```
 * @component
 */
export function AutoConnect(props) {
    const setConnectionStatus = useSetActiveWalletConnectionStatus();
    const { connect } = useConnect({
        client: props.client,
        accountAbstraction: props.accountAbstraction,
    });
    const { isAutoConnecting } = connectionManager;
    const { wallets, onConnect } = props;
    const timeout = props.timeout ?? 15000;
    // get the supported wallets from thirdweb provider
    // check the storage for last connected wallets and connect them all
    // check the storage for last active wallet and set it as active
    useEffect(() => {
        if (autoConnectAttempted) {
            return;
        }
        autoConnectAttempted = true;
        const startAutoConnect = async () => {
            const [lastConnectedWalletIds, lastActiveWalletId] = await Promise.all([
                getStoredConnectedWalletIds(asyncLocalStorage),
                getStoredActiveWalletId(asyncLocalStorage),
            ]);
            // if no wallets were last connected
            if (!lastConnectedWalletIds) {
                return;
            }
            const lastConnectedChain = await getLastConnectedChain(asyncLocalStorage);
            async function handleWalletConnection(wallet) {
                return wallet.autoConnect({
                    client: props.client,
                    chain: lastConnectedChain ?? undefined,
                });
            }
            const activeWallet = lastActiveWalletId && wallets.find((w) => w.id === lastActiveWalletId);
            if (activeWallet) {
                try {
                    setConnectionStatus("connecting"); // only set connecting status if we are connecting the last active EOA
                    await timeoutPromise(handleWalletConnection(activeWallet), {
                        ms: timeout,
                        message: `AutoConnect timeout : ${timeout}ms limit exceeded.`,
                    });
                    // connected wallet could be activeWallet or smart wallet
                    const connectedWallet = await connect(activeWallet);
                    if (connectedWallet) {
                        if (onConnect) {
                            try {
                                onConnect(connectedWallet);
                            }
                            catch {
                                // ignore
                            }
                        }
                    }
                    else {
                        setConnectionStatus("disconnected");
                    }
                }
                catch (e) {
                    console.error("Failed to auto connect last active wallet");
                    console.error(e);
                    setConnectionStatus("disconnected");
                }
            }
            else {
                setConnectionStatus("disconnected");
            }
            // then connect wallets that were last connected but were not set as active
            const otherWallets = wallets.filter((w) => w.id !== lastActiveWalletId && lastConnectedWalletIds.includes(w.id));
            for (const wallet of otherWallets) {
                try {
                    await handleWalletConnection(wallet);
                    connectionManager.addConnectedWallet(wallet);
                }
                catch (e) {
                    console.error("Failed to auto connect a non-active connected wallet");
                    console.error(e);
                }
            }
        };
        (async () => {
            isAutoConnecting.setValue(true);
            await startAutoConnect();
            isAutoConnecting.setValue(false);
        })();
    });
    return _jsx("div", { children: " " });
}
let noAutoConnectDone = false;
/**
 * @internal
 */
export function NoAutoConnect() {
    const setConnectionStatus = useSetActiveWalletConnectionStatus();
    useEffect(() => {
        if (noAutoConnectDone) {
            return;
        }
        noAutoConnectDone = true;
        setConnectionStatus("disconnected");
    });
    return null;
}
//# sourceMappingURL=useAutoConnect.js.map