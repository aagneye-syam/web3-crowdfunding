"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifySignature = exports.verifyContractWalletSignature = exports.verifyEOASignature = void 0;
const viem_1 = require("viem");
const contract_js_1 = require("../contract/contract.js");
const isValidSignature_js_1 = require("../extensions/erc1271/__generated__/isValidSignature/read/isValidSignature.js");
const hex_js_1 = require("../utils/encoding/hex.js");
const hashMessage_js_1 = require("../utils/hashing/hashMessage.js");
/**
 * Verifies the signature of a message using an Ethereum account's EOA (Externally Owned Account).
 * @param options - The options for verifying the signature.
 * @returns A boolean indicating whether the signature is valid.
 * @throws An error if the signature is invalid.
 * @example
 * ```ts
 * import { verifyEOASignature } from 'thirdweb/auth';
 *
 * const isValid = await verifyEOASignature({
 *  message: '0x1234567890123456789012345678901234567890',
 *  signature: '0x1234567890123456789012345678901234567890',
 *  address: '0x1234567890123456789012345678901234567890',
 * });
 * ```
 * @auth
 */
async function verifyEOASignature(options) {
    const messageHash = (0, hashMessage_js_1.hashMessage)(options.message);
    if (!(0, hex_js_1.isHex)(options.signature)) {
        return false;
    }
    const recoveredAddress = await (0, viem_1.recoverAddress)({
        hash: messageHash,
        signature: options.signature,
    });
    if (recoveredAddress.toLowerCase() === options.address.toLowerCase()) {
        return true;
    }
    return false;
}
exports.verifyEOASignature = verifyEOASignature;
const EIP1271_MAGICVALUE = "0x1626ba7e";
/**
 * Verifies the signature of a contract wallet.
 * @param options - The parameters for verifying the signature.
 * @returns A boolean indicating whether the signature is valid.
 * @throws An error if the signature is invalid.
 * @example
 * ```ts
 * import { verifyContractWalletSignature } from 'thirdweb/auth';
 *
 * const isValid = await verifyContractWalletSignature({
 *  message: '0x1234567890123456789012345678901234567890',
 *  signature: '0x1234567890123456789012345678901234567890',
 *  address: '0x1234567890123456789012345678901234567890',
 *  chain: ...,
 *  client: ...,
 * });
 * ```
 * @auth
 */
async function verifyContractWalletSignature(options) {
    if (!(0, hex_js_1.isHex)(options.signature)) {
        throw new Error("Invalid signature");
    }
    const contract = (0, contract_js_1.getContract)({
        address: options.address,
        chain: options.chain,
        client: options.client,
    });
    const messageHash = (0, hashMessage_js_1.hashMessage)(options.message);
    const result = await (0, isValidSignature_js_1.isValidSignature)({
        contract,
        hash: messageHash,
        signature: options.signature,
    });
    return result === EIP1271_MAGICVALUE;
}
exports.verifyContractWalletSignature = verifyContractWalletSignature;
/**
 * Verifies the signature based on the provided options.
 * Handles smart contract wallet signatures and EOA signatures.
 * **IMPORTANT: in order to check smart contract signatures, a chain and client must be provided.**
 * @param options - The options for signature verification.
 * @returns A boolean indicating whether the signature is valid or not.
 * @example
 * ```ts
 * import { verifySignature } from 'thirdweb/auth';
 *
 * const isValid = await verifySignature({
 *  message: 'Your message to sign',
 *  signature: '0x91db0222ec371a8c18d3b187a6d2e77789bffca1b96826ef6b8708e0d4a66c80312fc3ae95b8fbc147265abf539bb6f360152be61a0e1411d7f5771a599e769a1c',
 *  address: '0xda9C7A86AeE76701FC1c23ae548e8E93Ba3e42A5',
 *  client: thirdwebClient,
 *  chain: chain
 * });
 * ```
 * @auth
 */
async function verifySignature(options) {
    try {
        const isValidEOASig = await verifyEOASignature(options);
        if (isValidEOASig) {
            return true;
        }
    }
    catch {
        // no-op, we skip to contract signature check
    }
    if (isVerifyContractWalletSignatureParams(options)) {
        try {
            return await verifyContractWalletSignature(options);
        }
        catch {
            // no-op we skip to return false
        }
    }
    // if we reach here, we have no way to verify the signature
    return false;
}
exports.verifySignature = verifySignature;
function isVerifyContractWalletSignatureParams(options) {
    return "chain" in options && "client" in options;
}
//# sourceMappingURL=verifySignature.js.map