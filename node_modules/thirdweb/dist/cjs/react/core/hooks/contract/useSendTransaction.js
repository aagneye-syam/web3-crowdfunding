"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTotalTxCostForBuy = exports.useSendTransactionCore = void 0;
const react_query_1 = require("@tanstack/react-query");
const estimate_gas_cost_js_1 = require("../../../../transaction/actions/estimate-gas-cost.js");
const send_transaction_js_1 = require("../../../../transaction/actions/send-transaction.js");
const resolve_promised_value_js_1 = require("../../../../utils/promise/resolve-promised-value.js");
const getWalletBalance_js_1 = require("../../../../wallets/utils/getWalletBalance.js");
const useSwapSupportedChains_js_1 = require("../../../web/ui/ConnectWallet/screens/Buy/swap/useSwapSupportedChains.js");
const wallet_hooks_js_1 = require("../wallets/wallet-hooks.js");
/**
 * A hook to send a transaction.
 * @returns A mutation object to send a transaction.
 * @example
 * ```jsx
 * import { useSendTransaction } from "thirdweb/react";
 * const { mutate: sendTx, data: transactionResult } = useSendTransaction();
 *
 * // later
 * sendTx(tx);
 * ```
 * @internal
 */
function useSendTransactionCore(showPayModal, gasless) {
    let _account = (0, wallet_hooks_js_1.useActiveAccount)();
    const wallet = (0, wallet_hooks_js_1.useActiveWallet)();
    const switchChain = (0, wallet_hooks_js_1.useSwitchActiveWalletChain)();
    return (0, react_query_1.useMutation)({
        mutationFn: async (tx) => {
            // switch chain if needed
            if (wallet && tx.chain.id !== wallet.getChain()?.id) {
                await switchChain(tx.chain);
                // in smart wallet case, account may change after chain switch
                _account = wallet.getAccount();
            }
            const account = _account;
            if (!account) {
                throw new Error("No active account");
            }
            if (!showPayModal) {
                return (0, send_transaction_js_1.sendTransaction)({
                    transaction: tx,
                    account,
                    gasless,
                });
            }
            return new Promise((resolve, reject) => {
                const sendTx = async () => {
                    try {
                        const res = await (0, send_transaction_js_1.sendTransaction)({
                            transaction: tx,
                            account,
                            gasless,
                        });
                        resolve(res);
                    }
                    catch (e) {
                        reject(e);
                    }
                };
                (async () => {
                    try {
                        const destinations = await (0, useSwapSupportedChains_js_1.fetchBuySupportedDestinations)(tx.client);
                        const isBuySupported = destinations.find((c) => c.chain.id === tx.chain.id);
                        // buy not supported, can't show modal - send tx directly
                        if (!isBuySupported) {
                            sendTx();
                            return;
                        }
                        //  buy supported, check if there is enouch balance - if not show modal to buy tokens
                        const [walletBalance, totalCostWei] = await Promise.all([
                            (0, getWalletBalance_js_1.getWalletBalance)({
                                address: account.address,
                                chain: tx.chain,
                                client: tx.client,
                            }),
                            getTotalTxCostForBuy(tx, account),
                        ]);
                        const walletBalanceWei = walletBalance.value;
                        // if enough balance, send tx
                        if (totalCostWei < walletBalanceWei) {
                            sendTx();
                            return;
                        }
                        // if not enough balance - show modal
                        showPayModal({
                            tx,
                            sendTx,
                            rejectTx: () => {
                                reject(new Error("Not enough balance"));
                            },
                            totalCostWei,
                            walletBalance,
                        });
                    }
                    catch (e) {
                        console.error("Failed to estimate cost", e);
                        // send it anyway?
                        sendTx();
                    }
                })();
            });
        },
    });
}
exports.useSendTransactionCore = useSendTransactionCore;
async function getTotalTxCostForBuy(tx, account) {
    const gasCost = await (0, estimate_gas_cost_js_1.estimateGasCost)({
        transaction: tx,
        account,
    });
    const bufferCost = gasCost.wei / 10n;
    // Note: get tx.value AFTER estimateGasCost
    const txValue = await (0, resolve_promised_value_js_1.resolvePromisedValue)(tx.value);
    // add 10% extra gas cost to the estimate to ensure user buys enough to cover the tx cost
    return gasCost.wei + bufferCost + (txValue || 0n);
}
exports.getTotalTxCostForBuy = getTotalTxCostForBuy;
//# sourceMappingURL=useSendTransaction.js.map