"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deployPublishedContract = void 0;
const contract_js_1 = require("../../contract/contract.js");
const publisher_js_1 = require("../../contract/deployment/publisher.js");
const send_and_confirm_transaction_js_1 = require("../../transaction/actions/send-and-confirm-transaction.js");
const simulate_js_1 = require("../../transaction/actions/simulate.js");
const prepare_contract_call_js_1 = require("../../transaction/prepare-contract-call.js");
const resolve_method_js_1 = require("../../transaction/resolve-method.js");
/**
 * Deploy an instance of a published contract on a given chain
 * @param options - the deploy options
 * @returns a promise that resolves to the deployed contract address
 * @example
 * ```ts
 * import { deployPublishedContract } from "thirdweb/deploys";
 *
 * const address = await deployedPublishedContract({
 *   client,
 *   chain,
 *   account,
 *   contractId: "MyPublishedContract",
 *   contractParams: [...],
 *   publisher: "0x...",
 * });
 * ```
 * @extension DEPLOY
 */
async function deployPublishedContract(options) {
    const { client, account, chain, contractId, contractParams, publisher, version, implementationConstructorParams, } = options;
    const { compilerMetadata, extendedMetadata } = await (0, publisher_js_1.fetchPublishedContractMetadata)({
        client,
        contractId,
        publisher,
        version,
    });
    switch (extendedMetadata?.deployType) {
        case "standard": {
            const { deployContract } = await Promise.resolve().then(() => require("../../contract/deployment/deploy-with-abi.js"));
            return deployContract({
                account,
                client,
                chain,
                bytecode: compilerMetadata.bytecode,
                constructorAbi: compilerMetadata.abi.find((i) => i.type === "constructor") || [],
                constructorParams: contractParams,
            });
        }
        case "autoFactory": {
            const [{ deployViaAutoFactory }, { getOrDeployInfraForPublishedContract },] = await Promise.all([
                Promise.resolve().then(() => require("../../contract/deployment/deploy-via-autofactory.js")),
                Promise.resolve().then(() => require("../../contract/deployment/utils/bootstrap.js")),
            ]);
            const { cloneFactoryContract, implementationContract } = await getOrDeployInfraForPublishedContract({
                chain,
                client,
                account,
                contractId,
                constructorParams: implementationConstructorParams || [],
                publisher,
            });
            const initializeTransaction = (0, prepare_contract_call_js_1.prepareContractCall)({
                contract: (0, contract_js_1.getContract)({
                    client,
                    chain,
                    address: implementationContract.address,
                }),
                method: (0, resolve_method_js_1.resolveMethod)(extendedMetadata.factoryDeploymentData
                    ?.implementationInitializerFunction || "initialize"),
                params: contractParams,
            });
            return deployViaAutoFactory({
                client,
                chain,
                account,
                cloneFactoryContract,
                initializeTransaction,
            });
        }
        case "customFactory": {
            if (!extendedMetadata?.factoryDeploymentData?.customFactoryInput) {
                throw new Error("No custom factory info found");
            }
            const factoryAddress = extendedMetadata?.factoryDeploymentData?.customFactoryInput
                ?.customFactoryAddresses?.[chain.id];
            const factoryFunction = extendedMetadata.factoryDeploymentData?.customFactoryInput
                ?.factoryFunction;
            if (!factoryAddress || !factoryFunction) {
                throw new Error(`No factory address found on chain ${chain.id}`);
            }
            const factory = (0, contract_js_1.getContract)({
                client,
                chain,
                address: factoryAddress,
            });
            const deployTx = (0, prepare_contract_call_js_1.prepareContractCall)({
                contract: factory,
                method: (0, resolve_method_js_1.resolveMethod)(factoryFunction),
                params: contractParams,
            });
            // asumption here is that the factory address returns the deployed proxy address
            const address = (0, simulate_js_1.simulateTransaction)({
                transaction: deployTx,
            });
            await (0, send_and_confirm_transaction_js_1.sendAndConfirmTransaction)({
                transaction: deployTx,
                account,
            });
            return address;
        }
        case undefined: {
            // Default to standard deployment if none was specified
            const { deployContract } = await Promise.resolve().then(() => require("../../contract/deployment/deploy-with-abi.js"));
            return deployContract({
                account,
                client,
                chain,
                bytecode: compilerMetadata.bytecode,
                constructorAbi: compilerMetadata.abi.find((i) => i.type === "constructor") || [],
                constructorParams: contractParams,
            });
        }
        default:
            // If a deployType was specified but we don't support it, throw an error
            throw new Error(`Unsupported deploy type: ${extendedMetadata?.deployType}`);
    }
}
exports.deployPublishedContract = deployPublishedContract;
//# sourceMappingURL=deploy-published.js.map