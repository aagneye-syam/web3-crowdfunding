"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.disconnectSmartWallet = exports.connectSmartWallet = exports.personalAccountToSmartAccountMap = exports.isSmartWallet = void 0;
const viem_1 = require("viem");
const contract_js_1 = require("../../contract/contract.js");
const bundler_js_1 = require("./lib/bundler.js");
const calls_js_1 = require("./lib/calls.js");
const constants_js_1 = require("./lib/constants.js");
const userop_js_1 = require("./lib/userop.js");
/**
 * Checks if the provided wallet is a smart wallet.
 *
 * @param wallet - The wallet to check.
 * @returns True if the wallet is a smart wallet, false otherwise.
 */
function isSmartWallet(wallet) {
    return wallet.id === "smart";
}
exports.isSmartWallet = isSmartWallet;
/**
 * We can get the personal account for given smart account but not the other way around - this map gives us the reverse lookup
 * @internal
 */
exports.personalAccountToSmartAccountMap = new WeakMap();
const smartWalletToPersonalAccountMap = new WeakMap();
/**
 * @internal
 */
async function connectSmartWallet(wallet, connectionOptions, creationOptions) {
    const { personalAccount, client, chain: connectChain } = connectionOptions;
    if (!personalAccount) {
        throw new Error("Personal wallet does not have an account");
    }
    const options = creationOptions;
    const factoryAddress = options.factoryAddress ?? constants_js_1.DEFAULT_ACCOUNT_FACTORY;
    const chain = connectChain ?? options.chain;
    const factoryContract = (0, contract_js_1.getContract)({
        client: client,
        address: factoryAddress,
        chain: chain,
    });
    // TODO: listen for chainChanged event on the personal wallet and emit the disconnect event on the smart wallet
    const accountAddress = await (0, calls_js_1.predictAddress)(factoryContract, {
        personalAccountAddress: personalAccount.address,
        ...options,
    })
        .then((address) => address)
        .catch(() => {
        throw new Error(`Failed to get account address with factory contract ${factoryContract.address} on chain ID ${chain.id}. Are you on the right chain?`);
    });
    const accountContract = (0, contract_js_1.getContract)({
        client,
        address: accountAddress,
        chain,
    });
    const sponsorGas = "gasless" in options ? options.gasless : options.sponsorGas;
    const account = await createSmartAccount({
        ...options,
        chain,
        sponsorGas,
        personalAccount,
        accountContract,
        factoryContract,
        client,
    });
    exports.personalAccountToSmartAccountMap.set(personalAccount, wallet);
    smartWalletToPersonalAccountMap.set(wallet, personalAccount);
    return [account, chain];
}
exports.connectSmartWallet = connectSmartWallet;
/**
 * @internal
 */
async function disconnectSmartWallet(wallet) {
    // look up the personalAccount for the smart wallet
    const personalAccount = smartWalletToPersonalAccountMap.get(wallet);
    if (personalAccount) {
        // remove the mappings
        exports.personalAccountToSmartAccountMap.delete(personalAccount);
        smartWalletToPersonalAccountMap.delete(wallet);
    }
}
exports.disconnectSmartWallet = disconnectSmartWallet;
async function createSmartAccount(options) {
    const { accountContract } = options;
    const account = {
        address: accountContract.address,
        async sendTransaction(transaction) {
            const executeTx = (0, calls_js_1.prepareExecute)({
                accountContract,
                options,
                transaction,
            });
            return _sendUserOp({
                executeTx,
                options,
            });
        },
        async sendBatchTransaction(transactions) {
            const executeTx = (0, calls_js_1.prepareBatchExecute)({
                accountContract,
                options,
                transactions,
            });
            return _sendUserOp({
                executeTx,
                options,
            });
        },
        async signMessage({ message }) {
            const [{ isContractDeployed }, { readContract }, { encodeAbiParameters }, { hashMessage }, { checkContractWalletSignature },] = await Promise.all([
                Promise.resolve().then(() => require("../../utils/bytecode/is-contract-deployed.js")),
                Promise.resolve().then(() => require("../../transaction/read-contract.js")),
                Promise.resolve().then(() => require("../../utils/abi/encodeAbiParameters.js")),
                Promise.resolve().then(() => require("../../utils/hashing/hashMessage.js")),
                Promise.resolve().then(() => require("../../extensions/erc1271/checkContractWalletSignature.js")),
            ]);
            const isDeployed = await isContractDeployed(accountContract);
            if (!isDeployed) {
                console.log("Account contract not deployed yet. Deploying account before signing message");
                await _deployAccount({
                    options,
                    account,
                    accountContract,
                });
            }
            const originalMsgHash = hashMessage(message);
            // check if the account contract supports EIP721 domain separator based signing
            let factorySupports712 = false;
            try {
                // this will throw if the contract does not support it (old factories)
                await readContract({
                    contract: accountContract,
                    method: "function getMessageHash(bytes32 _hash) public view returns (bytes32)",
                    params: [originalMsgHash],
                });
                factorySupports712 = true;
            }
            catch (e) {
                // ignore
            }
            let sig;
            if (factorySupports712) {
                const wrappedMessageHash = encodeAbiParameters([{ type: "bytes32" }], [originalMsgHash]);
                sig = await options.personalAccount.signTypedData({
                    domain: {
                        name: "Account",
                        version: "1",
                        chainId: options.chain.id,
                        verifyingContract: accountContract.address,
                    },
                    primaryType: "AccountMessage",
                    types: { AccountMessage: [{ name: "message", type: "bytes" }] },
                    message: { message: wrappedMessageHash },
                });
            }
            else {
                sig = await options.personalAccount.signMessage({ message });
            }
            const isValid = await checkContractWalletSignature({
                contract: accountContract,
                message,
                signature: sig,
            });
            if (isValid) {
                return sig;
            }
            throw new Error("Unable to verify signature on smart account, please make sure the smart account is deployed and the signature is valid.");
        },
        async signTypedData(_typedData) {
            const [{ isContractDeployed }, { readContract }, { encodeAbiParameters }, { checkContractWalletSignedTypedData },] = await Promise.all([
                Promise.resolve().then(() => require("../../utils/bytecode/is-contract-deployed.js")),
                Promise.resolve().then(() => require("../../transaction/read-contract.js")),
                Promise.resolve().then(() => require("../../utils/abi/encodeAbiParameters.js")),
                Promise.resolve().then(() => require("../../extensions/erc1271/checkContractWalletSignedTypedData.js")),
            ]);
            const isSelfVerifyingContract = _typedData.domain?.verifyingContract?.toLowerCase() ===
                accountContract.address?.toLowerCase();
            if (isSelfVerifyingContract) {
                // if the contract is self-verifying, we can just sign the message with the EOA (ie. adding a session key)
                return options.personalAccount.signTypedData(_typedData);
            }
            const isDeployed = await isContractDeployed(accountContract);
            if (!isDeployed) {
                console.log("Account contract not deployed yet. Deploying account before signing message");
                await _deployAccount({
                    options,
                    account,
                    accountContract,
                });
            }
            const originalMsgHash = (0, viem_1.hashTypedData)(_typedData);
            // check if the account contract supports EIP721 domain separator based signing
            let factorySupports712 = false;
            try {
                // this will throw if the contract does not support it (old factories)
                await readContract({
                    contract: accountContract,
                    method: "function getMessageHash(bytes32 _hash) public view returns (bytes32)",
                    params: [originalMsgHash],
                });
                factorySupports712 = true;
            }
            catch (e) {
                // ignore
            }
            let sig;
            if (factorySupports712) {
                const wrappedMessageHash = encodeAbiParameters([{ type: "bytes32" }], [originalMsgHash]);
                sig = await options.personalAccount.signTypedData({
                    domain: {
                        name: "Account",
                        version: "1",
                        chainId: options.chain.id,
                        verifyingContract: accountContract.address,
                    },
                    primaryType: "AccountMessage",
                    types: { AccountMessage: [{ name: "message", type: "bytes" }] },
                    message: { message: wrappedMessageHash },
                });
            }
            else {
                sig = await options.personalAccount.signTypedData(_typedData);
            }
            const isValid = await checkContractWalletSignedTypedData({
                contract: accountContract,
                data: _typedData,
                signature: sig,
            });
            if (isValid) {
                return sig;
            }
            throw new Error("Unable to verify signature on smart account, please make sure the smart account is deployed and the signature is valid.");
        },
    };
    return account;
}
async function _deployAccount(args) {
    const { options, account, accountContract } = args;
    const [{ sendTransaction }, { prepareTransaction }] = await Promise.all([
        Promise.resolve().then(() => require("../../transaction/actions/send-transaction.js")),
        Promise.resolve().then(() => require("../../transaction/prepare-transaction.js")),
    ]);
    const dummyTx = prepareTransaction({
        client: options.client,
        chain: options.chain,
        to: accountContract.address,
        value: 0n,
    });
    const deployResult = await sendTransaction({
        transaction: dummyTx,
        account,
    });
    return deployResult;
}
async function _sendUserOp(args) {
    const { executeTx, options } = args;
    const unsignedUserOp = await (0, userop_js_1.createUnsignedUserOp)({
        executeTx,
        options,
    });
    const signedUserOp = await (0, userop_js_1.signUserOp)({
        options,
        userOp: unsignedUserOp,
    });
    const userOpHash = await (0, bundler_js_1.bundleUserOp)({
        options,
        userOp: signedUserOp,
    });
    // wait for tx receipt rather than return the userOp hash
    const receipt = await waitForUserOpReceipt({
        options,
        userOpHash,
    });
    return {
        client: options.client,
        chain: options.chain,
        transactionHash: receipt.transactionHash,
    };
}
async function waitForUserOpReceipt(args) {
    const { options, userOpHash } = args;
    const timeout = 120000; // 2mins
    const interval = 1000;
    const endtime = Date.now() + timeout;
    while (Date.now() < endtime) {
        const userOpReceipt = await (0, bundler_js_1.getUserOpReceipt)({ options, userOpHash });
        if (userOpReceipt) {
            return userOpReceipt;
        }
        await new Promise((resolve) => setTimeout(resolve, interval));
    }
    throw new Error("Timeout waiting for userOp to be mined");
}
//# sourceMappingURL=index.js.map