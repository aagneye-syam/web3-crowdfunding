"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUserOpReceipt = exports.getUserOpGasPrice = exports.estimateUserOpGas = exports.bundleUserOp = void 0;
const viem_1 = require("viem");
const parse_logs_js_1 = require("../../../event/actions/parse-logs.js");
const UserOperationRevertReason_js_1 = require("../../../extensions/erc4337/__generated__/IEntryPoint/events/UserOperationRevertReason.js");
const hex_js_1 = require("../../../utils/encoding/hex.js");
const fetch_js_1 = require("../../../utils/fetch.js");
const constants_js_1 = require("./constants.js");
const utils_js_1 = require("./utils.js");
/**
 * @internal
 */
async function bundleUserOp(args) {
    return sendBundlerRequest({
        ...args,
        operation: "eth_sendUserOperation",
        params: [
            (0, utils_js_1.hexlifyUserOp)(args.userOp),
            args.options.overrides?.entrypointAddress ?? constants_js_1.ENTRYPOINT_ADDRESS_v0_6,
        ],
    });
}
exports.bundleUserOp = bundleUserOp;
/**
 * @internal
 */
async function estimateUserOpGas(args) {
    const res = await sendBundlerRequest({
        ...args,
        operation: "eth_estimateUserOperationGas",
        params: [
            (0, utils_js_1.hexlifyUserOp)(args.userOp),
            args.options.overrides?.entrypointAddress ?? constants_js_1.ENTRYPOINT_ADDRESS_v0_6,
        ],
    });
    // add gas buffer for managed account factory delegate calls
    return {
        preVerificationGas: (0, hex_js_1.hexToBigInt)(res.preVerificationGas),
        verificationGas: (0, hex_js_1.hexToBigInt)(res.verificationGas),
        verificationGasLimit: (0, hex_js_1.hexToBigInt)(res.verificationGasLimit),
        callGasLimit: (0, hex_js_1.hexToBigInt)(res.callGasLimit) + constants_js_1.MANAGED_ACCOUNT_GAS_BUFFER,
    };
}
exports.estimateUserOpGas = estimateUserOpGas;
/**
 * @internal
 */
async function getUserOpGasPrice(args) {
    const res = await sendBundlerRequest({
        ...args,
        operation: "thirdweb_getUserOperationGasPrice",
        params: [],
    });
    return {
        maxPriorityFeePerGas: (0, hex_js_1.hexToBigInt)(res.maxPriorityFeePerGas),
        maxFeePerGas: (0, hex_js_1.hexToBigInt)(res.maxFeePerGas),
    };
}
exports.getUserOpGasPrice = getUserOpGasPrice;
/**
 * @internal
 */
async function getUserOpReceipt(args) {
    const res = await sendBundlerRequest({
        ...args,
        operation: "eth_getUserOperationReceipt",
        params: [args.userOpHash],
    });
    if (!res) {
        return undefined;
    }
    if (res.success === false) {
        // parse revert reason
        const logs = (0, parse_logs_js_1.parseEventLogs)({
            events: [(0, UserOperationRevertReason_js_1.userOperationRevertReasonEvent)()],
            logs: res.logs,
        });
        const revertReason = logs[0]?.args?.revertReason;
        if (!revertReason) {
            throw new Error(`UserOp failed at txHash: ${res.transactionHash}`);
        }
        const revertMsg = (0, viem_1.decodeErrorResult)({
            data: revertReason,
        });
        throw new Error(`UserOp failed with reason: '${revertMsg.args.join(",")}' at txHash: ${res.transactionHash}`);
    }
    return res.receipt;
}
exports.getUserOpReceipt = getUserOpReceipt;
async function sendBundlerRequest(args) {
    const { options, operation, params } = args;
    if (constants_js_1.DEBUG) {
        console.debug(`>>> sending ${operation} with payload:`, params);
    }
    const bundlerUrl = options.overrides?.bundlerUrl ?? (0, constants_js_1.getDefaultBundlerUrl)(options.chain);
    const fetchWithHeaders = (0, fetch_js_1.getClientFetch)(options.client);
    const response = await fetchWithHeaders(bundlerUrl, {
        method: "POST",
        headers: {
            "Content-Type": "application/json",
        },
        body: JSON.stringify({
            jsonrpc: "2.0",
            id: 1,
            method: operation,
            params,
        }),
    });
    const res = await response.json();
    if (!response.ok || res.error) {
        let error = res.error || response.statusText;
        if (typeof error === "object") {
            error = JSON.stringify(error);
        }
        const code = res.code || "UNKNOWN";
        throw new Error(`${operation} error: ${error}
Status: ${response.status}
Code: ${code}`);
    }
    if (constants_js_1.DEBUG) {
        console.debug(`<<< ${operation} result:`, res);
    }
    return res.result;
}
//# sourceMappingURL=bundler.js.map