"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareBatchExecute = exports.prepareExecute = exports.prepareCreateAccount = exports.predictAddress = void 0;
const prepare_contract_call_js_1 = require("../../../transaction/prepare-contract-call.js");
const read_contract_js_1 = require("../../../transaction/read-contract.js");
const hex_js_1 = require("../../../utils/encoding/hex.js");
/**
 * @internal
 */
async function predictAddress(factoryContract, options) {
    if (options.overrides?.predictAddress) {
        return options.overrides.predictAddress(factoryContract);
    }
    if (options.overrides?.accountAddress) {
        return options.overrides.accountAddress;
    }
    const adminAddress = options.personalAccountAddress;
    if (!adminAddress) {
        throw new Error("Account address is required to predict the smart wallet address.");
    }
    const extraData = (0, hex_js_1.stringToHex)(options.overrides?.accountSalt ?? "");
    return (0, read_contract_js_1.readContract)({
        contract: factoryContract,
        method: "function getAddress(address, bytes) returns (address)",
        params: [adminAddress, extraData],
    });
}
exports.predictAddress = predictAddress;
/**
 * @internal
 */
function prepareCreateAccount(args) {
    const { factoryContract, options } = args;
    if (options.overrides?.createAccount) {
        return options.overrides.createAccount(factoryContract);
    }
    return (0, prepare_contract_call_js_1.prepareContractCall)({
        contract: factoryContract,
        method: "function createAccount(address, bytes) returns (address)",
        params: [
            options.personalAccount.address,
            (0, hex_js_1.stringToHex)(options.overrides?.accountSalt ?? ""),
        ],
    });
}
exports.prepareCreateAccount = prepareCreateAccount;
/**
 * @internal
 */
function prepareExecute(args) {
    const { accountContract, options, transaction } = args;
    if (options.overrides?.execute) {
        return options.overrides.execute(accountContract, transaction);
    }
    return (0, prepare_contract_call_js_1.prepareContractCall)({
        contract: accountContract,
        method: "function execute(address, uint256, bytes)",
        params: [
            transaction.to || "",
            transaction.value || 0n,
            transaction.data || "0x",
        ],
    });
}
exports.prepareExecute = prepareExecute;
/**
 * @internal
 */
function prepareBatchExecute(args) {
    const { accountContract, options, transactions } = args;
    if (options.overrides?.executeBatch) {
        return options.overrides.executeBatch(accountContract, transactions);
    }
    return (0, prepare_contract_call_js_1.prepareContractCall)({
        contract: accountContract,
        method: "function executeBatch(address[], uint256[], bytes[])",
        params: [
            transactions.map((tx) => tx.to || ""),
            transactions.map((tx) => tx.value || 0n),
            transactions.map((tx) => tx.data || "0x"),
        ],
    });
}
exports.prepareBatchExecute = prepareBatchExecute;
//# sourceMappingURL=calls.js.map