"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.autoConnectCoinbaseWalletSDK = exports.connectCoinbaseWalletSDK = exports.coinbaseSDKWalletGetCallsStatus = exports.coinbaseSDKWalletShowCallsStatus = exports.coinbaseSDKWalletSendCalls = exports.coinbaseSDKWalletGetCapabilities = exports.isCoinbaseSDKWallet = void 0;
const wallet_sdk_1 = require("@coinbase/wallet-sdk");
const viem_1 = require("viem");
const json_js_1 = require("../../utils/json.js");
const chains_js_1 = require("../utils/chains.js");
const normalizeChainId_js_1 = require("../utils/normalizeChainId.js");
const utils_js_1 = require("../../chains/utils.js");
const address_js_1 = require("../../utils/address.js");
const hex_js_1 = require("../../utils/encoding/hex.js");
const constants_js_1 = require("../constants.js");
const defaultDappMetadata_js_1 = require("../utils/defaultDappMetadata.js");
// Need to keep the provider around because it keeps a single popup window connection behind the scenes
// this should be ok since all the creation options are provided at build time
let _provider;
async function getCoinbaseProvider(options) {
    if (!_provider) {
        const client = new wallet_sdk_1.CoinbaseWalletSDK({
            appName: options?.appMetadata?.name || (0, defaultDappMetadata_js_1.getDefaultAppMetadata)().name,
            appChainIds: options?.chains
                ? options.chains.map((c) => c.id)
                : undefined,
            appLogoUrl: options?.appMetadata?.logoUrl || (0, defaultDappMetadata_js_1.getDefaultAppMetadata)().logoUrl,
        });
        const provider = client.makeWeb3Provider(options?.walletConfig);
        _provider = provider;
        return provider;
    }
    return _provider;
}
/**
 * Checks if the provided wallet is a Coinbase SDK wallet.
 *
 * @param wallet - The wallet to check.
 * @returns True if the wallet is a Coinbase SDK wallet, false otherwise.
 */
function isCoinbaseSDKWallet(wallet) {
    return wallet.id === constants_js_1.COINBASE;
}
exports.isCoinbaseSDKWallet = isCoinbaseSDKWallet;
/**
 * @internal
 */
async function coinbaseSDKWalletGetCapabilities(args) {
    const { wallet } = args;
    const account = wallet.getAccount();
    if (!account) {
        return {
            message: `Can't get capabilities, no account connected for wallet: ${wallet.id}`,
        };
    }
    const config = wallet.getConfig();
    const provider = await getCoinbaseProvider(config);
    try {
        return (await provider.request({
            method: "wallet_getCapabilities",
            params: [account.address],
        }));
    }
    catch (error) {
        if (/unsupport|not support/i.test(error.message)) {
            return {
                message: `${wallet.id} does not support wallet_getCapabilities, reach out to them directly to request EIP-5792 support.`,
            };
        }
        throw error;
    }
}
exports.coinbaseSDKWalletGetCapabilities = coinbaseSDKWalletGetCapabilities;
/**
 * @internal
 */
async function coinbaseSDKWalletSendCalls(args) {
    const { wallet, params } = args;
    const config = wallet.getConfig();
    const provider = await getCoinbaseProvider(config);
    try {
        return (await provider.request({
            method: "wallet_sendCalls",
            params,
        }));
    }
    catch (error) {
        if (/unsupport|not support/i.test(error.message)) {
            throw new Error(`${wallet.id} does not support wallet_sendCalls, reach out to them directly to request EIP-5792 support.`);
        }
        throw error;
    }
}
exports.coinbaseSDKWalletSendCalls = coinbaseSDKWalletSendCalls;
/**
 * @internal
 */
async function coinbaseSDKWalletShowCallsStatus(args) {
    const { wallet, bundleId } = args;
    const provider = await getCoinbaseProvider(wallet.getConfig());
    try {
        return await provider.request({
            method: "wallet_showCallsStatus",
            params: [bundleId],
        });
    }
    catch (error) {
        if (/unsupport|not support/i.test(error.message)) {
            throw new Error(`${wallet.id} does not support wallet_showCallsStatus, reach out to them directly to request EIP-5792 support.`);
        }
        throw error;
    }
}
exports.coinbaseSDKWalletShowCallsStatus = coinbaseSDKWalletShowCallsStatus;
/**
 * @internal
 */
async function coinbaseSDKWalletGetCallsStatus(args) {
    const { wallet, bundleId } = args;
    const config = wallet.getConfig();
    const provider = await getCoinbaseProvider(config);
    return provider.request({
        method: "wallet_getCallsStatus",
        params: [bundleId],
    });
}
exports.coinbaseSDKWalletGetCallsStatus = coinbaseSDKWalletGetCallsStatus;
function onConnect(address, chain, provider, emitter) {
    const account = {
        address,
        async sendTransaction(tx) {
            const transactionHash = (await provider.request({
                method: "eth_sendTransaction",
                params: [
                    {
                        accessList: tx.accessList,
                        value: tx.value ? (0, hex_js_1.numberToHex)(tx.value) : undefined,
                        gas: tx.gas ? (0, hex_js_1.numberToHex)(tx.gas) : undefined,
                        from: this.address,
                        to: tx.to,
                        data: tx.data,
                    },
                ],
            }));
            return {
                transactionHash,
            };
        },
        async signMessage({ message }) {
            if (!account.address) {
                throw new Error("Provider not setup");
            }
            const messageToSign = (() => {
                if (typeof message === "string") {
                    return (0, hex_js_1.stringToHex)(message);
                }
                if (message.raw instanceof Uint8Array) {
                    return (0, hex_js_1.uint8ArrayToHex)(message.raw);
                }
                return message.raw;
            })();
            return await provider.request({
                method: "personal_sign",
                params: [messageToSign, account.address],
            });
        },
        async signTypedData(typedData) {
            if (!account.address) {
                throw new Error("Provider not setup");
            }
            const { domain, message, primaryType } = typedData;
            const types = {
                EIP712Domain: (0, viem_1.getTypesForEIP712Domain)({ domain }),
                ...typedData.types,
            };
            // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc
            // as we can't statically check this with TypeScript.
            (0, viem_1.validateTypedData)({ domain, message, primaryType, types });
            const stringifiedData = (0, json_js_1.stringify)({ domain: domain ?? {}, message, primaryType, types }, (_, value) => ((0, hex_js_1.isHex)(value) ? value.toLowerCase() : value));
            return await provider.request({
                method: "eth_signTypedData_v4",
                params: [account.address, stringifiedData],
            });
        },
    };
    async function disconnect() {
        provider.removeListener("accountsChanged", onAccountsChanged);
        provider.removeListener("chainChanged", onChainChanged);
        provider.removeListener("disconnect", onDisconnect);
        await provider.disconnect();
    }
    function onDisconnect() {
        disconnect();
        emitter.emit("disconnect", undefined);
    }
    function onAccountsChanged(accounts) {
        if (accounts[0]) {
            const newAccount = {
                ...account,
                address: (0, address_js_1.getAddress)(accounts[0]),
            };
            emitter.emit("accountChanged", newAccount);
            emitter.emit("accountsChanged", accounts);
        }
        else {
            onDisconnect();
        }
    }
    function onChainChanged(newChainId) {
        const newChain = (0, utils_js_1.getCachedChain)((0, normalizeChainId_js_1.normalizeChainId)(newChainId));
        emitter.emit("chainChanged", newChain);
    }
    // subscribe to events
    provider.on("accountsChanged", onAccountsChanged);
    provider.on("chainChanged", onChainChanged);
    provider.on("disconnect", onDisconnect);
    return [
        account,
        chain,
        disconnect,
        (newChain) => switchChainCoinbaseWalletSDK(provider, newChain),
    ];
}
/**
 * @internal
 */
async function connectCoinbaseWalletSDK(options, createOptions, emitter) {
    const provider = await getCoinbaseProvider(createOptions);
    const accounts = (await provider.request({
        method: "eth_requestAccounts",
    }));
    if (!accounts[0]) {
        throw new Error("No accounts found");
    }
    const address = (0, address_js_1.getAddress)(accounts[0]);
    const connectedChainId = (await provider.request({
        method: "eth_chainId",
    }));
    const chainId = (0, normalizeChainId_js_1.normalizeChainId)(connectedChainId);
    let chain = options.chain && options.chain.id === chainId
        ? options.chain
        : (0, utils_js_1.getCachedChain)(chainId);
    // Switch to chain if provided
    if (connectedChainId &&
        options?.chain &&
        connectedChainId !== options?.chain.id) {
        await switchChainCoinbaseWalletSDK(provider, options.chain);
        chain = options.chain;
    }
    return onConnect(address, chain, provider, emitter);
}
exports.connectCoinbaseWalletSDK = connectCoinbaseWalletSDK;
/**
 * @internal
 */
async function autoConnectCoinbaseWalletSDK(options, createOptions, emitter) {
    const provider = await getCoinbaseProvider(createOptions);
    // connected accounts
    const addresses = (await provider.request({
        method: "eth_accounts",
    }));
    const address = addresses[0];
    if (!address) {
        throw new Error("No accounts found");
    }
    const connectedChainId = (await provider.request({
        method: "eth_chainId",
    }));
    const chainId = (0, normalizeChainId_js_1.normalizeChainId)(connectedChainId);
    const chain = options.chain && options.chain.id === chainId
        ? options.chain
        : (0, utils_js_1.getCachedChain)(chainId);
    return onConnect(address, chain, provider, emitter);
}
exports.autoConnectCoinbaseWalletSDK = autoConnectCoinbaseWalletSDK;
async function switchChainCoinbaseWalletSDK(provider, chain) {
    const chainIdHex = (0, hex_js_1.numberToHex)(chain.id);
    try {
        await provider.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: chainIdHex }],
        });
    }
    catch (error) {
        const apiChain = await (0, utils_js_1.getChainMetadata)(chain);
        // Indicates chain is not added to provider
        // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later
        if (error?.code === 4902) {
            // try to add the chain
            await provider.request({
                method: "wallet_addEthereumChain",
                params: [
                    {
                        chainId: chainIdHex,
                        chainName: apiChain.name,
                        nativeCurrency: apiChain.nativeCurrency,
                        rpcUrls: (0, chains_js_1.getValidPublicRPCUrl)(apiChain), // no client id on purpose here
                        blockExplorerUrls: apiChain.explorers?.map((x) => x.url) || [],
                    },
                ],
            });
        }
    }
}
//# sourceMappingURL=coinbaseSDKWallet.js.map