"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasStoredPasskey = exports.loginWithPasskey = exports.registerPasskey = void 0;
const webauthn_1 = require("@passwordless-id/webauthn");
const domains_js_1 = require("../../../../../utils/domains.js");
const fetch_js_1 = require("../../../../../utils/fetch.js");
const LocalStorage_js_1 = require("../../utils/Storage/LocalStorage.js");
function getVerificationPath() {
    return `${(0, domains_js_1.getThirdwebBaseUrl)("inAppWallet")}/api/2024-05-05/login/passkey/callback`;
}
function getChallengePath(type, username) {
    return `${(0, domains_js_1.getThirdwebBaseUrl)("inAppWallet")}/api/2024-05-05/login/passkey?type=${type}${username ? `&username=${username}` : ""}`;
}
async function registerPasskey(options) {
    if (!webauthn_1.client.isAvailable()) {
        throw new Error("Passkeys are not available on this device");
    }
    // TODO inject this
    const storage = new LocalStorage_js_1.LocalStorage({ clientId: options.client.clientId });
    const fetchWithId = (0, fetch_js_1.getClientFetch)(options.client);
    const generatedName = options.username ?? generateUsername();
    // 1. request challenge from  server
    const res = await fetchWithId(getChallengePath("sign-up", generatedName));
    const challengeData = await res.json();
    if (!challengeData.challenge) {
        throw new Error("No challenge received");
    }
    const challenge = challengeData.challenge;
    // 2. initiate registration
    const registration = await webauthn_1.client.register(generatedName, challenge, {
        authenticatorType: options.authenticatorType ?? "auto",
        userVerification: "required",
        attestation: true,
        debug: false,
    });
    // 3. store the credentialId in local storage
    await storage.savePasskeyCredentialId(registration.credential.id);
    // 4. send the registration object to the server
    const verifRes = await fetchWithId(getVerificationPath(), {
        method: "POST",
        headers: {
            "Content-Type": "application/json",
        },
        body: JSON.stringify({
            type: "sign-up",
            authenticatorData: registration.authenticatorData,
            credentialId: registration.credential.id,
            serverVerificationId: challengeData.serverVerificationId,
            clientData: registration.clientData,
            username: generatedName,
            credential: {
                publicKey: registration.credential.publicKey,
                algorithm: registration.credential.algorithm,
            },
        }),
    });
    const verifData = await verifRes.json();
    if (!verifData) {
        throw new Error("No token received");
    }
    // 5. returns back the IAW authentication token
    return verifData;
}
exports.registerPasskey = registerPasskey;
async function loginWithPasskey(options) {
    if (!webauthn_1.client.isAvailable()) {
        throw new Error("Passkeys are not available on this device");
    }
    // TODO inject this
    const storage = new LocalStorage_js_1.LocalStorage({ clientId: options.client.clientId });
    const fetchWithId = (0, fetch_js_1.getClientFetch)(options.client);
    // 1. request challenge from  server/iframe
    const res = await fetchWithId(getChallengePath("sign-in"));
    const challengeData = await res.json();
    if (!challengeData.challenge) {
        throw new Error("No challenge received");
    }
    const challenge = challengeData.challenge;
    // 1.2. find the user's credentialId in local storage
    const credentialId = await storage.getPasskeyCredentialId();
    const credentials = credentialId ? [credentialId] : [];
    // 2. initiate login
    const authentication = await webauthn_1.client.authenticate(credentials, challenge, {
        authenticatorType: options.authenticatorType ?? "auto",
        userVerification: "required",
    });
    // 3. send the authentication object to the server/iframe
    const verifRes = await fetchWithId(getVerificationPath(), {
        method: "POST",
        headers: {
            "Content-Type": "application/json",
        },
        body: JSON.stringify({
            type: "sign-in",
            authenticatorData: authentication.authenticatorData,
            credentialId: authentication.credentialId,
            serverVerificationId: challengeData.serverVerificationId,
            clientData: authentication.clientData,
            signature: authentication.signature,
        }),
    });
    // 5. store the credentialId in local storage
    await storage.savePasskeyCredentialId(authentication.credentialId);
    const verifData = await verifRes.json();
    if (!verifData) {
        throw new Error("No token received");
    }
    // 6. return the auth'd user type
    return verifData;
}
exports.loginWithPasskey = loginWithPasskey;
/**
 * Returns whether this device has a stored passkey ready to be used for sign-in
 * @param client - the thirdweb client
 * @returns whether the device has a stored passkey
 */
async function hasStoredPasskey(client) {
    const storage = new LocalStorage_js_1.LocalStorage({ clientId: client.clientId });
    const credId = await storage.getPasskeyCredentialId();
    return !!credId;
}
exports.hasStoredPasskey = hasStoredPasskey;
function generateUsername() {
    return `wallet-${new Date().toISOString()}`;
}
//# sourceMappingURL=passkeys.js.map