"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.inAppWallet = exports.smartWallet = exports.walletConnect = exports.createWallet = void 0;
const track_js_1 = require("../analytics/track.js");
const contract_js_1 = require("../contract/contract.js");
const is_contract_deployed_js_1 = require("../utils/bytecode/is-contract-deployed.js");
const constants_js_1 = require("./constants.js");
const constants_js_2 = require("./smart/lib/constants.js");
const wallet_emitter_js_1 = require("./wallet-emitter.js");
// TODO: figure out how to define the type without tuple args type and using function overloads
/**
 * Creates a wallet based on the provided ID and arguments.
 * @param args - The arguments for creating the wallet.
 * @returns - The created wallet.
 * @example
 * ```ts
 * import { createWallet } from "thirdweb/wallets";
 *
 * const metamaskWallet = createWallet("io.metamask");
 *
 * const account = await metamaskWallet.connect({
 *  client,
 * });
 * ```
 * @wallet
 */
function createWallet(...args) {
    const [id, creationOptions] = args;
    switch (id) {
        /**
         * SMART WALLET
         */
        case "smart": {
            return smartWallet(creationOptions);
        }
        /**
         * IN-APP WALLET
         */
        case "embedded":
        case "inApp": {
            return inAppWallet(creationOptions);
        }
        /**
         * COINBASE WALLET VIA SDK
         * -> if no injected coinbase found, we'll use the coinbase SDK
         */
        case constants_js_1.COINBASE: {
            return coinbaseWalletSDK(creationOptions);
        }
        /**
         * WALLET CONNECT AND INJECTED WALLETS + walletConnect standalone
         */
        default: {
            const emitter = (0, wallet_emitter_js_1.createWalletEmitter)();
            let account = undefined;
            let chain = undefined;
            const unsubscribeChain = emitter.subscribe("chainChanged", (newChain) => {
                chain = newChain;
            });
            function reset() {
                account = undefined;
                chain = undefined;
            }
            let handleDisconnect = async () => { };
            const unsubscribeDisconnect = emitter.subscribe("disconnect", () => {
                reset();
                unsubscribeChain();
                unsubscribeDisconnect();
            });
            emitter.subscribe("accountChanged", (_account) => {
                account = _account;
            });
            let handleSwitchChain = async () => {
                throw new Error("Not implemented yet");
            };
            const wallet = {
                id,
                subscribe: emitter.subscribe,
                getConfig: () => args[1],
                getChain: () => chain,
                getAccount: () => account,
                autoConnect: async (options) => {
                    const { injectedProvider } = await Promise.resolve().then(() => require("./injected/mipdStore.js"));
                    // injected wallet priority for autoConnect
                    if (id !== "walletConnect" && injectedProvider(id)) {
                        const { autoConnectInjectedWallet } = await Promise.resolve().then(() => require("./injected/index.js"));
                        const [connectedAccount, connectedChain, doDisconnect, doSwitchChain,] = await autoConnectInjectedWallet(id, emitter, options.chain);
                        // set the states
                        account = connectedAccount;
                        chain = connectedChain;
                        handleDisconnect = doDisconnect;
                        handleSwitchChain = doSwitchChain;
                        (0, track_js_1.trackConnect)({
                            client: options.client,
                            walletType: id,
                            walletAddress: account.address,
                        });
                        // return account
                        return account;
                    }
                    if (options && "client" in options) {
                        const { autoConnectWC } = await Promise.resolve().then(() => require("./wallet-connect/index.js"));
                        const [connectedAccount, connectedChain, doDisconnect, doSwitchChain,] = await autoConnectWC(options, emitter, wallet.id);
                        // set the states
                        account = connectedAccount;
                        chain = connectedChain;
                        handleDisconnect = doDisconnect;
                        handleSwitchChain = doSwitchChain;
                        (0, track_js_1.trackConnect)({
                            client: options.client,
                            walletType: id,
                            walletAddress: account.address,
                        });
                        // return account
                        return account;
                    }
                    throw new Error("Failed to auto connect");
                },
                connect: async (options) => {
                    async function wcConnect(wcOptions) {
                        const { connectWC } = await Promise.resolve().then(() => require("./wallet-connect/index.js"));
                        const [connectedAccount, connectedChain, doDisconnect, doSwitchChain,] = await connectWC(wcOptions, emitter, wallet.id);
                        // set the states
                        account = connectedAccount;
                        chain = connectedChain;
                        handleDisconnect = doDisconnect;
                        handleSwitchChain = doSwitchChain;
                        (0, track_js_1.trackConnect)({
                            client: wcOptions.client,
                            walletType: id,
                            walletAddress: account.address,
                        });
                        return account;
                    }
                    if (id === "walletConnect") {
                        const { client, chain: _chain, ...walletConnectOptions } = options;
                        return wcConnect({
                            client,
                            chain: _chain,
                            walletConnect: {
                                ...walletConnectOptions,
                            },
                        });
                    }
                    // prefer walletconnect over injected for connect (more explicit)
                    if (options && "walletConnect" in options) {
                        return wcConnect(options);
                    }
                    const { injectedProvider } = await Promise.resolve().then(() => require("./injected/mipdStore.js"));
                    if (injectedProvider(id)) {
                        const { connectInjectedWallet } = await Promise.resolve().then(() => require("./injected/index.js"));
                        const [connectedAccount, connectedChain, doDisconnect, doSwitchChain,] = await connectInjectedWallet(id, options, emitter);
                        // set the states
                        account = connectedAccount;
                        chain = connectedChain;
                        handleDisconnect = doDisconnect;
                        handleSwitchChain = doSwitchChain;
                        (0, track_js_1.trackConnect)({
                            client: options.client,
                            walletType: id,
                            walletAddress: account.address,
                        });
                        // return account
                        return account;
                    }
                    throw new Error("Failed to connect");
                },
                // these get overridden in connect and autoConnect
                disconnect: async () => {
                    reset();
                    await handleDisconnect();
                },
                switchChain: (c) => handleSwitchChain(c),
            };
            return wallet;
        }
    }
}
exports.createWallet = createWallet;
/**
 * Creates a wallet that allows connecting to any wallet that supports the WalletConnect protocol.
 * @returns The created smart wallet.
 * @example
 * ```ts
 * import { walletConnect } from "thirdweb/wallets";
 *
 * const wallet = walletConnect();
 *
 * const account = await wallet.connect({
 *  client
 * });
 * ```
 * @wallet
 */
function walletConnect() {
    return createWallet("walletConnect");
}
exports.walletConnect = walletConnect;
/**
 * Creates a smart wallet.
 * @param createOptions - The options for creating the wallet.
 * @returns The created smart wallet.
 * @example
 * ```ts
 * import { smartWallet } from "thirdweb/wallets";
 *
 * const wallet = smartWallet({
 *  factoryAddress: "0x1234...",
 *  chain: sepolia,
 *  gasless: true,
 * });
 *
 * const account = await wallet.connect({
 *   client,
 *   personalAccount: account,
 * });
 * ```
 * @wallet
 */
function smartWallet(createOptions) {
    const emitter = (0, wallet_emitter_js_1.createWalletEmitter)();
    let account = undefined;
    let chain = undefined;
    let lastConnectOptions;
    const _smartWallet = {
        id: "smart",
        subscribe: emitter.subscribe,
        getChain: () => chain,
        getConfig: () => createOptions,
        getAccount: () => account,
        autoConnect: async (options) => {
            const { connectSmartWallet } = await Promise.resolve().then(() => require("./smart/index.js"));
            const [connectedAccount, connectedChain] = await connectSmartWallet(_smartWallet, options, createOptions);
            // set the states
            lastConnectOptions = options;
            account = connectedAccount;
            chain = connectedChain;
            (0, track_js_1.trackConnect)({
                client: options.client,
                walletType: "smart",
                walletAddress: account.address,
            });
            // return account
            return account;
        },
        connect: async (options) => {
            const { connectSmartWallet } = await Promise.resolve().then(() => require("./smart/index.js"));
            const [connectedAccount, connectedChain] = await connectSmartWallet(_smartWallet, options, createOptions);
            // set the states
            lastConnectOptions = options;
            account = connectedAccount;
            chain = connectedChain;
            (0, track_js_1.trackConnect)({
                client: options.client,
                walletType: "smart",
                walletAddress: account.address,
            });
            // return account
            emitter.emit("accountChanged", account);
            return account;
        },
        disconnect: async () => {
            account = undefined;
            chain = undefined;
            const { disconnectSmartWallet } = await Promise.resolve().then(() => require("./smart/index.js"));
            await disconnectSmartWallet(_smartWallet);
            emitter.emit("disconnect", undefined);
        },
        switchChain: async (newChain) => {
            if (!lastConnectOptions) {
                throw new Error("Cannot switch chain without a previous connection");
            }
            // check if factory is deployed
            const factory = (0, contract_js_1.getContract)({
                address: createOptions.factoryAddress || constants_js_2.DEFAULT_ACCOUNT_FACTORY,
                chain: newChain,
                client: lastConnectOptions.client,
            });
            const isDeployed = await (0, is_contract_deployed_js_1.isContractDeployed)(factory);
            if (!isDeployed) {
                throw new Error(`Factory contract not deployed on chain: ${newChain.id}`);
            }
            const { connectSmartWallet } = await Promise.resolve().then(() => require("./smart/index.js"));
            const [connectedAccount, connectedChain] = await connectSmartWallet(_smartWallet, { ...lastConnectOptions, chain: newChain }, createOptions);
            // set the states
            account = connectedAccount;
            chain = connectedChain;
            emitter.emit("chainChanged", newChain);
        },
    };
    return _smartWallet;
}
exports.smartWallet = smartWallet;
/**
 * Creates an in-app wallet.
 * @param createOptions - configuration options
 * @returns The created in-app wallet.
 * @example
 * ```ts
 * import { inAppWallet } from "thirdweb/wallets";
 *
 * const wallet = inAppWallet();
 *
 * const account = await wallet.connect({
 *   client,
 *   chain,
 *   strategy: "google",
 * });
 * ```
 * Enable smart accounts and sponsor gas for your users:
 * ```ts
 * import { inAppWallet } from "thirdweb/wallets";
 * const wallet = inAppWallet({
 *  smartAccount: {
 *   chain: sepolia,
 *   sponsorGas: true,
 * },
 * });
 * ```
 *
 * Specify a logo for your login page
 * ```ts
 * import { inAppWallet } from "thirdweb/wallets";
 * const wallet = inAppWallet({
 *  metadata: {
 *   image: {
 *    src: "https://example.com/logo.png",
 *    alt: "My logo",
 *    width: 100,
 *    height: 100,
 *   },
 *  },
 * });
 * ```
 * @wallet
 */
function inAppWallet(createOptions) {
    const emitter = (0, wallet_emitter_js_1.createWalletEmitter)();
    let account = undefined;
    let chain = undefined;
    let client;
    return {
        id: "inApp",
        subscribe: emitter.subscribe,
        getChain: () => chain,
        getConfig: () => createOptions,
        getAccount: () => account,
        autoConnect: async (options) => {
            const { autoConnectInAppWallet } = await Promise.resolve().then(() => require("./in-app/core/wallet/index.js"));
            const [connectedAccount, connectedChain] = await autoConnectInAppWallet(options, createOptions);
            // set the states
            client = options.client;
            account = connectedAccount;
            chain = connectedChain;
            (0, track_js_1.trackConnect)({
                client: options.client,
                walletType: "inApp",
                walletAddress: account.address,
            });
            // return only the account
            return account;
        },
        connect: async (options) => {
            const { connectInAppWallet } = await Promise.resolve().then(() => require("./in-app/core/wallet/index.js"));
            const [connectedAccount, connectedChain] = await connectInAppWallet(options, createOptions);
            // set the states
            client = options.client;
            account = connectedAccount;
            chain = connectedChain;
            (0, track_js_1.trackConnect)({
                client: options.client,
                walletType: "inApp",
                walletAddress: account.address,
            });
            // return only the account
            return account;
        },
        disconnect: async () => {
            // simply un-set the states
            account = undefined;
            chain = undefined;
            emitter.emit("disconnect", undefined);
        },
        switchChain: async (newChain) => {
            if (createOptions?.smartAccount && client && account) {
                // if account abstraction is enabled, reconnect to smart account on the new chain
                const { autoConnectInAppWallet } = await Promise.resolve().then(() => require("./in-app/core/wallet/index.js"));
                const [connectedAccount, connectedChain] = await autoConnectInAppWallet({
                    chain: newChain,
                    client,
                }, createOptions);
                account = connectedAccount;
                chain = connectedChain;
            }
            else {
                // if not, simply set the new chain
                chain = newChain;
            }
            emitter.emit("chainChanged", newChain);
        },
    };
}
exports.inAppWallet = inAppWallet;
/**
 * internal helper functions
 */
function coinbaseWalletSDK(createOptions) {
    const emitter = (0, wallet_emitter_js_1.createWalletEmitter)();
    let account = undefined;
    let chain = undefined;
    function reset() {
        account = undefined;
        chain = undefined;
    }
    let handleDisconnect = async () => { };
    let handleSwitchChain = async (newChain) => {
        chain = newChain;
    };
    const unsubscribeChainChanged = emitter.subscribe("chainChanged", (newChain) => {
        chain = newChain;
    });
    const unsubscribeDisconnect = emitter.subscribe("disconnect", () => {
        reset();
        unsubscribeChainChanged();
        unsubscribeDisconnect();
    });
    emitter.subscribe("accountChanged", (_account) => {
        account = _account;
    });
    return {
        id: constants_js_1.COINBASE,
        subscribe: emitter.subscribe,
        getChain: () => chain,
        getConfig: () => createOptions,
        getAccount: () => account,
        autoConnect: async (options) => {
            const { autoConnectCoinbaseWalletSDK } = await Promise.resolve().then(() => require("./coinbase/coinbaseSDKWallet.js"));
            const [connectedAccount, connectedChain, doDisconnect, doSwitchChain] = await autoConnectCoinbaseWalletSDK(options, createOptions, emitter);
            // set the states
            account = connectedAccount;
            chain = connectedChain;
            handleDisconnect = doDisconnect;
            handleSwitchChain = doSwitchChain;
            (0, track_js_1.trackConnect)({
                client: options.client,
                walletType: constants_js_1.COINBASE,
                walletAddress: account.address,
            });
            // return account
            return account;
        },
        connect: async (options) => {
            const { connectCoinbaseWalletSDK } = await Promise.resolve().then(() => require("./coinbase/coinbaseSDKWallet.js"));
            const [connectedAccount, connectedChain, doDisconnect, doSwitchChain] = await connectCoinbaseWalletSDK(options, createOptions, emitter);
            // set the states
            account = connectedAccount;
            chain = connectedChain;
            handleDisconnect = doDisconnect;
            handleSwitchChain = doSwitchChain;
            (0, track_js_1.trackConnect)({
                client: options.client,
                walletType: constants_js_1.COINBASE,
                walletAddress: account.address,
            });
            // return account
            return account;
        },
        disconnect: async () => {
            reset();
            await handleDisconnect();
        },
        switchChain: async (newChain) => {
            await handleSwitchChain(newChain);
        },
    };
}
//# sourceMappingURL=create-wallet.js.map