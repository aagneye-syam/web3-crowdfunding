"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getClaimParams = void 0;
const viem_1 = require("viem");
const addresses_js_1 = require("../../../constants/addresses.js");
async function getClaimParams(options) {
    const cc = await (async () => {
        if (options.type === "erc1155") {
            // lazy-load the getActiveClaimCondition function
            const { getActiveClaimCondition } = await Promise.resolve().then(() => require("../../../extensions/erc1155/drops/read/getActiveClaimCondition.js"));
            return await getActiveClaimCondition({
                contract: options.contract,
                tokenId: options.tokenId,
            });
        }
        if (options.type === "erc721") {
            // lazy-load the getActiveClaimCondition function
            const { getActiveClaimCondition } = await Promise.resolve().then(() => require("../../../extensions/erc721/drops/read/getActiveClaimCondition.js"));
            return await getActiveClaimCondition({
                contract: options.contract,
            });
        }
        // otherwise erc20 case!
        // lazy-load the getActiveClaimCondition function
        const { getActiveClaimCondition } = await Promise.resolve().then(() => require("../../../extensions/erc721/drops/read/getActiveClaimCondition.js"));
        return await getActiveClaimCondition({
            contract: options.contract,
        });
    })();
    // compute the allowListProof in an iife
    const allowlistProof = await (async () => {
        // early exit if no merkle root is set
        if (!cc.merkleRoot || cc.merkleRoot === (0, viem_1.padHex)("0x", { size: 32 })) {
            return {
                currency: addresses_js_1.ADDRESS_ZERO,
                proof: [],
                quantityLimitPerWallet: 0n,
                pricePerToken: viem_1.maxUint256,
            };
        }
        // lazy-load the fetchProofsForClaimer function if we need it
        const { fetchProofsForClaimer } = await Promise.resolve().then(() => require("./fetch-proofs-for-claimers.js"));
        const allowListProof = await fetchProofsForClaimer({
            contract: options.contract,
            claimer: options.from || options.to, // receiver and claimer can be different, always prioritize the claimer for allowlists
            merkleRoot: cc.merkleRoot,
            tokenDecimals: options.type === "erc20" ? options.tokenDecimals : 0, // nfts have no decimals
        });
        // if no proof is found, we'll try the empty proof
        if (!allowListProof) {
            return {
                currency: addresses_js_1.ADDRESS_ZERO,
                proof: [],
                quantityLimitPerWallet: 0n,
                pricePerToken: viem_1.maxUint256,
            };
        }
        // otherwise return the proof
        return allowListProof;
    })();
    // currency and price need to match the allowlist proof if set
    // if default values in the allowlist proof, fallback to the claim condition
    const currency = allowlistProof.currency && allowlistProof.currency !== addresses_js_1.ADDRESS_ZERO
        ? allowlistProof.currency
        : cc.currency;
    const pricePerToken = allowlistProof.pricePerToken !== undefined &&
        allowlistProof.pricePerToken !== viem_1.maxUint256
        ? allowlistProof.pricePerToken
        : cc.pricePerToken;
    return {
        receiver: options.to,
        tokenId: options.type === "erc1155" ? options.tokenId : undefined,
        quantity: options.quantity,
        currency,
        pricePerToken,
        allowlistProof,
        data: "0x",
        overrides: {
            value: (0, addresses_js_1.isNativeTokenAddress)(currency)
                ? pricePerToken * BigInt(options.quantity)
                : 0n,
        },
    };
}
exports.getClaimParams = getClaimParams;
//# sourceMappingURL=get-claim-params.js.map