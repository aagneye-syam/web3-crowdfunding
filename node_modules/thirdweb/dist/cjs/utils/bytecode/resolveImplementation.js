"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveImplementation = void 0;
const get_bytecode_js_1 = require("../../contract/actions/get-bytecode.js");
const eth_getStorageAt_js_1 = require("../../rpc/actions/eth_getStorageAt.js");
const rpc_js_1 = require("../../rpc/rpc.js");
const read_contract_js_1 = require("../../transaction/read-contract.js");
const address_js_1 = require("../address.js");
const extractMnimalProxyImplementationAddress_js_1 = require("./extractMnimalProxyImplementationAddress.js");
// TODO: move to const exports
const AddressZero = "0x0000000000000000000000000000000000000000";
/**
 * Resolves the implementation address and bytecode for a given proxy contract.
 * @param contract The contract to resolve the implementation for.
 * @returns A promise that resolves to an object containing the implementation address and bytecode.
 * @example
 * ```ts
 * import { resolveImplementation } from "thirdweb";
 * const implementation = await resolveImplementation(contract);
 * ```
 * @contract
 */
async function resolveImplementation(
// biome-ignore lint/suspicious/noExplicitAny: TODO: fix any
contract) {
    const [originalBytecode, beacon] = await Promise.all([
        (0, get_bytecode_js_1.getBytecode)(contract),
        getBeaconFromStorageSlot(contract),
    ]);
    // check minimal proxy first synchronously
    const minimalProxyImplementationAddress = (0, extractMnimalProxyImplementationAddress_js_1.extractMinimalProxyImplementationAddress)(originalBytecode);
    if (minimalProxyImplementationAddress) {
        return {
            address: minimalProxyImplementationAddress,
            bytecode: await (0, get_bytecode_js_1.getBytecode)({
                ...contract,
                address: minimalProxyImplementationAddress,
            }),
        };
    }
    // check other proxy types
    if (beacon && beacon !== AddressZero) {
        // In case of a BeaconProxy, it is setup as BeaconProxy --> Beacon --> Implementation
        // Hence we replace the proxy address with Beacon address, and continue further resolving below
        // biome-ignore lint/style/noParameterAssign: we purposefully mutate the contract object here
        contract = { ...contract, address: beacon };
    }
    const implementations = await Promise.all([
        getImplementationFromStorageSlot(contract),
        getImplementationFromContractCall(contract),
    ]);
    // this seems inefficient
    for (const implementationAddress of implementations) {
        if (implementationAddress &&
            (0, address_js_1.isAddress)(implementationAddress) &&
            implementationAddress !== AddressZero) {
            const implementationBytecode = await (0, get_bytecode_js_1.getBytecode)({
                ...contract,
                address: implementationAddress,
            });
            // return the original contract bytecode if the implementation bytecode is empty
            if (implementationBytecode === "0x") {
                return {
                    address: contract.address,
                    bytecode: originalBytecode,
                };
            }
            return {
                address: implementationAddress,
                bytecode: implementationBytecode,
            };
        }
    }
    return { address: contract.address, bytecode: originalBytecode };
}
exports.resolveImplementation = resolveImplementation;
async function getBeaconFromStorageSlot(
// biome-ignore lint/suspicious/noExplicitAny: TODO: fix any
contract) {
    /**
     * The storage slot of the Beacon as defined in EIP-1967
     * See https://eips.ethereum.org/EIPS/eip-1967#beacon-contract-address
     *
     * bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1))
     */
    const rpcRequest = (0, rpc_js_1.getRpcClient)({
        client: contract.client,
        chain: contract.chain,
    });
    try {
        const proxyStorage = await (0, eth_getStorageAt_js_1.eth_getStorageAt)(rpcRequest, {
            address: contract.address,
            position: "0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50",
        });
        return `0x${proxyStorage.slice(-40)}`;
    }
    catch {
        return undefined;
    }
}
async function getImplementationFromStorageSlot(
// biome-ignore lint/suspicious/noExplicitAny: TODO: fix any
contract) {
    const rpcRequest = (0, rpc_js_1.getRpcClient)({
        client: contract.client,
        chain: contract.chain,
    });
    try {
        const proxyStorage = await (0, eth_getStorageAt_js_1.eth_getStorageAt)(rpcRequest, {
            address: contract.address,
            position: "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc",
        });
        return `0x${proxyStorage.slice(-40)}`;
    }
    catch {
        return undefined;
    }
}
const UPGRADEABLE_PROXY_ABI = {
    type: "function",
    name: "implementation",
    inputs: [],
    outputs: [
        {
            type: "address",
            name: "",
            internalType: "address",
        },
    ],
    stateMutability: "view",
};
async function getImplementationFromContractCall(
// biome-ignore lint/suspicious/noExplicitAny: TODO: fix any
contract) {
    try {
        return await (0, read_contract_js_1.readContract)({ contract, method: UPGRADEABLE_PROXY_ABI });
    }
    catch {
        return undefined;
    }
}
//# sourceMappingURL=resolveImplementation.js.map