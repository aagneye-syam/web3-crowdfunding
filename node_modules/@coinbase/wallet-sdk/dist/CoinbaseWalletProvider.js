"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoinbaseWalletProvider = void 0;
const eventemitter3_1 = __importDefault(require("eventemitter3"));
const error_1 = require("./core/error");
const type_1 = require("./core/type");
const util_1 = require("./core/type/util");
const SignHandler_1 = require("./sign/SignHandler");
const provider_1 = require("./util/provider");
const method_1 = require("./core/provider/method");
const FilterPolyfill_1 = require("./util/FilterPolyfill");
class CoinbaseWalletProvider extends eventemitter3_1.default {
    constructor(params) {
        var _a, _b;
        super();
        this.accounts = [];
        this.handlers = {
            // eth_requestAccounts
            handshake: async (_) => {
                try {
                    const accounts = this.connected // already connected
                        ? this.accounts
                        : await this.signHandler.handshake();
                    this.emit('connect', { chainId: (0, util_1.hexStringFromIntNumber)((0, type_1.IntNumber)(this.chain.id)) });
                    return accounts;
                }
                catch (error) {
                    this.handleUnauthorizedError(error);
                    throw error;
                }
            },
            sign: async (request) => {
                if (!this.connected) {
                    throw error_1.standardErrors.provider.unauthorized("Must call 'eth_requestAccounts' before other methods");
                }
                try {
                    return await this.signHandler.request(request);
                }
                catch (error) {
                    this.handleUnauthorizedError(error);
                    throw error;
                }
            },
            fetch: (request) => (0, provider_1.fetchRPCRequest)(request, this.chain),
            state: (request) => {
                const getConnectedAccounts = () => {
                    if (this.connected)
                        return this.accounts;
                    throw error_1.standardErrors.provider.unauthorized("Must call 'eth_requestAccounts' before other methods");
                };
                switch (request.method) {
                    case 'eth_chainId':
                    case 'net_version':
                        return this.chain.id;
                    case 'eth_accounts':
                        return getConnectedAccounts();
                    case 'eth_coinbase':
                        return getConnectedAccounts()[0];
                    default:
                        return this.handlers.unsupported(request);
                }
            },
            filter: (request) => this.filterHandler.request(request),
            deprecated: ({ method }) => {
                throw error_1.standardErrors.rpc.methodNotSupported(`Method ${method} is deprecated.`);
            },
            unsupported: ({ method }) => {
                throw error_1.standardErrors.rpc.methodNotSupported(`Method ${method} is not supported.`);
            },
        };
        this.isCoinbaseWallet = true;
        this.updateListener = {
            onAccountsUpdate: ({ accounts, source }) => {
                if ((0, util_1.areAddressArraysEqual)(this.accounts, accounts))
                    return;
                this.accounts = accounts;
                if (source === 'storage')
                    return;
                this.emit('accountsChanged', this.accounts);
            },
            onChainUpdate: ({ chain, source }) => {
                if (chain.id === this.chain.id && chain.rpcUrl === this.chain.rpcUrl)
                    return;
                this.chain = chain;
                if (source === 'storage')
                    return;
                this.emit('chainChanged', (0, util_1.hexStringFromIntNumber)((0, type_1.IntNumber)(chain.id)));
            },
        };
        this.chain = {
            id: (_b = (_a = params.metadata.appChainIds) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : 1,
        };
        this.signHandler = new SignHandler_1.SignHandler(Object.assign(Object.assign({}, params), { listener: this.updateListener }));
        this.filterHandler = new FilterPolyfill_1.FilterPolyfill(this.handlers.fetch);
    }
    get connected() {
        return this.accounts.length > 0;
    }
    async request(args) {
        var _a;
        const invalidArgsError = (0, provider_1.checkErrorForInvalidRequestArgs)(args);
        if (invalidArgsError)
            throw invalidArgsError;
        // unrecognized methods are treated as fetch requests
        const category = (_a = (0, method_1.determineMethodCategory)(args.method)) !== null && _a !== void 0 ? _a : 'fetch';
        return this.handlers[category](args);
    }
    handleUnauthorizedError(error) {
        const e = error;
        if (e.code === error_1.standardErrorCodes.provider.unauthorized)
            this.disconnect();
    }
    /** @deprecated Use `.request({ method: 'eth_requestAccounts' })` instead. */
    async enable() {
        console.warn(`.enable() has been deprecated. Please use .request({ method: "eth_requestAccounts" }) instead.`);
        return await this.request({
            method: 'eth_requestAccounts',
        });
    }
    async disconnect() {
        this.accounts = [];
        this.chain = { id: 1 };
        this.signHandler.disconnect();
        this.emit('disconnect', error_1.standardErrors.provider.disconnected('User initiated disconnection'));
    }
}
exports.CoinbaseWalletProvider = CoinbaseWalletProvider;
