import { providers, utils, BigNumber, constants, Contract } from 'ethers';
import { z } from 'zod';
import { defaultChains, getValidChainRPCs, Polygon, Flag, FlagTestnet, Mumbai, Optimism, OpSepoliaTestnet, Base, BaseSepoliaTestnet, Zora, ZoraSepoliaTestnet, Celo, CeloAlfajoresTestnet } from '@thirdweb-dev/chains';
import { sha256HexSync } from '@thirdweb-dev/crypto';
import invariant from 'tiny-invariant';
import BN from 'bn.js';
import bs58 from 'bs58';
import IBurnableERC20Abi from '@thirdweb-dev/contracts-js/dist/abis/IBurnableERC20.json';
import IDrop from '@thirdweb-dev/contracts-js/dist/abis/IDrop.json';
import DropERC20_V2Abi from '@thirdweb-dev/contracts-js/dist/abis/IDropERC20_V2.json';
import IDropSinglePhase from '@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase.json';
import IDropSinglePhaseV1 from '@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase_V1.json';
import ERC20Abi from '@thirdweb-dev/contracts-js/dist/abis/IERC20.json';
import IERC20PermitAbi from '@thirdweb-dev/contracts-js/dist/abis/IERC20Permit.json';
import IMintableERC20Abi from '@thirdweb-dev/contracts-js/dist/abis/IMintableERC20.json';
import MulticallAbi from '@thirdweb-dev/contracts-js/dist/abis/IMulticall.json';
import ISignatureMintERC20Abi from '@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC20.json';
import IERC20MetadataAbi from '@thirdweb-dev/contracts-js/dist/abis/IERC20Metadata.json';
import IBurnableERC721Abi from '@thirdweb-dev/contracts-js/dist/abis/IBurnableERC721.json';
import IClaimableERC721 from '@thirdweb-dev/contracts-js/dist/abis/IClaimableERC721.json';
import DelayedRevealAbi from '@thirdweb-dev/contracts-js/dist/abis/IDelayedReveal.json';
import DropERC721_V3Abi from '@thirdweb-dev/contracts-js/dist/abis/IDropERC721_V3.json';
import Erc721Abi from '@thirdweb-dev/contracts-js/dist/abis/IERC721.json';
import Erc721EnumerableAbi from '@thirdweb-dev/contracts-js/dist/abis/IERC721Enumerable.json';
import Erc721AQueryableAbi from '@thirdweb-dev/contracts-js/dist/abis/IERC721AQueryableUpgradeable.json';
import Erc721SupplyAbi from '@thirdweb-dev/contracts-js/dist/abis/IERC721Supply.json';
import ILazyMintAbi from '@thirdweb-dev/contracts-js/dist/abis/ILazyMint.json';
import IMintableERC721Abi from '@thirdweb-dev/contracts-js/dist/abis/IMintableERC721.json';
import SignatureMintERC721Abi from '@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC721.json';
import SignatureMintERC721_V1Abi from '@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC721_V1.json';
import TieredDropAbi from '@thirdweb-dev/contracts-js/dist/abis/LazyMintWithTier_V1.json';
import SharedMetadataAbi from '@thirdweb-dev/contracts-js/dist/abis/SharedMetadata.json';
import zora_IDropERC721 from '@thirdweb-dev/contracts-js/dist/abis/zora_IERC721Drop.json';
import ILoyaltyCardAbi from '@thirdweb-dev/contracts-js/dist/abis/ILoyaltyCard.json';
import INFTMetadataAbi from '@thirdweb-dev/contracts-js/dist/abis/INFTMetadata.json';
import IERC721MetadataAbi from '@thirdweb-dev/contracts-js/dist/abis/IERC721Metadata.json';
import IBurnableERC1155Abi from '@thirdweb-dev/contracts-js/dist/abis/IBurnableERC1155.json';
import IClaimableERC1155 from '@thirdweb-dev/contracts-js/dist/abis/IClaimableERC1155.json';
import IDropMultiPhase1155 from '@thirdweb-dev/contracts-js/dist/abis/IDrop1155.json';
import DropERC1155_V2Abi from '@thirdweb-dev/contracts-js/dist/abis/IDropERC1155_V2.json';
import IDropSinglePhase1155 from '@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase1155.json';
import IDropSinglePhase1155_V1 from '@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase1155_V1.json';
import Erc1155Abi from '@thirdweb-dev/contracts-js/dist/abis/IERC1155.json';
import Erc1155MetadataAbi from '@thirdweb-dev/contracts-js/dist/abis/IERC1155Metadata.json';
import Erc1155SupplyAbi from '@thirdweb-dev/contracts-js/dist/abis/IERC1155Supply.json';
import Erc1155EnumerableAbi from '@thirdweb-dev/contracts-js/dist/abis/IERC1155Enumerable.json';
import IMintableERC1155Abi from '@thirdweb-dev/contracts-js/dist/abis/IMintableERC1155.json';
import ISignatureMintERC1155Abi from '@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC1155.json';
import IERC2771ContextAbi from '@thirdweb-dev/contracts-js/dist/abis/IERC2771Context.json';
import IAppURI from '@thirdweb-dev/contracts-js/dist/abis/IAppURI.json';
import IContractMetadataAbi from '@thirdweb-dev/contracts-js/dist/abis/IContractMetadata.json';
import IDirectListingsAbi from '@thirdweb-dev/contracts-js/dist/abis/IDirectListings.json';
import IEnglishAuctionsAbi from '@thirdweb-dev/contracts-js/dist/abis/IEnglishAuctions.json';
import IOffersAbi from '@thirdweb-dev/contracts-js/dist/abis/IOffers.json';
import IPackVRFAbi from '@thirdweb-dev/contracts-js/dist/abis/IPackVRFDirect.json';
import IPermissionsAbi from '@thirdweb-dev/contracts-js/dist/abis/IPermissions.json';
import IPermissionsEnumerableAbi from '@thirdweb-dev/contracts-js/dist/abis/IPermissionsEnumerable.json';
import IThirdwebPlatformFeeAbi from '@thirdweb-dev/contracts-js/dist/abis/IPlatformFee.json';
import IThirdwebPrimarySaleAbi from '@thirdweb-dev/contracts-js/dist/abis/IPrimarySale.json';
import IThirdwebRoyaltyAbi from '@thirdweb-dev/contracts-js/dist/abis/IRoyalty.json';
import IOwnableAbi from '@thirdweb-dev/contracts-js/dist/abis/Ownable.json';
import IAirdropERC20 from '@thirdweb-dev/contracts-js/dist/abis/IAirdropERC20.json';
import IAirdropERC721 from '@thirdweb-dev/contracts-js/dist/abis/IAirdropERC721.json';
import IAirdropERC1155 from '@thirdweb-dev/contracts-js/dist/abis/IAirdropERC1155.json';
import IAccountFactoryCore from '@thirdweb-dev/contracts-js/dist/abis/IAccountFactoryCore.json';
import IAccountPermissions from '@thirdweb-dev/contracts-js/dist/abis/IAccountPermissions.json';
import IAccountPermissionsV1 from '@thirdweb-dev/contracts-js/dist/abis/IAccountPermissions_V1.json';
import IAccount from '@thirdweb-dev/contracts-js/dist/abis/IAccount.json';
import { Interface } from 'ethers/lib/utils';
import EventEmitter from 'eventemitter3';

function getProcessEnv(key) {
  let defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
  if (typeof process !== "undefined") {
    if (process.env[key]) {
      return process.env[key];
    }
  }
  return defaultValue;
}

const ContractPublisher_address = "0xf5b896Ddb5146D5dA77efF4efBb3Eae36E300808"; // Polygon only

/**
 * @internal
 */
function getContractPublisherAddress() {
  return getProcessEnv("contractPublisherAddress", ContractPublisher_address);
}

/**
 * util function to check for signer, ripped out of ethers Signer.isProvider
 *
 * @param value - possible signer
 * @returns boolean if value is a signer
 * @internal
 */
function isSigner(value) {
  return !!(value && value._isSigner);
}

/**
 * util function to check for provider, ripped out of ethers providers.Provider.isProvider
 *
 * @param value - possible provider
 * @returns boolean if value is a provider
 * @internal
 */
function isProvider(value) {
  return !!(value && value._isProvider);
}

const DEFAULT_BATCH_TIME_LIMIT_MS = 10;
const DEFAULT_BATCH_SIZE_LIMIT = 200;
const DEFAULT_BATCH_OPTIONS = {
  timeLimitMs: DEFAULT_BATCH_TIME_LIMIT_MS,
  sizeLimit: DEFAULT_BATCH_SIZE_LIMIT
};
/**
 * mostly copied from ethers.js directly but make it a StaticJsonRpcProvider
 * @internal
 */
class StaticJsonRpcBatchProvider extends providers.StaticJsonRpcProvider {
  constructor(url, network) {
    let batchOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_BATCH_OPTIONS;
    super(url, network);
    this._timeLimitMs = batchOptions.timeLimitMs || DEFAULT_BATCH_TIME_LIMIT_MS;
    this._sizeLimit = batchOptions.sizeLimit || DEFAULT_BATCH_SIZE_LIMIT;
    this._pendingBatchAggregator = null;
    this._pendingBatch = null;
  }
  sendCurrentBatch(request) {
    // if we still have a timeout clear that first
    if (this._pendingBatchAggregator) {
      clearTimeout(this._pendingBatchAggregator);
    }
    // Get the current batch and clear it, so new requests
    // go into the next batch
    const batch = this._pendingBatch || [];
    this._pendingBatch = null;
    this._pendingBatchAggregator = null;

    // Get the request as an array of requests
    const request_ = batch.map(inflight => inflight.request);
    this.emit("debug", {
      action: "requestBatch",
      request: utils.deepCopy(request),
      provider: this
    });
    return utils.fetchJson(this.connection, JSON.stringify(request_)).then(result => {
      this.emit("debug", {
        action: "response",
        request: request_,
        response: result,
        provider: this
      });

      // For each result, feed it to the correct Promise, depending
      // on whether it was a success or error
      batch.forEach((inflightRequest_, index) => {
        const payload = result[index];

        // there may *not* be a payload for a given request (typically RPC error level)
        if (payload) {
          // if there is a payload, check for an error
          if (payload.error) {
            const error = new Error(payload.error.message);
            error.code = payload.error.code;
            error.data = payload.error.data;
            inflightRequest_.reject(error);
          } else {
            // if there's no error resolve the request
            inflightRequest_.resolve(payload.result);
          }
        } else {
          // if there is no payload, reject the request
          inflightRequest_.reject(new Error("No response for request"));
        }
      });
    }, error => {
      this.emit("debug", {
        action: "response",
        error: error,
        request: request_,
        provider: this
      });

      // If there was an error, reject all the requests
      batch.forEach(inflightRequest_ => {
        inflightRequest_.reject(error);
      });
    });
  }
  send(method, params) {
    const request = {
      method: method,
      params: params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    if (this._pendingBatch === null) {
      this._pendingBatch = [];
    }
    const inflightRequest = {
      request,
      resolve: null,
      reject: null
    };
    const promise = new Promise((resolve, reject) => {
      inflightRequest.resolve = resolve;
      inflightRequest.reject = reject;
    });
    this._pendingBatch.push(inflightRequest);

    // if we would go *over* the size limit of the batch with this request, send the batch now
    if (this._pendingBatch.length === this._sizeLimit) {
      this.sendCurrentBatch(request);
    }
    if (!this._pendingBatchAggregator) {
      // Schedule batch for next event loop + short duration
      this._pendingBatchAggregator = setTimeout(() => {
        this.sendCurrentBatch(request);
      }, this._timeLimitMs);
    }
    return promise;
  }
}

const ChainInfoInputSchema = /* @__PURE__ */(() => z.object({
  rpc: z.array(z.string().url()),
  chainId: z.number(),
  nativeCurrency: z.object({
    name: z.string(),
    symbol: z.string(),
    decimals: z.number()
  }),
  slug: z.string()
}))();

/**
 * @public
 */
const SDKOptionsSchema = /* @__PURE__ */(() => z.object({
  // @ts-expect-error - zod doesn't know anything about readonly
  supportedChains: z.array(ChainInfoInputSchema).default(defaultChains),
  clientId: z.string().optional(),
  secretKey: z.string().optional(),
  readonlySettings: z.object({
    rpcUrl: z.string().url(),
    chainId: z.number().optional()
  }).optional(),
  gasSettings: z.object({
    maxPriceInGwei: z.number().min(1, "gas price cannot be less than 1").default(300),
    speed: z.enum(["standard", "fast", "fastest"]).default("fastest")
  }).default({
    maxPriceInGwei: 300,
    speed: "fastest"
  }),
  gasless: z.union([z.object({
    openzeppelin: z.object({
      relayerUrl: z.string().url(),
      relayerForwarderAddress: z.string().optional(),
      useEOAForwarder: z.boolean().default(false),
      domainName: z.string().default("GSNv2 Forwarder"),
      domainVersion: z.string().default("0.0.1"),
      domainSeparatorVersion: z.string().default("1")
    }),
    experimentalChainlessSupport: z.boolean().default(false)
  }), z.object({
    biconomy: z.object({
      apiId: z.string(),
      apiKey: z.string(),
      deadlineSeconds: z.number().min(1, "deadlineSeconds cannot be les than 1").default(3600)
    })
  }), z.object({
    engine: z.object({
      relayerUrl: z.string().url().transform(url => url.replace(/\/$/, "")),
      relayerForwarderAddress: z.string().optional(),
      domainName: z.string().default("GSNv2 Forwarder"),
      domainVersion: z.string().default("0.0.1"),
      domainSeparatorVersion: z.string().default("1")
    }),
    experimentalChainlessSupport: z.boolean().default(false)
  })]).optional(),
  gatewayUrls: z.array(z.string()).optional(),
  rpcBatchSettings: z.object({
    sizeLimit: z.number().default(200),
    timeLimit: z.number().default(10)
  }).optional()
}).default({
  gasSettings: {
    maxPriceInGwei: 300,
    speed: "fastest"
  }
}))();

/**
 * @public
 * All these configuration options are optional with sane defaults:
 * @example
 * ```javascript
 * {
 *   readonlySettings: {
 *     rpcUrl, // force read calls to go through your own RPC url
 *     chainId, // reduce RPC calls by sepcifying your chain ID
 *   },
 *   gasSettings: {
 *     maxPriceInGwei, // Maximum gas price for transactions (default 300 gwei)
 *     speed, // the tx speed setting: 'standard'|'fast|'fastest' (default: 'fastest')
 *   },
 *   gasless: {
 *     // By specifying a gasless configuration - all transactions will get forwarded to enable gasless transactions
 *     openzeppelin: {
 *       relayerUrl, // your OZ Defender relayer URL
 *       relayerForwarderAddress, // the OZ defender relayer address (defaults to the standard one)
 *     },
 *     biconomy: {
 *       apiId, // your Biconomy API Id
 *       apiKey, // your Biconomy API Key
 *       deadlineSeconds, // your Biconomy timeout preference
 *     },
 *   },
 * }
 * ```
 */

/**
 * @internal
 */

/**
 * @public
 */

var pkg = {
	name: "@thirdweb-dev/sdk",
	version: "4.0.85",
	description: "The main thirdweb SDK.",
	repository: "https://github.com/thirdweb-dev/js/tree/main/legacy_packages/sdk",
	license: "Apache-2.0",
	main: "dist/thirdweb-dev-sdk.cjs.js",
	module: "dist/thirdweb-dev-sdk.esm.js",
	browser: {
		"./dist/thirdweb-dev-sdk.esm.js": "./dist/thirdweb-dev-sdk.browser.esm.js"
	},
	exports: {
		".": {
			module: {
				browser: "./dist/thirdweb-dev-sdk.browser.esm.js",
				"default": "./dist/thirdweb-dev-sdk.esm.js"
			},
			"default": "./dist/thirdweb-dev-sdk.cjs.js"
		},
		"./evm": {
			module: {
				browser: "./evm/dist/thirdweb-dev-sdk-evm.browser.esm.js",
				"default": "./evm/dist/thirdweb-dev-sdk-evm.esm.js"
			},
			"default": "./evm/dist/thirdweb-dev-sdk-evm.cjs.js"
		},
		"./evm/zksync": {
			module: {
				browser: "./evm/zksync/dist/thirdweb-dev-sdk-evm-zksync.browser.esm.js",
				"default": "./evm/zksync/dist/thirdweb-dev-sdk-evm-zksync.esm.js"
			},
			"default": "./evm/zksync/dist/thirdweb-dev-sdk-evm-zksync.cjs.js"
		},
		"./evm/functions": {
			module: {
				browser: "./evm/functions/dist/thirdweb-dev-sdk-evm-functions.browser.esm.js",
				"default": "./evm/functions/dist/thirdweb-dev-sdk-evm-functions.esm.js"
			},
			"default": "./evm/functions/dist/thirdweb-dev-sdk-evm-functions.cjs.js"
		},
		"./package.json": "./package.json"
	},
	files: [
		"dist/",
		"evm/",
		"server/"
	],
	preconstruct: {
		entrypoints: [
			"index.ts",
			"evm/index.ts",
			"evm/functions/index.ts",
			"evm/zksync/index.ts"
		],
		exports: {
			envConditions: [
				"browser"
			]
		}
	},
	sideEffects: false,
	scripts: {
		format: "prettier --write 'src/**/*'",
		lint: "eslint src/",
		fix: "eslint src/ --fix",
		clean: "rm -rf dist/",
		"generate-docs": "mkdir -p etc && pnpm generate-docs:evm && pnpm generate-snippets",
		"generate-docs:evm": "api-extractor run --local --config ./config/api-extractor-evm.json && api-documenter markdown -i ./temp -o ./docs/evm && rm -rf ./temp-evm && mv ./temp ./temp-evm",
		"generate-snippets": "node ./scripts/generate-snippets.mjs && node ./scripts/generate-feature-snippets-evm.mjs",
		build: "tsc && preconstruct build",
		"test:all": "SWC_NODE_PROJECT=./tsconfig.test.json nyc --reporter lcovonly --report-dir ./coverage/evm mocha --config './test/evm/.mocharc.json' --timeout 180000 --parallel './test/evm/**/*.test.ts'",
		test: "make test-evm",
		"test:single": "SWC_NODE_PROJECT=./tsconfig.test.json mocha --config './test/evm/.mocharc.json' --timeout 90000",
		push: "yalc push",
		typedoc: "node scripts/typedoc.mjs"
	},
	devDependencies: {
		"@aws-sdk/client-secrets-manager": "^3.549.0",
		"@ethersproject/abstract-provider": "^5.7.0",
		"@microsoft/api-documenter": "^7.24.5",
		"@microsoft/api-extractor": "^7.43.0",
		"@microsoft/tsdoc": "^0.14.2",
		"@nomiclabs/hardhat-ethers": "^2.2.3",
		"@preconstruct/cli": "2.7.0",
		"@swc-node/register": "^1.9.0",
		"@swc/core": "^1.4.12",
		"@thirdweb-dev/tsconfig": "^0.1.7",
		"@types/bn.js": "^5.1.5",
		"@types/chai": "^4.3.14",
		"@types/deep-equal-in-any-order": "^1.0.3",
		"@types/mocha": "^10.0.6",
		"@types/node": "20.12.7",
		"@types/uuid": "^9.0.8",
		chai: "^4.4.1",
		"deep-equal-in-any-order": "^1.1.20",
		"dotenv-mono": "^1.3.14",
		eslint: "8.57.0",
		"eslint-config-thirdweb": "^0.1.9",
		"eslint-plugin-better-tree-shaking": "0.0.4",
		"eslint-plugin-import": "^2.29.1",
		"eslint-plugin-inclusive-language": "^2.2.1",
		"eslint-plugin-prettier": "^5.1.3",
		"eslint-plugin-tsdoc": "^0.2.17",
		ethers: "^5.7.2",
		"ethers-aws-kms-signer": "^1.3.2",
		hardhat: "^2.22.2",
		mocha: "10.4.0",
		nyc: "^15.1.0",
		rimraf: "5.0.5",
		"typedoc-gen": "^1.0.2",
		typescript: "5.4.4",
		"zksync-ethers": "^5.7.0"
	},
	peerDependencies: {
		"@aws-sdk/client-secrets-manager": "^3.215.0",
		ethers: "^5",
		"ethers-aws-kms-signer": "^1.3.2",
		"zksync-ethers": "^5.6.0"
	},
	peerDependenciesMeta: {
		"@aws-sdk/client-secrets-manager": {
			optional: true
		},
		"ethers-aws-kms-signer": {
			optional: true
		},
		"zksync-ethers": {
			optional: true
		}
	},
	dependencies: {
		"@eth-optimism/sdk": "3.3.0",
		"@thirdweb-dev/chains": "0.1.111",
		"@thirdweb-dev/contracts-js": "1.3.23",
		"@thirdweb-dev/crypto": "0.2.6",
		"@thirdweb-dev/generated-abis": "0.0.2",
		"@thirdweb-dev/merkletree": "0.2.6",
		"@thirdweb-dev/storage": "2.0.15",
		abitype: "1.0.0",
		"bn.js": "5.2.1",
		bs58: "^5.0.0",
		buffer: "^6.0.3",
		eventemitter3: "^5.0.1",
		"fast-deep-equal": "^3.1.3",
		thirdweb: "5.22.1",
		"tiny-invariant": "^1.3.3",
		tweetnacl: "^1.0.3",
		uuid: "^9.0.1",
		yaml: "^2.4.1",
		zod: "^3.22.4"
	},
	bugs: {
		url: "https://github.com/thirdweb-dev/js/issues"
	},
	author: "thirdweb eng <eng@thirdweb.com>",
	engines: {
		node: ">=18"
	}
};

/**
 * @internal
 *
 * The code below comes from the package https://github.com/DamonOehlman/detect-browser
 */
const operatingSystemRules = [["iOS", /iP(hone|od|ad)/], ["Android OS", /Android/], ["BlackBerry OS", /BlackBerry|BB10/], ["Windows Mobile", /IEMobile/], ["Amazon OS", /Kindle/], ["Windows 3.11", /Win16/], ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/], ["Windows 98", /(Windows 98)|(Win98)/], ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/], ["Windows XP", /(Windows NT 5.1)|(Windows XP)/], ["Windows Server 2003", /(Windows NT 5.2)/], ["Windows Vista", /(Windows NT 6.0)/], ["Windows 7", /(Windows NT 6.1)/], ["Windows 8", /(Windows NT 6.2)/], ["Windows 8.1", /(Windows NT 6.3)/], ["Windows 10", /(Windows NT 10.0)/], ["Windows ME", /Windows ME/], ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/], ["Open BSD", /OpenBSD/], ["Sun OS", /SunOS/], ["Chrome OS", /CrOS/], ["Linux", /(Linux)|(X11)/], ["Mac OS", /(Mac_PowerPC)|(Macintosh)/], ["QNX", /QNX/], ["BeOS", /BeOS/], ["OS/2", /OS\/2/]];
function detectOS(ua) {
  for (let ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
    const result = operatingSystemRules[ii];
    if (!result) {
      continue;
    }
    const [os, regex] = result;
    const match = regex.exec(ua);
    if (match) {
      return os;
    }
  }
  return null;
}

function getOperatingSystem() {
  if (typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return "";
  } else if (typeof window !== "undefined") {
    const userAgent = navigator.userAgent;
    return detectOS(userAgent) || "";
  } else {
    return process.platform;
  }
}

function setAnalyticsHeaders(headers) {
  const globals = getAnalyticsGlobals();
  headers["x-sdk-version"] = globals.x_sdk_version;
  headers["x-sdk-name"] = globals.x_sdk_name;
  headers["x-sdk-platform"] = globals.x_sdk_platform;
  headers["x-sdk-os"] = globals.x_sdk_os;
}
function getAnalyticsHeaders() {
  const globals = getAnalyticsGlobals();
  return {
    "x-sdk-version": globals.x_sdk_version,
    "x-sdk-os": globals.x_sdk_os,
    "x-sdk-name": globals.x_sdk_name,
    "x-sdk-platform": globals.x_sdk_platform,
    ...(globals.app_bundle_id ? {
      "x-bundle-id": globals.app_bundle_id
    } : {})
  };
}
function getAnalyticsGlobals() {
  if (typeof globalThis === "undefined") {
    return {
      x_sdk_name: pkg.name,
      x_sdk_platform: getPlatform(),
      x_sdk_version: pkg.version,
      x_sdk_os: getOperatingSystem(),
      app_bundle_id: undefined
    };
  }
  if (globalThis.X_SDK_NAME === undefined) {
    globalThis.X_SDK_NAME = pkg.name;
    globalThis.X_SDK_PLATFORM = getPlatform();
    globalThis.X_SDK_VERSION = pkg.version;
    globalThis.X_SDK_OS = getOperatingSystem();
    globalThis.APP_BUNDLE_ID = undefined;
  }
  return {
    x_sdk_name: globalThis.X_SDK_NAME,
    x_sdk_platform: globalThis.X_SDK_PLATFORM,
    x_sdk_version: globalThis.X_SDK_VERSION,
    x_sdk_os: globalThis.X_SDK_OS,
    app_bundle_id: globalThis.APP_BUNDLE_ID || "" // if react, this will be empty
  };
}
function getPlatform() {
  return typeof navigator !== "undefined" && navigator.product === "ReactNative" ? "mobile" : typeof window !== "undefined" ? "browser" : "node";
}

/**
 * @internal
 */
function buildDefaultMap(options) {
  return options.supportedChains.reduce((previousValue, currentValue) => {
    // don't overwrite existing chains!
    if (!previousValue[currentValue.chainId]) {
      previousValue[currentValue.chainId] = currentValue;
    }
    return previousValue;
  }, {});
}

/**
 * Get an ethers provider for the specified network
 *
 * @internal
 */
function getChainProvider(network, sdkOptions) {
  // If we have an RPC URL, use that for the provider
  if (typeof network === "string" && isRpcUrl(network)) {
    return getProviderFromRpcUrl(network, sdkOptions);
  }

  // Add the chain to the supportedChains
  const options = SDKOptionsSchema.parse(sdkOptions);
  if (isChainConfig(network)) {
    options.supportedChains = [
    // @ts-expect-error - we know this is a chain and it will work to build the map
    network, ...options.supportedChains.filter(c => c.chainId === network.chainId)];
  }

  // Build a map of chainId -> ChainInfo based on the supportedChains
  const rpcMap = buildDefaultMap(options);
  let rpcUrl = "";
  let chainId;
  try {
    // Resolve the chain id from the network, which could be a chain, chain name, or chain id
    chainId = getChainIdFromNetwork(network, options);
    // Attempt to get the RPC url from the map based on the chainId
    rpcUrl = getValidChainRPCs(rpcMap[chainId], options.clientId)[0];
  } catch (e) {
    // no-op
  }

  // if we still don't have an url fall back to just using the chainId or slug in the rpc and try that
  if (!rpcUrl) {
    rpcUrl = `https://${chainId || network}.rpc.thirdweb.com/${options.clientId || ""}`;
  }
  if (!rpcUrl) {
    throw new Error(`No rpc url found for chain ${network}. Please provide a valid rpc url via the 'supportedChains' property of the sdk options.`);
  }
  return getProviderFromRpcUrl(rpcUrl, sdkOptions, chainId);
}

/**
 * @internal
 */
function getChainIdFromNetwork(network, options) {
  if (isChainConfig(network)) {
    // If it's a chain just return the chain id
    return network.chainId;
  } else if (typeof network === "number") {
    // If it's a number (chainId) return it directly
    return network;
  } else {
    // If it's a string (chain name) return the chain id from the map
    const chainNameToId = options.supportedChains.reduce((acc, curr) => {
      acc[curr.slug] = curr.chainId;
      return acc;
    }, {});
    if (network in chainNameToId) {
      return chainNameToId[network];
    }
  }
  throw new Error(`Cannot resolve chainId from: ${network} - please pass the chainId instead and specify it in the 'supportedChains' property of the SDK options.`);
}

/**
 * @internal
 */
async function getChainIdOrName(network) {
  if (isChainConfig(network)) {
    // If it's a chain just return the chain id
    return network.chainId;
  } else if (typeof network === "number") {
    // If it's a number (chainId) return it directly
    return network;
  } else if (typeof network === "number") {
    // If it's a string (chain name) return the chain id from the map
    return network;
  } else if (isProvider(network)) {
    return network.getNetwork().then(n => n.chainId);
  } else if (isSigner(network)) {
    if (!network.provider) {
      throw new Error("Signer does not have a provider");
    }
    return network.provider.getNetwork().then(n => n.chainId);
  }
  throw new Error(`Cannot resolve chainId from: ${network}.`);
}

/**
 * Check whether a NetworkInput value is a Chain config (naively, without parsing)
 * @internal
 */
function isChainConfig(network) {
  return typeof network !== "string" && typeof network !== "number" && !isSigner(network) && !isProvider(network);
}

/**
 * Returns whether the specified url is a valid RPC url, as implemented by ethers.getDefaultProvier():
 * - https://github.com/ethers-io/ethers.js/blob/ec1b9583039a14a0e0fa15d0a2a6082a2f41cf5b/packages/providers/src.ts/index.ts#L55
 *
 * @param url - The url to check
 *
 * @internal
 */
function isRpcUrl(url) {
  const match = url.match(/^(ws|http)s?:/i);
  if (match) {
    switch (match[1].toLowerCase()) {
      case "http":
      case "https":
      case "ws":
      case "wss":
        return true;
    }
  }
  return false;
}
const RPC_PROVIDER_MAP = new Map();

/**
 * Get an ethers provider based on the specified RPC URL
 *
 * @param rpcUrl - The RPC URL
 * @param chainId - The optional chain ID
 * @returns The provider for the specified RPC URL
 *
 * @internal
 */
function getProviderFromRpcUrl(rpcUrl, sdkOptions, chainId) {
  try {
    const headers = {};
    // will be used to make sure we don't cache providers with different auth strategies
    let authStrategy = "none";
    if (isTwUrl(rpcUrl)) {
      // if we have a secret key passed in the SDK options we want to always use that
      if (sdkOptions?.secretKey) {
        // compute the clientId from the secret key
        // should only be used on Node.js in a backend/script context
        if (typeof window !== "undefined") {
          throw new Error("Cannot use secretKey in browser context");
        }
        const hashedSecretKey = sha256HexSync(sdkOptions.secretKey);
        const derivedClientId = hashedSecretKey.slice(0, 32);
        const utilizedRpcUrl = new URL(rpcUrl);
        // always set the clientId on the path to the derived client id
        utilizedRpcUrl.pathname = derivedClientId;
        // set the headers
        headers["x-client-id"] = derivedClientId;
        headers["x-secret-key"] = sdkOptions.secretKey;
        // set the final rpc url
        rpcUrl = utilizedRpcUrl.toString();
        authStrategy = "secretKey";
      }
      // if we do NOT have a secret key but we have a client id we want to use that
      else if (sdkOptions?.clientId) {
        const utilizedRpcUrl = new URL(rpcUrl);
        // always set the clientId on the path to the client id
        utilizedRpcUrl.pathname = sdkOptions.clientId;
        // set the headers
        headers["x-client-id"] = sdkOptions.clientId;
        // set the final rpc url
        rpcUrl = utilizedRpcUrl.toString();
        authStrategy = "clientId";
      }

      // if we *also* have a tw auth token on global context add it to the headers (in addition to anything else)
      if (typeof globalThis !== "undefined" && "TW_AUTH_TOKEN" in globalThis && typeof globalThis.TW_AUTH_TOKEN === "string") {
        headers["authorization"] = `Bearer ${globalThis.TW_AUTH_TOKEN}`;
        authStrategy = "twAuthToken";
      }
      if (typeof globalThis !== "undefined" && "TW_CLI_AUTH_TOKEN" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === "string") {
        headers["x-authorize-wallet"] = "true";
      }
      setAnalyticsHeaders(headers);
      const bundleId = typeof globalThis !== "undefined" && "APP_BUNDLE_ID" in globalThis ? globalThis.APP_BUNDLE_ID : undefined;
      if (!rpcUrl.includes("bundleId") && bundleId) {
        rpcUrl = rpcUrl + (bundleId ? `?bundleId=${bundleId}` : "");
      }
    }
    const match = rpcUrl.match(/^(ws|http)s?:/i);
    // Try the JSON batch provider if available
    if (match) {
      switch (match[1].toLowerCase()) {
        case "http":
        case "https":
          // Create a unique cache key for these params
          const seralizedOpts = `${rpcUrl}-${chainId || -1}-${authStrategy}`;

          // Check if we have a provider in our cache already
          const existingProvider = RPC_PROVIDER_MAP.get(seralizedOpts);
          if (existingProvider) {
            return existingProvider;
          }

          // TODO: remove below `skipFetchSetup` logic when ethers.js v6 support arrives
          let _skipFetchSetup = false;
          if (typeof globalThis !== "undefined" && "TW_SKIP_FETCH_SETUP" in globalThis && typeof globalThis.TW_SKIP_FETCH_SETUP === "boolean") {
            _skipFetchSetup = globalThis.TW_SKIP_FETCH_SETUP;
          }

          // Otherwise, create a new provider on the specific network
          const newProvider = chainId ?
          // If we know the chainId we should use the StaticJsonRpcBatchProvider
          new StaticJsonRpcBatchProvider({
            url: rpcUrl,
            headers,
            skipFetchSetup: _skipFetchSetup
          }, chainId, sdkOptions?.rpcBatchSettings) :
          // Otherwise fall back to the built in json rpc batch provider
          new providers.JsonRpcBatchProvider({
            url: rpcUrl,
            headers,
            skipFetchSetup: _skipFetchSetup
          });

          // Save the provider in our cache
          RPC_PROVIDER_MAP.set(seralizedOpts, newProvider);
          return newProvider;
        case "ws":
        case "wss":
          // Use the WebSocketProvider for ws:// URLs
          // TODO: handle auth for WS at some point
          return new providers.WebSocketProvider(rpcUrl, chainId);
      }
    }
  } catch (e) {
    // no-op
  }

  // Always fallback to the default provider if no other option worked
  return providers.getDefaultProvider(rpcUrl);
}

// TODO move to utils package
function isTwUrl(url) {
  return new URL(url).hostname.endsWith(".thirdweb.com");
}

/**
 * @internal
 */
function getSignerAndProvider(network, options) {
  let signer;
  let provider;
  if (isSigner(network)) {
    // Here, we have an ethers.Signer
    signer = network;
    if (network.provider) {
      provider = network.provider;
    }
  } else if (isProvider(network)) {
    // Here, we have an ethers.providers.Provider
    provider = network;
  } else {
    // Here, we must have a ChainOrRpcUrl, which is a chain name, chain id, rpc url, or chain config
    // All of which, getChainProvider can handle for us
    provider = getChainProvider(network, options);
  }
  if (options?.readonlySettings) {
    // If readonly settings are specified, then overwrite the provider
    provider = getProviderFromRpcUrl(options.readonlySettings.rpcUrl, options, options.readonlySettings.chainId);
  }

  // At this point, if we don't have a provider, don't default to a random chain
  // Instead, just throw an error
  if (!provider) {
    if (signer) {
      throw new Error("No provider passed to the SDK! Please make sure that your signer is connected to a provider!");
    }
    throw new Error("No provider found! Make sure to specify which network to connect to, or pass a signer or provider to the SDK!");
  }
  return [signer, provider];
}

// TODO: Respect SDK RPC configuration and don't pull straight from ethers
let provider;
const ENS_CACHE = new Map();

/**
 * @internal
 */
async function resolveEns(ens) {
  let depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  if (!provider) {
    // if we don't already have a provider then get one
    provider = getSignerAndProvider("ethereum")[1];
  }
  let ensPromise;
  if (ENS_CACHE.has(ens)) {
    ensPromise = ENS_CACHE.get(ens);
  } else {
    ensPromise = provider.resolveName(ens).then(address => {
      // If they don't have an ENS, only cache for 30s
      if (!address) {
        return {
          address: null,
          expirationTime: new Date(Date.now() + 1000 * 30)
        };
      }

      // Cache ENS for 1 hour
      return {
        address,
        expirationTime: new Date(Date.now() + 1000 * 60 * 5)
      };
    });
  }
  const resolvedPromise = await ensPromise;
  if (resolvedPromise.expirationTime < new Date()) {
    // delete the cache if it's expired
    ENS_CACHE.delete(ens);
    // then call ourselves again to refresh the cache, but don't block on the result
    if (depth === 0) {
      resolveEns(ens, depth + 1);
    }
  }
  return resolvedPromise.address;
}

// Only pass through to provider call if value ends with .eth or .cb.id
const EnsSchema = /* @__PURE__ */(() => z.custom(ens => typeof ens === "string" && (ens.endsWith(".eth") || ens.endsWith(".cb.id"))).transform(async ens => resolveEns(ens)).refine(address => !!address && utils.isAddress(address), {
  message: "Provided value was not a valid ENS name"
}))();

const AddressSchema = /* @__PURE__ */(() => z.custom(address => typeof address === "string" && utils.isAddress(address), out => {
  return {
    message: `${out} is not a valid address`
  };
}))();

// Important for address check to come before ENS so network request is only made when necessary
const AddressOrEnsSchema = /* @__PURE__ */(() => z.union([AddressSchema, EnsSchema], {
  invalid_type_error: "Provided value was not a valid address or ENS name"
}))();

// Use this everywhere even though it's just string so we can optionally switch it out
// more easily if we want to later

async function resolveAddress(addressOrEns) {
  return AddressOrEnsSchema.parseAsync(addressOrEns);
}

/**
 * @internal
 */
const isBrowser$1 = () => typeof window !== "undefined";
/**
 * @internal
 */
const FileOrBufferUnionSchema = /* @__PURE__ */(() => isBrowser$1() ? z.instanceof(File) :
// @fixme, this is a hack to make browser happy for now
z.instanceof(Buffer))();

/**
 * @internal
 */
const FileOrBufferSchema = /* @__PURE__ */(() => z.union([FileOrBufferUnionSchema, z.object({
  data: z.union([FileOrBufferUnionSchema, z.string()]),
  name: z.string()
})]))();

/**
 * @internal
 */
const FileOrBufferOrStringSchema = /* @__PURE__ */(() => z.union([FileOrBufferSchema, z.string()]))();
const MAX_BPS = 10000;
const BytesLikeSchema = /* @__PURE__ */(() => z.union([z.array(z.number()), z.string()]))();
const BigNumberTransformSchema$1 = /* @__PURE__ */(() => z.union([z.bigint(), z.custom(data => {
  return BigNumber.isBigNumber(data);
}), z.custom(data => {
  return BN.isBN(data);
})]).transform(arg => {
  if (BN.isBN(arg)) {
    return new BN(arg).toString();
  }
  return BigNumber.from(arg).toString();
}))();
const BasisPointsSchema = /* @__PURE__ */(() => z.number().max(MAX_BPS, "Cannot exceed 100%").min(0, "Cannot be below 0%"))();
const PercentSchema = /* @__PURE__ */(() => z.number().max(100, "Cannot exceed 100%").min(0, "Cannot be below 0%"))();
const HexColor = /* @__PURE__ */(() => z.union([z.string().regex(/^([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/, "Invalid hex color"), z.string().regex(/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/, "Invalid hex color").transform(val => val.replace("#", "")), z.string().length(0)]))();
const AmountSchema = /* @__PURE__ */(() => z.union([z.string().regex(/^([0-9]+\.?[0-9]*|\.[0-9]+)$/, "Invalid amount"), z.number().min(0, "Amount cannot be negative")]).transform(arg => typeof arg === "number" ? arg.toString() : arg))();

/**
 * @internal
 */

/**
 * @internal
 */
const QuantitySchema = /* @__PURE__ */(() => z.union([AmountSchema, z.literal("unlimited")]).default("unlimited"))();

const MAX_LENGTH = 256;
const NUMERIC_IDENTIFIER = "0|[1-9]\\d*";
const MAIN_VERSION_IDENTIFIER = `(${NUMERIC_IDENTIFIER})\\.(${NUMERIC_IDENTIFIER})\\.(${NUMERIC_IDENTIFIER})`;
const REGEX_MAIN_VERSION = new RegExp(MAIN_VERSION_IDENTIFIER);

/**
 * @internal
 */

/**
 * @internal
 * @param version - The version to convert to a Semver
 */
function toSemver(version) {
  if (version.length > MAX_LENGTH) {
    throw new Error(`version is longer than ${MAX_LENGTH} characters`);
  }
  const matches = version.trim().match(REGEX_MAIN_VERSION);
  if (!matches || matches?.length !== 4) {
    throw new Error(`${version} is not a valid semantic version. Should be in the format of major.minor.patch. Ex: 0.4.1`);
  }
  const major = Number(matches[1]);
  const minor = Number(matches[2]);
  const patch = Number(matches[3]);
  const versionString = [major, minor, patch].join(".");
  return {
    major,
    minor,
    patch,
    versionString
  };
}

/**
 * @internal
 * @param current - The current version
 * @param next - The next version
 */
function isIncrementalVersion(current, next) {
  const currentSemver = toSemver(current);
  const nextSemver = toSemver(next);
  if (nextSemver.major > currentSemver.major) {
    return true;
  }
  const eqMajor = nextSemver.major === currentSemver.major;
  if (eqMajor && nextSemver.minor > currentSemver.minor) {
    return true;
  }
  const eqMinor = nextSemver.minor === currentSemver.minor;
  return eqMajor && eqMinor && nextSemver.patch > currentSemver.patch;
}

/**
 * @internal
 */
function isDowngradeVersion(current, next) {
  const currentSemver = toSemver(current);
  const nextSemver = toSemver(next);
  if (nextSemver.major < currentSemver.major) {
    return true;
  }
  const eqMajor = nextSemver.major === currentSemver.major;
  if (eqMajor && nextSemver.minor < currentSemver.minor) {
    return true;
  }
  const eqMinor = nextSemver.minor === currentSemver.minor;
  return eqMajor && eqMinor && nextSemver.patch < currentSemver.patch;
}

const BigNumberSchema = /* @__PURE__ */(() => z.union([z.string(), z.number(), z.bigint(), z.custom(data => {
  return BigNumber.isBigNumber(data);
})]).transform(arg => BigNumber.from(arg)))();
const BigNumberishSchema = /* @__PURE__ */(() => BigNumberSchema.transform(arg => arg.toString()))();
const BigNumberTransformSchema = /* @__PURE__ */(() => z.union([z.bigint(), z.custom(data => {
  return BigNumber.isBigNumber(data);
})]).transform(arg => {
  return BigNumber.from(arg).toString();
}))();

/**
 * @internal
 */
const CommonContractSchema = /* @__PURE__ */(() => z.object({
  name: z.string(),
  description: z.string().optional(),
  image: FileOrBufferOrStringSchema.optional(),
  external_link: z.string().optional(),
  app_uri: z.string().optional(),
  social_urls: z.record(z.string()).optional(),
  defaultAdmin: AddressOrEnsSchema.optional()
}).catchall(z.unknown()))();
/**
 * @internal
 */
const CommonContractOutputSchema = /* @__PURE__ */(() => CommonContractSchema.extend({
  image: z.string().optional()
}).catchall(z.unknown()))();

/**
 * @internal
 */
const CommonRoyaltySchema = /* @__PURE__ */(() => z.object({
  /**
   * The amount of royalty collected on all royalties represented as basis points.
   * The default is 0 (no royalties).
   *
   * 1 basis point = 0.01%
   *
   * For example: if this value is 100, then the royalty is 1% of the total sales.
   *
   * @internal
   * @remarks used by OpenSea "seller_fee_basis_points"
   */
  seller_fee_basis_points: BasisPointsSchema.default(0),
  /**
   * The address of the royalty recipient. All royalties will be sent
   * to this address.
   * @internal
   * @remarks used by OpenSea "fee_recipient"
   */
  fee_recipient: AddressOrEnsSchema.default(constants.AddressZero)
}))();

/**
 * @internal
 */
const CommonPrimarySaleSchema = /* @__PURE__ */(() => z.object({
  /**
   * primary sale recipient address
   */
  primary_sale_recipient: AddressOrEnsSchema.default(constants.AddressZero)
}))();

/**
 * @internal
 */
const CommonPlatformFeeSchema = /* @__PURE__ */(() => z.object({
  /**
   * platform fee basis points
   */
  platform_fee_basis_points: BasisPointsSchema.default(0),
  /**
   * platform fee recipient address
   */
  platform_fee_recipient: AddressOrEnsSchema.default(constants.AddressZero)
}))();

/**
 * @internal
 */
const CommonTrustedForwarderSchema = /* @__PURE__ */(() => z.object({
  trusted_forwarders: z.array(AddressOrEnsSchema).default([])
}))();

/**
 * @internal
 */
const CommonSymbolSchema = /* @__PURE__ */(() => z.object({
  symbol: z.string().default("")
}))();

/**
 * @internal
 */
const MerkleSchema = /* @__PURE__ */(() => z.object({
  merkle: z.record(z.string()).default({})
}))();
const SnapshotEntryInput = /* @__PURE__ */(() => z.object({
  address: AddressOrEnsSchema,
  maxClaimable: QuantitySchema.default(0),
  // defaults to 0
  price: QuantitySchema.optional(),
  // defaults to unlimited, but can be undefined in old snapshots
  currencyAddress: AddressOrEnsSchema.default(constants.AddressZero).optional() // defaults to AddressZero, but can be undefined for old snapshots
}))();
/**
 * @internal
 */
const SnapshotInputSchema = /* @__PURE__ */(() => z.union([z.array(z.string()).transform(async strings => await Promise.all(strings.map(address => SnapshotEntryInput.parseAsync({
  address
})))), z.array(SnapshotEntryInput)]))();
const SnapshotEntryWithProofSchema = /* @__PURE__ */(() => SnapshotEntryInput.extend({
  proof: z.array(z.string())
}))();

/**
 * @internal
 */
const SnapshotSchema = /* @__PURE__ */(() => z.object({
  /**
   * The merkle root
   */
  merkleRoot: z.string(),
  claims: z.array(SnapshotEntryWithProofSchema)
}))();

/**
 * @internal
 */

/**
 * @internal
 */
const SnapshotInfoSchema = /* @__PURE__ */(() => z.object({
  merkleRoot: z.string(),
  snapshotUri: z.string()
}))();

/**
 * @internal
 */
const BYOCContractMetadataSchema = /* @__PURE__ */(() => CommonContractSchema.catchall(z.union([BigNumberTransformSchema, z.unknown()])))();

/**
 * @internal
 */

/**
 * @internal
 */
const CustomContractInput = /* @__PURE__ */(() => BYOCContractMetadataSchema.merge(CommonRoyaltySchema.merge(MerkleSchema).merge(CommonSymbolSchema).partial()).catchall(z.any()))();

/**
 * @internal
 */
const CustomContractOutput = /* @__PURE__ */(() => CommonContractOutputSchema.merge(CommonRoyaltySchema.merge(MerkleSchema).merge(CommonSymbolSchema).partial()).catchall(z.any()))();

/**
 * @internal
 */
const CustomContractDeploy = /* @__PURE__ */(() => CustomContractInput.merge(CommonPlatformFeeSchema.merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema).partial()))();

/**
 * @internal
 */
const CustomContractSchema = {
  deploy: CustomContractDeploy,
  output: CustomContractOutput,
  input: CustomContractInput
};

/**
 * @internal
 */
const AbiTypeBaseSchema = /* @__PURE__ */(() => z.object({
  type: z.string(),
  name: z.string().default("")
}).catchall(z.any()))();

/**
 * @internal
 */
const AbiTypeSchema = /* @__PURE__ */(() => AbiTypeBaseSchema.extend({
  stateMutability: z.string().optional(),
  components: z.array(AbiTypeBaseSchema).optional()
}).catchall(z.any()))();

/**
 * @internal
 */
const AbiObjectSchema = /* @__PURE__ */(() => z.object({
  type: z.string(),
  name: z.string().default(""),
  inputs: z.array(AbiTypeSchema).default([]),
  outputs: z.array(AbiTypeSchema).default([])
}).catchall(z.any()))();

/**
 * @internal
 */
const AbiSchema = /* @__PURE__ */(() => z.array(AbiObjectSchema))();
// if we want to statically type this for external usage it has to *awlways* be the output type

// input type is only used internally
/**
 * @internal
 */

/**
 * @internal
 */
const CompilerTypeInput = /* @__PURE__ */(() => z.union([z.literal("solc"), z.literal("zksolc")]))();
/**
 * @internal
 */
const PreDeployMetadata = /* @__PURE__ */(() => z.object({
  name: z.string(),
  metadataUri: z.string(),
  bytecodeUri: z.string(),
  analytics: z.any().optional(),
  compilers: z.record(CompilerTypeInput,
  // z.record(
  z.array(z.object({
    compilerVersion: z.string().optional(),
    evmVersion: z.string().optional(),
    metadataUri: z.string(),
    bytecodeUri: z.string()
  }))
  // ),
  ).optional()
}).catchall(z.any()))();

/**
 * @internal
 */
const ChainIdToAddressSchema = /* @__PURE__ */(() => z.record(z.string(), z.string()))();

/**
 * @internal
 */
const CustomFactoryInput = /* @__PURE__ */(() => z.object({
  factoryFunction: z.string(),
  params: z.array(z.object({
    name: z.string(),
    type: z.string()
  })).default([]),
  customFactoryAddresses: ChainIdToAddressSchema
}))();

/**
 * @internal
 */
const FactoryDeploymentSchema = /* @__PURE__ */(() => z.object({
  implementationAddresses: ChainIdToAddressSchema,
  implementationInitializerFunction: z.string().default("initialize"),
  customFactoryInput: CustomFactoryInput.optional(),
  factoryAddresses: ChainIdToAddressSchema.optional()
}))();

/**
 * @internal
 */
const DeployTypeInput = /* @__PURE__ */(() => z.union([z.literal("standard"), z.literal("autoFactory"), z.literal("customFactory")]))();

/**
 * @internal
 */
const RouterTypeInput = /* @__PURE__ */(() => z.union([z.literal("none"), z.literal("plugin"), z.literal("dynamic")]))();

/**
 * @internal
 */
const DeploymentNetworkInput = /* @__PURE__ */(() => z.object({
  allNetworks: z.boolean().optional(),
  networksEnabled: z.array(z.number()).default([])
}))();

/**
 * @internal
 */
const ExtraPublishMetadataSchemaInput = /* @__PURE__ */(() => z.object({
  version: z.string().refine(v => {
    try {
      toSemver(v);
      return true;
    } catch (e) {
      return false;
    }
  }, out => {
    return {
      message: `'${out}' is not a valid semantic version. Should be in the format of major.minor.patch. Ex: 0.4.1`
    };
  }),
  displayName: z.string().optional(),
  description: z.string().optional(),
  externalLinks: z.array(z.object({
    name: z.string(),
    url: z.string()
  })).optional(),
  readme: z.string().optional(),
  license: z.string().optional(),
  changelog: z.string().optional(),
  tags: z.array(z.string()).optional(),
  audit: FileOrBufferOrStringSchema.nullable().optional(),
  logo: FileOrBufferOrStringSchema.nullable().optional(),
  isDeployableViaFactory: z.boolean().optional(),
  isDeployableViaProxy: z.boolean().optional(),
  factoryDeploymentData: FactoryDeploymentSchema.optional(),
  deployType: DeployTypeInput.optional(),
  routerType: RouterTypeInput.optional(),
  defaultExtensions: z.array(z.object({
    extensionName: z.string(),
    extensionVersion: z.string().default("latest"),
    publisherAddress: AddressOrEnsSchema
  })).optional(),
  networksForDeployment: DeploymentNetworkInput.optional(),
  constructorParams: z.record(z.string(), z.object({
    displayName: z.string().optional(),
    description: z.string().optional(),
    defaultValue: z.string().optional(),
    hidden: z.boolean().optional()
  }).catchall(z.any())).optional(),
  compositeAbi: AbiSchema.optional()
}).catchall(z.any()))();

/**
 * @internal
 */
const ExtraPublishMetadataSchemaOutput = /* @__PURE__ */(() => ExtraPublishMetadataSchemaInput.extend({
  audit: z.string().nullable().optional(),
  logo: z.string().nullable().optional()
}))();
/**
 * @internal
 */
const FullPublishMetadataSchemaInput = /* @__PURE__ */(() => PreDeployMetadata.merge(ExtraPublishMetadataSchemaInput).extend({
  publisher: AddressOrEnsSchema.optional()
}))();

/**
 * @internal
 */
const FullPublishMetadataSchemaOutput = /* @__PURE__ */(() => PreDeployMetadata.merge(ExtraPublishMetadataSchemaOutput).extend({
  publisher: AddressOrEnsSchema.optional()
}))();
/**
 * @internal
 */
const ProfileSchemaInput = /* @__PURE__ */(() => z.object({
  name: z.string().optional(),
  bio: z.string().optional(),
  avatar: FileOrBufferOrStringSchema.nullable().optional(),
  website: z.string().optional(),
  twitter: z.string().optional(),
  telegram: z.string().optional(),
  facebook: z.string().optional(),
  github: z.string().optional(),
  medium: z.string().optional(),
  linkedin: z.string().optional(),
  reddit: z.string().optional(),
  discord: z.string().optional()
}))();
const ProfileSchemaOutput = /* @__PURE__ */(() => ProfileSchemaInput.extend({
  avatar: z.string().nullable().optional()
}))();
/**
 * @internal
 */
const PublishedContractSchema = /* @__PURE__ */(() => z.object({
  id: z.string(),
  timestamp: BigNumberishSchema,
  metadataUri: z.string()
}))();

/**
 * @internal
 * Follows https://docs.soliditylang.org/en/v0.8.15/natspec-format.html
 */
const ContractInfoSchema = /* @__PURE__ */(() => z.object({
  title: z.string().optional(),
  author: z.string().optional(),
  details: z.string().optional(),
  notice: z.string().optional()
}))();

/**
 * @internal
 */
const CompilerMetadataFetchedSchema = /* @__PURE__ */(() => z.object({
  name: z.string(),
  abi: AbiSchema,
  metadata: z.record(z.string(), z.any()),
  info: ContractInfoSchema,
  licenses: z.array(z.string().optional()).default([]).transform(v => {
    return v.filter(license => license !== undefined);
  }),
  isPartialAbi: z.boolean().optional()
}))();

/**
 * @internal
 */
const PreDeployMetadataFetchedSchema = /* @__PURE__ */(() => PreDeployMetadata.merge(CompilerMetadataFetchedSchema).extend({
  bytecode: z.string(),
  fetchedMetadataUri: z.string(),
  fetchedBytecodeUri: z.string()
}))();

/**
 * Fetch and parse the full metadata AFTER publishing a contract, with all the extra information (version, readme, etc)
 * @internal
 * @param publishMetadataUri - The publish metadata URI to fetch
 * @param storage - The storage to use
 */
async function fetchExtendedReleaseMetadata(publishMetadataUri, storage) {
  const meta = await (await storage.download(publishMetadataUri)).text();
  return FullPublishMetadataSchemaOutput.parse(JSON.parse(meta));
}

const CONTRACT_METADATA_TIMEOUT_SEC = 2;

/**
 * @internal
 * @param compilerMetadataUri - The compiler metadata URI to fetch
 * @param storage - The storage to use
 */
async function fetchContractMetadata(compilerMetadataUri, storage) {
  // short timeout to avoid hanging on unpinned contract metadata CIDs
  const metadata = await storage.downloadJSON(compilerMetadataUri, {
    timeoutInSeconds: CONTRACT_METADATA_TIMEOUT_SEC
  });
  if (!metadata || !metadata.output) {
    throw new Error(`Could not resolve metadata for contract at ${compilerMetadataUri}`);
  }
  return formatCompilerMetadata(metadata);
}

/**
 * @internal
 */
function formatCompilerMetadata(metadata) {
  const abi = AbiSchema.parse(metadata.output.abi);
  const compilationTarget = metadata.settings.compilationTarget;
  const targets = Object.keys(compilationTarget);
  const name = compilationTarget[targets[0]];
  const info = ContractInfoSchema.parse({
    title: metadata.output.devdoc.title,
    author: metadata.output.devdoc.author,
    details: metadata.output.devdoc.detail,
    notice: metadata.output.userdoc.notice
  });
  const licenses = [...new Set(Object.entries(metadata.sources).map(_ref => {
    let [, src] = _ref;
    return src.license;
  }))];
  return {
    name,
    abi,
    metadata,
    info,
    licenses,
    isPartialAbi: metadata.isPartialAbi
  };
}

/**
 * @internal
 * @param publishMetadataUri - The publish metadata URI to fetch
 * @param storage - The storage to use
 */
async function fetchRawPredeployMetadata(publishMetadataUri, storage) {
  return PreDeployMetadata.parse(JSON.parse(await (await storage.download(publishMetadataUri)).text()));
}

/**
 * Fetch the metadata coming from CLI, this is before deploying or releasing the contract.
 * @internal
 * @param publishMetadataUri - The publish metadata URI to fetch
 * @param storage - The storage to use
 */
async function fetchPreDeployMetadata(publishMetadataUri, storage, compilerOptions) {
  const rawMeta = await fetchRawPredeployMetadata(publishMetadataUri, storage);
  let bytecodeUri;
  let metadataUri;

  // TODO: Add an invariant, throw if no compilers in rawMeta in case compilerOptions are provided.
  // Keeping it this way until all contracts are republished with new metadata.
  if (compilerOptions && rawMeta.compilers) {
    let metadata;
    switch (compilerOptions.compilerType) {
      case "solc":
        {
          if (compilerOptions.compilerVersion) {
            metadata = rawMeta.compilers.solc?.find(m => m.compilerVersion === compilerOptions.compilerVersion && m.evmVersion === compilerOptions.evmVersion);
          } else if (rawMeta.compilers.solc) {
            const len = rawMeta.compilers.solc.length;
            metadata = rawMeta.compilers.solc[len - 1];
          }
          break;
        }
      case "zksolc":
        {
          if (compilerOptions.compilerVersion) {
            metadata = rawMeta.compilers.zksolc?.find(m => m.compilerVersion === compilerOptions.compilerVersion && m.evmVersion === compilerOptions.evmVersion);
          } else if (rawMeta.compilers.zksolc) {
            const len = rawMeta.compilers.zksolc.length;
            metadata = rawMeta.compilers.zksolc[len - 1];
          }
          break;
        }
    }
    invariant(metadata, "Compiler or EVM version not found");
    bytecodeUri = metadata.bytecodeUri;
    metadataUri = metadata.metadataUri;
  } else {
    bytecodeUri = rawMeta.bytecodeUri;
    metadataUri = rawMeta.metadataUri;
  }
  const [deployBytecode, parsedMeta] = await Promise.all([storage.download(bytecodeUri), fetchContractMetadata(metadataUri, storage)]);
  return PreDeployMetadataFetchedSchema.parse({
    ...rawMeta,
    ...parsedMeta,
    bytecode: await deployBytecode.text(),
    fetchedMetadataUri: metadataUri,
    fetchedBytecodeUri: bytecodeUri
  });
}

/**
 * @internal
 */
const isBrowser = () => typeof window !== "undefined";

/**
 * @internal
 */
const isNode = () => !isBrowser();

/**
 * @internal
 */
function unique(a, fn) {
  if (a.length === 0 || a.length === 1) {
    return a;
  }
  if (!fn) {
    return a;
  }
  for (let i = 0; i < a.length; i++) {
    for (let j = i + 1; j < a.length; j++) {
      if (fn(a[i], a[j])) {
        a.splice(j, 1);
        j--;
      }
    }
  }
  return a;
}

/**
 * @internal
 */
function createLruCache(maxEntries) {
  let store = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Map();
  function put(key, value) {
    if (store.size >= maxEntries) {
      const keyToDelete = store.keys().next().value;
      store.delete(keyToDelete);
    }
    store.set(key, value);
  }
  function get(key) {
    const hasKey = store.has(key);
    if (!hasKey) {
      return undefined;
    }
    const entry = store.get(key);
    store.delete(key);
    store.set(key, entry);
    return entry;
  }
  function has(key) {
    return store.has(key);
  }
  return {
    put,
    get,
    has,
    maxEntries,
    store
  };
}

const deployMetadataCache = /* @__PURE__ */createLruCache(20);

/**
 * @internal
 */
async function fetchAndCacheDeployMetadata(publishMetadataUri, storage, compilerOptions) {
  const compiler = compilerOptions ? `${compilerOptions.compilerType}_${compilerOptions.compilerVersion || ""}_${compilerOptions.evmVersion || ""}
  ` : "default";
  const cacheKey = `${compiler}_${publishMetadataUri}`;
  const cached = deployMetadataCache.get(cacheKey);
  if (cached) {
    return cached;
  }
  const compilerMetadata = await fetchPreDeployMetadata(publishMetadataUri, storage, compilerOptions);
  let extendedMetadata;
  try {
    extendedMetadata = await fetchExtendedReleaseMetadata(publishMetadataUri, storage);
  } catch (e) {
    // not a factory deployment, ignore
  }
  const data = {
    compilerMetadata,
    extendedMetadata
  };
  deployMetadataCache.put(cacheKey, data);
  return data;
}

// @ts-expect-error - readonly vs not
let supportedChains = defaultChains;

/**
 * @internal
 */
function setSupportedChains(chains) {
  if (chains && chains.length > 0) {
    supportedChains = chains;
  } else {
    // @ts-expect-error - readonly vs not
    supportedChains = defaultChains;
  }
}

/**
 * @internal
 */
function getSupportedChains() {
  return supportedChains;
}

const THIRDWEB_DEPLOYER = "0xdd99b75f095d0c4d5112aCe938e4e6ed962fb024";

/**
 * @internal
 */
async function fetchPublishedContractFromPolygon(publisherAddress, contractName) {
  let version = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "latest";
  let storage = arguments.length > 3 ? arguments[3] : undefined;
  let clientId = arguments.length > 4 ? arguments[4] : undefined;
  let secretKey = arguments.length > 5 ? arguments[5] : undefined;
  const polygonChain = getSupportedChains().find(c => c.chainId === 137);
  const chain = polygonChain || Polygon;
  const publisher = await resolveAddress(publisherAddress);
  const ContractPublisherAbi = (await import('@thirdweb-dev/contracts-js/dist/abis/ContractPublisher.json')).default;
  const contract = new Contract(getContractPublisherAddress(), ContractPublisherAbi, getChainProvider(chain, {
    clientId,
    secretKey
  }));
  let publishedContract;
  if (!version || version === "latest") {
    const model = await contract.getPublishedContract(publisher, contractName);
    publishedContract = PublishedContractSchema.parse({
      id: model.contractId,
      timestamp: model.publishTimestamp,
      metadataUri: model.publishMetadataUri
    });
  } else {
    const allVersions = (await contract.getPublishedContractVersions(publisher, contractName)).map(c => {
      return PublishedContractSchema.parse({
        id: c.contractId,
        timestamp: c.publishTimestamp,
        metadataUri: c.publishMetadataUri
      });
    });

    // get the metadata for each version
    const versionMetadata = (await Promise.all(allVersions.map(c => fetchAndCacheDeployMetadata(c.metadataUri, storage)))).map((item, index) => ({
      name: allVersions[index].id,
      publishedTimestamp: allVersions[index].timestamp,
      publishedMetadata: item
    }));

    // find the version that matches the version string
    const versionMatch = versionMetadata.find(metadata => metadata.publishedMetadata.extendedMetadata?.version === version);
    invariant(versionMatch, "Contract version not found");
    // match the version back to the contract based on the published timestamp
    publishedContract = allVersions.find(c => c.timestamp === versionMatch.publishedTimestamp);
  }
  if (!publishedContract) {
    throw new Error(`No published contract found for ${contractName} at version by '${THIRDWEB_DEPLOYER}'`);
  }
  return publishedContract;
}

async function getPrebuiltInfo(address, provider) {
  try {
    const IThirdwebContractABI = (await import('@thirdweb-dev/contracts-js/dist/abis/IThirdwebContract.json')).default;
    const contract = new Contract(address, IThirdwebContractABI, provider);
    const [_type, version] = await Promise.all([contract.contractType(), contract.contractVersion()]);
    const type = utils.toUtf8String(_type) // eslint-disable-next-line no-control-regex
    .replace(/\x00/g, "");
    return {
      type,
      version
    };
  } catch (e) {
    return undefined;
  }
}

/* eslint-disable eqeqeq */
/* eslint-disable better-tree-shaking/no-top-level-side-effects  */
let decoder;
try {
  decoder = new TextDecoder();
} catch (error) {}
let src;
let srcEnd;
let position = 0;
const LEGACY_RECORD_INLINE_ID = 105;
const RECORD_DEFINITIONS_ID = 0xdffe;
const RECORD_INLINE_ID = 0xdfff; // temporary first-come first-serve tag // proposed tag: 0x7265 // 're'
const BUNDLED_STRINGS_ID = 0xdff9;
const PACKED_REFERENCE_TAG_ID = 6;
const STOP_CODE = {};
let currentDecoder = {};
let currentStructures;
let srcString;
let srcStringStart = 0;
let srcStringEnd = 0;
let bundledStrings;
let referenceMap;
let currentExtensions = [];
let currentExtensionRanges = [];
let packedValues;
let dataView;
let restoreMapsAsObject;
let defaultOptions = {
  useRecords: false,
  mapsAsObjects: true
};
let sequentialMode = false;
class Decoder {
  constructor(options) {
    if (options) {
      if ((options.keyMap || options._keyMap) && !options.useRecords) {
        options.useRecords = false;
        options.mapsAsObjects = true;
      }
      if (options.useRecords === false && options.mapsAsObjects === undefined) {
        options.mapsAsObjects = true;
      }
      if (options.getStructures) {
        options.getShared = options.getStructures;
      }
      if (options.getShared && !options.structures) {
        (options.structures = []).uninitialized = true;
      } // this is what we use to denote an uninitialized structures
      if (options.keyMap) {
        this.mapKey = new Map();
        for (let [k, v] of Object.entries(options.keyMap)) {
          this.mapKey.set(v, k);
        }
      }
    }
    Object.assign(this, options);
  }
  decodeKey(key) {
    return this.keyMap ? this.mapKey.get(key) || key : key;
  }
  decode(source, end) {
    if (src) {
      // re-entrant execution, save the state and restore it after we do this decode
      return saveState(() => {
        clearSource();
        return this ? this.decode(source, end) : Decoder.prototype.decode.call(defaultOptions, source, end);
      });
    }
    srcEnd = end > -1 ? end : source.length;
    position = 0;
    srcStringEnd = 0;
    srcString = null;
    bundledStrings = null;
    src = source;
    // this provides cached access to the data view for a buffer if it is getting reused, which is a recommend
    // technique for getting data from a database where it can be copied into an existing buffer instead of creating
    // new ones
    try {
      dataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));
    } catch (error) {
      // if it doesn't have a buffer, maybe it is the wrong type of object
      src = null;
      if (source instanceof Uint8Array) {
        throw error;
      }
      throw new Error("Source must be a Uint8Array or Buffer but was a " + (source && typeof source === "object" ? source.constructor.name : typeof source));
    }
    if (this instanceof Decoder) {
      // eslint-disable-next-line @typescript-eslint/no-this-alias
      currentDecoder = this;
      packedValues = this.sharedValues && (this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) : this.sharedValues);
      if (this.structures) {
        currentStructures = this.structures;
        return checkedRead();
      } else if (!currentStructures || currentStructures.length > 0) {
        currentStructures = [];
      }
    } else {
      currentDecoder = defaultOptions;
      if (!currentStructures || currentStructures.length > 0) {
        currentStructures = [];
      }
      packedValues = null;
    }
    return checkedRead();
  }
}
function checkedRead() {
  try {
    let result = read();
    if (bundledStrings) {
      if (position >= bundledStrings.postBundlePosition) {
        let error = new Error("Unexpected bundle position");
        error.incomplete = true;
        throw error;
      }
      // bundled strings to skip past
      position = bundledStrings.postBundlePosition;
      bundledStrings = null;
    }
    if (position == srcEnd) {
      // finished reading this source, cleanup references
      currentStructures = null;
      src = null;
      if (referenceMap) {
        referenceMap = null;
      }
    } else if (position > srcEnd) {
      // over read
      let error = new Error("Unexpected end of CBOR data");
      error.incomplete = true;
      throw error;
    } else if (!sequentialMode) {
      throw new Error("Data read, but end of buffer not reached");
    }
    // else more to read, but we are reading sequentially, so don't clear source yet
    return result;
  } catch (error) {
    clearSource();
    if (error instanceof RangeError || error.message.startsWith("Unexpected end of buffer")) {
      error.incomplete = true;
    }
    throw error;
  }
}
function read() {
  let token = src[position++];
  let majorType = token >> 5;
  token = token & 0x1f;
  if (token > 0x17) {
    switch (token) {
      case 0x18:
        token = src[position++];
        break;
      case 0x19:
        if (majorType == 7) {
          return getFloat16();
        }
        token = dataView.getUint16(position);
        position += 2;
        break;
      case 0x1a:
        if (majorType == 7) {
          let value = dataView.getFloat32(position);
          if (currentDecoder.useFloat32 > 2) {
            // this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
            let multiplier = mult10[(src[position] & 0x7f) << 1 | src[position + 1] >> 7];
            position += 4;
            return (multiplier * value + (value > 0 ? 0.5 : -0.5) >> 0) / multiplier;
          }
          position += 4;
          return value;
        }
        token = dataView.getUint32(position);
        position += 4;
        break;
      case 0x1b:
        if (majorType == 7) {
          let value = dataView.getFloat64(position);
          position += 8;
          return value;
        }
        if (majorType > 1) {
          if (dataView.getUint32(position) > 0) {
            throw new Error("JavaScript does not support arrays, maps, or strings with length over 4294967295");
          }
          token = dataView.getUint32(position + 4);
        } else if (currentDecoder.int64AsNumber) {
          token = dataView.getUint32(position) * 0x100000000;
          token += dataView.getUint32(position + 4);
        } else {
          token = dataView.getBigUint64(position);
        }
        position += 8;
        break;
      case 0x1f:
        // indefinite length
        switch (majorType) {
          case 2: // byte string
          case 3:
            // text string
            throw new Error("Indefinite length not supported for byte or text strings");
          case 4:
            // array
            let array = [];
            let value,
              i = 0;
            while ((value = read()) != STOP_CODE) {
              array[i++] = value;
            }
            return majorType == 4 ? array : majorType == 3 ? array.join("") : Buffer.concat(array);
          case 5:
            // map
            let key;
            if (currentDecoder.mapsAsObjects) {
              let object = {};
              if (currentDecoder.keyMap) {
                while ((key = read()) != STOP_CODE) {
                  object[safeKey(currentDecoder.decodeKey(key))] = read();
                }
              } else {
                while ((key = read()) != STOP_CODE) {
                  object[safeKey(key)] = read();
                }
              }
              return object;
            } else {
              if (restoreMapsAsObject) {
                currentDecoder.mapsAsObjects = true;
                restoreMapsAsObject = false;
              }
              let map = new Map();
              if (currentDecoder.keyMap) {
                while ((key = read()) != STOP_CODE) {
                  map.set(currentDecoder.decodeKey(key), read());
                }
              } else {
                while ((key = read()) != STOP_CODE) {
                  map.set(key, read());
                }
              }
              return map;
            }
          case 7:
            return STOP_CODE;
          default:
            throw new Error("Invalid major type for indefinite length " + majorType);
        }
      default:
        throw new Error("Unknown token " + token);
    }
  }
  switch (majorType) {
    case 0:
      // positive int
      return token;
    case 1:
      // negative int
      return ~token;
    case 2:
      // buffer
      return readBin(token);
    case 3:
      // string
      if (srcStringEnd >= position) {
        return srcString.slice(position - srcStringStart, (position += token) - srcStringStart);
      }
      if (srcStringEnd == 0 && srcEnd < 140 && token < 32) {
        // for small blocks, avoiding the overhead of the extract call is helpful
        let string = token < 16 ? shortStringInJS(token) : longStringInJS(token);
        if (string != null) {
          return string;
        }
      }
      return readFixedString(token);
    case 4:
      // array
      let array = new Array(token);
      //if (currentDecoder.keyMap) for (let i = 0; i < token; i++) array[i] = currentDecoder.decodeKey(read())
      //else
      for (let i = 0; i < token; i++) {
        array[i] = read();
      }
      return array;
    case 5:
      // map
      if (currentDecoder.mapsAsObjects) {
        let object = {};
        if (currentDecoder.keyMap) {
          for (let i = 0; i < token; i++) {
            object[safeKey(currentDecoder.decodeKey(read()))] = read();
          }
        } else {
          for (let i = 0; i < token; i++) {
            object[safeKey(read())] = read();
          }
        }
        return object;
      } else {
        if (restoreMapsAsObject) {
          currentDecoder.mapsAsObjects = true;
          restoreMapsAsObject = false;
        }
        let map = new Map();
        if (currentDecoder.keyMap) {
          for (let i = 0; i < token; i++) {
            map.set(currentDecoder.decodeKey(read()), read());
          }
        } else {
          for (let i = 0; i < token; i++) {
            map.set(read(), read());
          }
        }
        return map;
      }
    case 6:
      // extension
      if (token >= BUNDLED_STRINGS_ID) {
        let structure = currentStructures[token & 0x1fff]; // check record structures first
        // At some point we may provide an option for dynamic tag assignment with a range like token >= 8 && (token < 16 || (token > 0x80 && token < 0xc0) || (token > 0x130 && token < 0x4000))
        if (structure) {
          if (!structure.read) {
            structure.read = createStructureReader(structure);
          }
          return structure.read();
        }
        if (token < 0x10000) {
          if (token == RECORD_INLINE_ID) {
            // we do a special check for this so that we can keep the currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)
            return recordDefinition(read());
          } else if (token == RECORD_DEFINITIONS_ID) {
            let length = readJustLength();
            let id = read();
            for (let i = 2; i < length; i++) {
              recordDefinition([id++, read()]);
            }
            return read();
          } else if (token == BUNDLED_STRINGS_ID) {
            return readBundleExt();
          }
          if (currentDecoder.getShared) {
            loadShared();
            structure = currentStructures[token & 0x1fff];
            if (structure) {
              if (!structure.read) {
                structure.read = createStructureReader(structure);
              }
              return structure.read();
            }
          }
        }
      }
      let extension = currentExtensions[token];
      if (extension) {
        if (extension.handlesRead) {
          return extension(read);
        } else {
          return extension(read());
        }
      } else {
        let input = read();
        for (let i = 0; i < currentExtensionRanges.length; i++) {
          let value = currentExtensionRanges[i](token, input);
          if (value !== undefined) {
            return value;
          }
        }
        return new Tag(input, token);
      }
    case 7:
      // fixed value
      switch (token) {
        case 0x14:
          return false;
        case 0x15:
          return true;
        case 0x16:
          return null;
        case 0x17:
          return;
        // undefined
        case 0x1f:
        default:
          let packedValue = (packedValues || getPackedValues())[token];
          if (packedValue !== undefined) {
            return packedValue;
          }
          throw new Error("Unknown token " + token);
      }
    default:
      // negative int
      if (isNaN(token)) {
        let error = new Error("Unexpected end of CBOR data");
        error.incomplete = true;
        throw error;
      }
      throw new Error("Unknown CBOR token " + token);
  }
}
const validName = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;
function createStructureReader(structure) {
  function readObject() {
    // get the array size from the header
    let length = src[position++];
    //let majorType = token >> 5
    length = length & 0x1f;
    if (length > 0x17) {
      switch (length) {
        case 0x18:
          length = src[position++];
          break;
        case 0x19:
          length = dataView.getUint16(position);
          position += 2;
          break;
        case 0x1a:
          length = dataView.getUint32(position);
          position += 4;
          break;
        default:
          throw new Error("Expected array header, but got " + src[position - 1]);
      }
    }
    // This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function
    let compiledReader = this.compiledReader; // first look to see if we have the fast compiled function
    while (compiledReader) {
      // we have a fast compiled object literal reader
      if (compiledReader.propertyCount === length) {
        return compiledReader(read);
      } // with the right length, so we use it
      compiledReader = compiledReader.next; // see if there is another reader with the right length
    }
    if (this.slowReads++ >= 3) {
      // create a fast compiled reader
      let array = this.length == length ? this : this.slice(0, length);
      compiledReader = currentDecoder.keyMap ? new Function("r", "return {" + array.map(k => currentDecoder.decodeKey(k)).map(k => validName.test(k) ? safeKey(k) + ":r()" : "[" + JSON.stringify(k) + "]:r()").join(",") + "}") : new Function("r", "return {" + array.map(key => validName.test(key) ? safeKey(key) + ":r()" : "[" + JSON.stringify(key) + "]:r()").join(",") + "}");
      if (this.compiledReader) {
        compiledReader.next = this.compiledReader;
      } // if there is an existing one, we store multiple readers as a linked list because it is usually pretty rare to have multiple readers (of different length) for the same structure
      compiledReader.propertyCount = length;
      this.compiledReader = compiledReader;
      return compiledReader(read);
    }
    let object = {};
    if (currentDecoder.keyMap) {
      for (let i = 0; i < length; i++) {
        object[safeKey(currentDecoder.decodeKey(this[i]))] = read();
      }
    } else {
      for (let i = 0; i < length; i++) {
        object[safeKey(this[i])] = read();
      }
    }
    return object;
  }
  structure.slowReads = 0;
  return readObject;
}
function safeKey(key) {
  return key === "__proto__" ? "__proto_" : key;
}
let readFixedString = readStringJS;
function readStringJS(length) {
  let result;
  if (length < 16) {
    if (result = shortStringInJS(length)) {
      return result;
    }
  }
  if (length > 64 && decoder) {
    return decoder.decode(src.subarray(position, position += length));
  }
  const end = position + length;
  const units = [];
  result = "";
  while (position < end) {
    const byte1 = src[position++];
    if ((byte1 & 0x80) === 0) {
      // 1 byte
      units.push(byte1);
    } else if ((byte1 & 0xe0) === 0xc0) {
      // 2 bytes
      const byte2 = src[position++] & 0x3f;
      units.push((byte1 & 0x1f) << 6 | byte2);
    } else if ((byte1 & 0xf0) === 0xe0) {
      // 3 bytes
      const byte2 = src[position++] & 0x3f;
      const byte3 = src[position++] & 0x3f;
      units.push((byte1 & 0x1f) << 12 | byte2 << 6 | byte3);
    } else if ((byte1 & 0xf8) === 0xf0) {
      // 4 bytes
      const byte2 = src[position++] & 0x3f;
      const byte3 = src[position++] & 0x3f;
      const byte4 = src[position++] & 0x3f;
      let unit = (byte1 & 0x07) << 0x12 | byte2 << 0x0c | byte3 << 0x06 | byte4;
      if (unit > 0xffff) {
        unit -= 0x10000;
        units.push(unit >>> 10 & 0x3ff | 0xd800);
        unit = 0xdc00 | unit & 0x3ff;
      }
      units.push(unit);
    } else {
      units.push(byte1);
    }
    if (units.length >= 0x1000) {
      result += fromCharCode.apply(String, units);
      units.length = 0;
    }
  }
  if (units.length > 0) {
    result += fromCharCode.apply(String, units);
  }
  return result;
}
let fromCharCode = String.fromCharCode;
function longStringInJS(length) {
  let start = position;
  let bytes = new Array(length);
  for (let i = 0; i < length; i++) {
    const byte = src[position++];
    if ((byte & 0x80) > 0) {
      position = start;
      return;
    }
    bytes[i] = byte;
  }
  return fromCharCode.apply(String, bytes);
}
function shortStringInJS(length) {
  if (length < 4) {
    if (length < 2) {
      if (length === 0) {
        return "";
      } else {
        let a = src[position++];
        if ((a & 0x80) > 1) {
          position -= 1;
          return;
        }
        return fromCharCode(a);
      }
    } else {
      let a = src[position++];
      let b = src[position++];
      if ((a & 0x80) > 0 || (b & 0x80) > 0) {
        position -= 2;
        return;
      }
      if (length < 3) {
        return fromCharCode(a, b);
      }
      let c = src[position++];
      if ((c & 0x80) > 0) {
        position -= 3;
        return;
      }
      return fromCharCode(a, b, c);
    }
  } else {
    let a = src[position++];
    let b = src[position++];
    let c = src[position++];
    let d = src[position++];
    if ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {
      position -= 4;
      return;
    }
    if (length < 6) {
      if (length === 4) {
        return fromCharCode(a, b, c, d);
      } else {
        let e = src[position++];
        if ((e & 0x80) > 0) {
          position -= 5;
          return;
        }
        return fromCharCode(a, b, c, d, e);
      }
    } else if (length < 8) {
      let e = src[position++];
      let f = src[position++];
      if ((e & 0x80) > 0 || (f & 0x80) > 0) {
        position -= 6;
        return;
      }
      if (length < 7) {
        return fromCharCode(a, b, c, d, e, f);
      }
      let g = src[position++];
      if ((g & 0x80) > 0) {
        position -= 7;
        return;
      }
      return fromCharCode(a, b, c, d, e, f, g);
    } else {
      let e = src[position++];
      let f = src[position++];
      let g = src[position++];
      let h = src[position++];
      if ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {
        position -= 8;
        return;
      }
      if (length < 10) {
        if (length === 8) {
          return fromCharCode(a, b, c, d, e, f, g, h);
        } else {
          let i = src[position++];
          if ((i & 0x80) > 0) {
            position -= 9;
            return;
          }
          return fromCharCode(a, b, c, d, e, f, g, h, i);
        }
      } else if (length < 12) {
        let i = src[position++];
        let j = src[position++];
        if ((i & 0x80) > 0 || (j & 0x80) > 0) {
          position -= 10;
          return;
        }
        if (length < 11) {
          return fromCharCode(a, b, c, d, e, f, g, h, i, j);
        }
        let k = src[position++];
        if ((k & 0x80) > 0) {
          position -= 11;
          return;
        }
        return fromCharCode(a, b, c, d, e, f, g, h, i, j, k);
      } else {
        let i = src[position++];
        let j = src[position++];
        let k = src[position++];
        let l = src[position++];
        if ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {
          position -= 12;
          return;
        }
        if (length < 14) {
          if (length === 12) {
            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);
          } else {
            let m = src[position++];
            if ((m & 0x80) > 0) {
              position -= 13;
              return;
            }
            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m);
          }
        } else {
          let m = src[position++];
          let n = src[position++];
          if ((m & 0x80) > 0 || (n & 0x80) > 0) {
            position -= 14;
            return;
          }
          if (length < 15) {
            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);
          }
          let o = src[position++];
          if ((o & 0x80) > 0) {
            position -= 15;
            return;
          }
          return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);
        }
      }
    }
  }
}
function readBin(length) {
  return currentDecoder.copyBuffers ?
  // specifically use the copying slice (not the node one)
  Uint8Array.prototype.slice.call(src, position, position += length) : src.subarray(position, position += length);
}
let f32Array = new Float32Array(1);
let u8Array = new Uint8Array(f32Array.buffer, 0, 4);
function getFloat16() {
  let byte0 = src[position++];
  let byte1 = src[position++];
  let exponent = (byte0 & 0x7f) >> 2;
  if (exponent === 0x1f) {
    // specials
    if (byte1 || byte0 & 3) {
      return NaN;
    }
    return byte0 & 0x80 ? -Infinity : Infinity;
  }
  if (exponent === 0) {
    // sub-normals
    // significand with 10 fractional bits and divided by 2^14
    let abs = ((byte0 & 3) << 8 | byte1) / (1 << 24);
    return byte0 & 0x80 ? -abs : abs;
  }
  u8Array[3] = byte0 & 0x80 |
  // sign bit
  (exponent >> 1) + 56; // 4 of 5 of the exponent bits, re-offset-ed
  u8Array[2] = (byte0 & 7) << 5 |
  // last exponent bit and first two mantissa bits
  byte1 >> 3; // next 5 bits of mantissa
  u8Array[1] = byte1 << 5; // last three bits of mantissa
  u8Array[0] = 0;
  return f32Array[0];
}
class Tag {
  constructor(value, tag) {
    this.value = value;
    this.tag = tag;
  }
}
currentExtensions[0] = dateString => {
  // string date extension
  return new Date(dateString);
};
currentExtensions[1] = epochSec => {
  // numeric date extension
  return new Date(Math.round(epochSec * 1000));
};
currentExtensions[2] = buffer => {
  // bigint extension
  let value = BigInt(0);
  for (let i = 0, l = buffer.byteLength; i < l; i++) {
    value = BigInt(buffer[i]) + value << BigInt(8);
  }
  return value;
};
currentExtensions[3] = buffer => {
  // negative bigint extension
  return BigInt(-1) - currentExtensions[2](buffer);
};
currentExtensions[4] = fraction => {
  // best to reparse to maintain accuracy
  return Number(fraction[1] + "e" + fraction[0]);
};
currentExtensions[5] = fraction => {
  // probably not sufficiently accurate
  return fraction[1] * Math.exp(fraction[0] * Math.log(2));
};

// the registration of the record definition extension
const recordDefinition = definition => {
  let id = definition[0] - 0xe000;
  let structure = definition[1];
  let existingStructure = currentStructures[id];
  if (existingStructure && existingStructure.isShared) {
    (currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure;
  }
  currentStructures[id] = structure;
  structure.read = createStructureReader(structure);
  let object = {};
  if (currentDecoder.keyMap) {
    for (let i = 2, l = definition.length; i < l; i++) {
      let key = currentDecoder.decodeKey(structure[i - 2]);
      object[safeKey(key)] = definition[i];
    }
  } else {
    for (let i = 2, l = definition.length; i < l; i++) {
      let key = structure[i - 2];
      object[safeKey(key)] = definition[i];
    }
  }
  return object;
};
currentExtensions[LEGACY_RECORD_INLINE_ID] = recordDefinition;
currentExtensions[14] = value => {
  if (bundledStrings) {
    return bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 += value);
  }
  return new Tag(value, 14);
};
currentExtensions[15] = value => {
  if (bundledStrings) {
    return bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value);
  }
  return new Tag(value, 15);
};
let glbl = {
  Error,
  RegExp
};
currentExtensions[27] = data => {
  // http://cbor.schmorp.de/generic-object
  return (glbl[data[0]] || Error)(data[1], data[2]);
};
const packedTable = _read => {
  if (src[position++] != 0x84) {
    throw new Error("Packed values structure must be followed by a 4 element array");
  }
  let newPackedValues = _read(); // packed values
  packedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues;
  packedValues.prefixes = _read();
  packedValues.suffixes = _read();
  return _read(); // read the rump
};
packedTable.handlesRead = true;
currentExtensions[51] = packedTable;
currentExtensions[PACKED_REFERENCE_TAG_ID] = data => {
  // packed reference
  if (!packedValues) {
    if (currentDecoder.getShared) {
      loadShared();
    } else {
      return new Tag(data, PACKED_REFERENCE_TAG_ID);
    }
  }
  if (typeof data === "number") {
    return packedValues[16 + (data >= 0 ? 2 * data : -2 * data - 1)];
  }
  throw new Error("No support for non-integer packed references yet");
};
currentExtensions[25] = id => {
  return stringRefs[id];
};
currentExtensions[256] = _read => {
  stringRefs = [];
  try {
    return _read();
  } finally {
    stringRefs = null;
  }
};
currentExtensions[256].handlesRead = true;
currentExtensions[28] = _read => {
  // shareable http://cbor.schmorp.de/value-sharing (for structured clones)
  if (!referenceMap) {
    referenceMap = new Map();
    referenceMap.id = 0;
  }
  let id = referenceMap.id++;
  let token = src[position];
  let target;
  // TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read
  // ahead past references to record structure definitions
  if (token >> 5 == 4) {
    target = [];
  } else {
    target = {};
  }
  let refEntry = {
    target
  }; // a placeholder object
  referenceMap.set(id, refEntry);
  let targetProperties = _read(); // read the next value as the target object to id
  if (refEntry.used) {
    // there is a cycle, so we have to assign properties to original target
    return Object.assign(target, targetProperties);
  }
  refEntry.target = targetProperties; // the placeholder wasn't used, replace with the deserialized one
  return targetProperties; // no cycle, can just use the returned read object
};
currentExtensions[28].handlesRead = true;
currentExtensions[29] = id => {
  // sharedref http://cbor.schmorp.de/value-sharing (for structured clones)
  let refEntry = referenceMap.get(id);
  refEntry.used = true;
  return refEntry.target;
};
currentExtensions[258] = array => new Set(array); // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md
(currentExtensions[259] = _read => {
  // https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec
  // for decoding as a standard Map
  if (currentDecoder.mapsAsObjects) {
    currentDecoder.mapsAsObjects = false;
    restoreMapsAsObject = true;
  }
  return _read();
}).handlesRead = true;
function combine(a, b) {
  if (typeof a === "string") {
    return a + b;
  }
  if (a instanceof Array) {
    return a.concat(b);
  }
  return Object.assign({}, a, b);
}
function getPackedValues() {
  if (!packedValues) {
    if (currentDecoder.getShared) {
      loadShared();
    } else {
      throw new Error("No packed values available");
    }
  }
  return packedValues;
}
const SHARED_DATA_TAG_ID = 0x53687264; // ascii 'Shrd'
currentExtensionRanges.push((tag, input) => {
  if (tag >= 225 && tag <= 255) {
    return combine(getPackedValues().prefixes[tag - 224], input);
  }
  if (tag >= 28704 && tag <= 32767) {
    return combine(getPackedValues().prefixes[tag - 28672], input);
  }
  if (tag >= 1879052288 && tag <= 2147483647) {
    return combine(getPackedValues().prefixes[tag - 1879048192], input);
  }
  if (tag >= 216 && tag <= 223) {
    return combine(input, getPackedValues().suffixes[tag - 216]);
  }
  if (tag >= 27647 && tag <= 28671) {
    return combine(input, getPackedValues().suffixes[tag - 27639]);
  }
  if (tag >= 1811940352 && tag <= 1879048191) {
    return combine(input, getPackedValues().suffixes[tag - 1811939328]);
  }
  if (tag == SHARED_DATA_TAG_ID) {
    // we do a special check for this so that we can keep the currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)
    return {
      packedValues: packedValues,
      structures: currentStructures.slice(0),
      version: input
    };
  }
  if (tag == 55799) {
    // self-descriptive CBOR tag, just return input value
    return input;
  }
});
const isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1;
const typedArrays = [Uint8Array];
const typedArrayTags = [64];
for (let i = 0; i < typedArrays.length; i++) {
  registerTypedArray(typedArrays[i], typedArrayTags[i]);
}
function registerTypedArray(TypedArray, tag) {
  let dvMethod = "get" + TypedArray.name.slice(0, -5);
  if (typeof TypedArray !== "function") {
    TypedArray = null;
  }
  let bytesPerElement = TypedArray.BYTES_PER_ELEMENT;
  for (let littleEndian = 0; littleEndian < 2; littleEndian++) {
    if (!littleEndian && bytesPerElement == 1) {
      continue;
    }
    let sizeShift = bytesPerElement == 2 ? 1 : bytesPerElement == 4 ? 2 : 3;
    currentExtensions[littleEndian ? tag : tag - 4] = bytesPerElement == 1 || littleEndian == isLittleEndianMachine ? buffer => {
      if (!TypedArray) {
        throw new Error("Could not find typed array for code " + tag);
      }
      // we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned
      return new TypedArray(Uint8Array.prototype.slice.call(buffer, 0).buffer);
    } : buffer => {
      if (!TypedArray) {
        throw new Error("Could not find typed array for code " + tag);
      }
      let dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      let elements = buffer.length >> sizeShift;
      let ta = new TypedArray(elements);
      let method = dv[dvMethod];
      for (let i = 0; i < elements; i++) {
        ta[i] = method.call(dv, i << sizeShift, littleEndian);
      }
      return ta;
    };
  }
}
function readBundleExt() {
  let length = readJustLength();
  let bundlePosition = position + read();
  for (let i = 2; i < length; i++) {
    // skip past bundles that were already read
    let bundleLength = readJustLength(); // this will increment position, so must add to position afterwards
    position += bundleLength;
  }
  let dataPosition = position;
  position = bundlePosition;
  bundledStrings = [readStringJS(readJustLength()), readStringJS(readJustLength())];
  bundledStrings.position0 = 0;
  bundledStrings.position1 = 0;
  bundledStrings.postBundlePosition = position;
  position = dataPosition;
  return read();
}
function readJustLength() {
  let token = src[position++] & 0x1f;
  if (token > 0x17) {
    switch (token) {
      case 0x18:
        token = src[position++];
        break;
      case 0x19:
        token = dataView.getUint16(position);
        position += 2;
        break;
      case 0x1a:
        token = dataView.getUint32(position);
        position += 4;
        break;
    }
  }
  return token;
}
function loadShared() {
  if (currentDecoder.getShared) {
    let sharedData = saveState(() => {
      // save the state in case getShared modifies our buffer
      src = null;
      return currentDecoder.getShared();
    }) || {};
    let updatedStructures = sharedData.structures || [];
    currentDecoder.sharedVersion = sharedData.version;
    packedValues = currentDecoder.sharedValues = sharedData.packedValues;
    if (currentStructures === true) {
      currentDecoder.structures = currentStructures = updatedStructures;
    } else {
      currentStructures.splice.apply(currentStructures, [0, updatedStructures.length].concat(updatedStructures));
    }
  }
}
function saveState(callback) {
  let savedSrcEnd = srcEnd;
  let savedPosition = position;
  let savedSrcStringStart = srcStringStart;
  let savedSrcStringEnd = srcStringEnd;
  let savedSrcString = srcString;
  let savedReferenceMap = referenceMap;
  let savedBundledStrings = bundledStrings;

  // TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)
  let savedSrc = new Uint8Array(src.slice(0, srcEnd)); // we copy the data in case it changes while external data is processed
  let savedStructures = currentStructures;
  let savedDecoder = currentDecoder;
  let savedSequentialMode = sequentialMode;
  let value = callback();
  srcEnd = savedSrcEnd;
  position = savedPosition;
  srcStringStart = savedSrcStringStart;
  srcStringEnd = savedSrcStringEnd;
  srcString = savedSrcString;
  referenceMap = savedReferenceMap;
  bundledStrings = savedBundledStrings;
  src = savedSrc;
  sequentialMode = savedSequentialMode;
  currentStructures = savedStructures;
  currentDecoder = savedDecoder;
  dataView = new DataView(src.buffer, src.byteOffset, src.byteLength);
  return value;
}
function clearSource() {
  src = null;
  referenceMap = null;
  currentStructures = null;
}
const mult10 = new Array(147); // this is a table matching binary exponents to the multiplier to determine significant digit rounding
for (let i = 0; i < 256; i++) {
  mult10[i] = Number("1e" + Math.floor(45.15 - i * 0.30103));
}
const defaultDecoder = new Decoder({
  useRecords: false
});
const decode = defaultDecoder.decode;

/**
 * @internal
 * @param hex - The hex string to convert to bytes
 */
function hexToBytes(hex) {
  hex = hex.toString(16);
  if (!hex.startsWith("0x")) {
    hex = `0x${hex}`;
  }
  if (!isHexStrict(hex)) {
    throw new Error(`Given value "${hex}" is not a valid hex string.`);
  }
  hex = hex.replace(/^0x/i, "");
  const bytes = [];
  for (let c = 0; c < hex.length; c += 2) {
    bytes.push(parseInt(hex.slice(c, c + 2), 16));
  }
  return bytes;
}

/**
 * @internal
 * @param hex - The hex string to check
 */
function isHexStrict(hex) {
  return (typeof hex === "string" || typeof hex === "number") && /^(-)?0x[0-9a-f]*$/i.test(hex.toString());
}

/**
 * @internal
 * @param bytecode - The bytecode to extract the IPFS hash from
 */
function extractIPFSHashFromBytecode(bytecode) {
  const numericBytecode = hexToBytes(bytecode);
  const cborLength = numericBytecode[numericBytecode.length - 2] * 0x100 + numericBytecode[numericBytecode.length - 1];
  const bytecodeBuffer = Uint8Array.from(numericBytecode.slice(numericBytecode.length - 2 - cborLength, -2));
  const cborData = decode(bytecodeBuffer);
  if ("ipfs" in cborData && cborData["ipfs"]) {
    try {
      return `ipfs://${bs58.encode(cborData["ipfs"])}`;
    } catch (e) {
      console.warn("feature-detection ipfs cbor failed", e);
    }
  }
  return undefined;
}

/**
 * @internal
 * @param bytecode - The bytecode to check
 */
function extractMinimalProxyImplementationAddress(bytecode) {
  // EIP-1167 clone minimal proxy - https://eips.ethereum.org/EIPS/eip-1167
  if (bytecode.startsWith("0x363d3d373d3d3d363d73")) {
    const implementationAddress = bytecode.slice(22, 62);
    return `0x${implementationAddress}`;
  }

  // Minimal Proxy with receive() from 0xSplits - https://github.com/0xSplits/splits-contracts/blob/c7b741926ec9746182d0d1e2c4c2046102e5d337/contracts/libraries/Clones.sol
  if (bytecode.startsWith("0x36603057343d5230")) {
    // +40 = size of addr
    const implementationAddress = bytecode.slice(122, 122 + 40);
    return `0x${implementationAddress}`;
  }

  // 0age's minimal proxy - https://medium.com/coinmonks/the-more-minimal-proxy-5756ae08ee48
  if (bytecode.startsWith("0x3d3d3d3d363d3d37363d73")) {
    // +40 = size of addr
    const implementationAddress = bytecode.slice(24, 24 + 40);
    return `0x${implementationAddress}`;
  }

  // vyper's minimal proxy (uniswap v1) - https://etherscan.io/address/0x09cabec1ead1c0ba254b09efb3ee13841712be14#code
  if (bytecode.startsWith("0x366000600037611000600036600073")) {
    const implementationAddress = bytecode.slice(32, 32 + 40);
    return `0x${implementationAddress}`;
  }
  if (bytecode.startsWith("0x36600080376020600036600073")) {
    const implementationAddress = bytecode.slice(28, 28 + 40);
    return `0x${implementationAddress}`;
  }

  // EIP-7511 minimal proxy with PUSH0 opcode - https://eips.ethereum.org/EIPS/eip-7511
  if (bytecode.startsWith("0x365f5f375f5f365f73")) {
    const implementationAddress = bytecode.slice(20, 60);
    return `0x${implementationAddress}`;
  }
  return undefined;
}

/**
 * @internal
 * @param address - the contract address
 * @param provider - RPC provider
 */
async function resolveContractUriFromAddress(address, provider) {
  const {
    bytecode
  } = await resolveImplementation(address, provider);
  return extractIPFSHashFromBytecode(bytecode);
}

/**
 * @internal
 */
async function resolveContractUriAndBytecode(address, provider) {
  const {
    bytecode
  } = await resolveImplementation(address, provider);
  return {
    uri: extractIPFSHashFromBytecode(bytecode),
    bytecode
  };
}

/**
 * Resolve the implementation address of a proxy contract and its bytecode
 * @param address - the contract address
 * @param provider - RPC provider
 * @returns The implementation address and its bytecode
 */
async function resolveImplementation(address, provider) {
  const [bytecode, beacon] = await Promise.all([fetchBytecode(address, provider), getBeaconFromStorageSlot(address, provider)]);

  // check minimal proxy first synchronously
  const minimalProxyImplementationAddress = extractMinimalProxyImplementationAddress(bytecode);
  if (minimalProxyImplementationAddress) {
    return {
      address: minimalProxyImplementationAddress,
      bytecode: await fetchBytecode(minimalProxyImplementationAddress, provider)
    };
  }

  // check other proxy types
  if (beacon && beacon !== constants.AddressZero) {
    // In case of a BeaconProxy, it is setup as BeaconProxy --> Beacon --> Implementation
    // Hence we replace the proxy address with Beacon address, and continue further resolving below
    address = beacon;
  }
  const impl = await Promise.all([getImplementationFromStorageSlot(address, provider), getImplementationFromContractCall(address, provider)]);
  for (const implementationAddress of impl) {
    if (implementationAddress && utils.isAddress(implementationAddress) && implementationAddress !== constants.AddressZero) {
      try {
        const implBytecode = await fetchBytecode(implementationAddress, provider);
        return {
          address: implementationAddress,
          bytecode: implBytecode
        };
      } catch (e) {
        if (e instanceof Error) {
          // Ignore if fetchBytecode throws the error below, implying that bytecode is 0x.
          // In that case we don't want to throw, and just return the original contract address and bytecode.
          if (!e.message.includes(`Contract at ${implementationAddress} does not exist on chain`)) {
            throw e;
          }
        }
      }
    }
  }
  return {
    address,
    bytecode
  };
}
async function fetchBytecode(address, provider) {
  try {
    const bytecode = await provider.getCode(address);
    if (bytecode === "0x") {
      const chain = await provider.getNetwork();
      throw new Error(`Contract at ${address} does not exist on chain '${chain.name}' (chainId: ${chain.chainId})`);
    }
    return bytecode;
  } catch (e) {
    throw new Error(`Failed to get bytecode for address ${address}: ${e}`);
  }
}
async function getImplementationFromStorageSlot(address, provider) {
  try {
    const proxyStorage = await provider.getStorageAt(address, BigNumber.from("0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc"));
    return `0x${proxyStorage.slice(-40)}`;
  } catch (e) {
    return undefined;
  }
}
async function getBeaconFromStorageSlot(address, provider) {
  /**
   * The storage slot of the Beacon as defined in EIP-1967
   * See https://eips.ethereum.org/EIPS/eip-1967#beacon-contract-address
   *
   * bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1))
   */

  try {
    const proxyStorage = await provider.getStorageAt(address, BigNumber.from("0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50"));
    return `0x${proxyStorage.slice(-40)}`;
  } catch (e) {
    return undefined;
  }
}
async function getImplementationFromContractCall(address, provider) {
  try {
    const proxy = new Contract(address, UPGRADEABLE_PROXY_ABI, provider);
    return await proxy.implementation();
  } catch (e) {
    return undefined;
  }
}
const UPGRADEABLE_PROXY_ABI = [{
  type: "function",
  name: "implementation",
  inputs: [],
  outputs: [{
    type: "address",
    name: "",
    internalType: "address"
  }],
  stateMutability: "view"
}];

const MultichainRegistry_address = "0xcdAD8FA86e18538aC207872E8ff3536501431B73"; // Polygon only

/**
 * @internal
 */
function getMultichainRegistryAddress() {
  return getProcessEnv("multiChainRegistryAddress", MultichainRegistry_address);
}

/**
 * @internal
 */
function joinABIs(abis, abiWithConstructor) {
  const parsedABIs = abis.map(abi => AbiSchema.parse(abi)).flat();
  const filteredABIs = parsedABIs.filter(item => item.type !== "constructor");
  if (abiWithConstructor) {
    filteredABIs.push(...AbiSchema.parse(abiWithConstructor));
  }
  const finalABIs = unique(filteredABIs, (a, b) => {
    return a.name === b.name && a.type === b.type && a.inputs.length === b.inputs.length;
  });
  return AbiSchema.parse(finalABIs);
}

const FEATURE_TOKEN_CLAIM_CONDITIONS_V1 = {
  name: "ERC20ClaimConditionsV1",
  namespace: "token.drop.claim",
  docLinks: {
    sdk: "sdk.erc20dclaimable",
    contracts: "erc20claimconditions"
  },
  abis: [ERC20Abi, IDropSinglePhaseV1],
  features: {}
};
const FEATURE_TOKEN_CLAIM_CONDITIONS_V2 = {
  name: "ERC20ClaimConditionsV2",
  namespace: "token.drop.claim",
  docLinks: {
    sdk: "sdk.erc20dclaimable",
    contracts: "erc20claimconditions"
  },
  abis: [ERC20Abi, IDropSinglePhase],
  features: {}
};
const FEATURE_TOKEN_CLAIM_PHASES_V2 = {
  name: "ERC20ClaimPhasesV2",
  namespace: "token.drop.claim",
  docLinks: {
    sdk: "sdk.erc20dclaimable",
    contracts: "erc20claimphases"
  },
  abis: [ERC20Abi, IDrop],
  features: {}
};
const FEATURE_TOKEN_CLAIM_PHASES_V1 = {
  name: "ERC20ClaimPhasesV1",
  namespace: "token.drop.claim",
  docLinks: {
    sdk: "sdk.erc20dclaimable",
    contracts: "erc20claimphases"
  },
  abis: [DropERC20_V2Abi],
  features: {}
};
const FEATURE_TOKEN_BURNABLE = {
  name: "ERC20Burnable",
  namespace: "token.burn",
  docLinks: {
    sdk: "sdk.erc20burnable",
    contracts: "erc20burnable"
  },
  abis: [ERC20Abi, IBurnableERC20Abi],
  features: {}
};
const FEATURE_TOKEN_SIGNATURE_MINTABLE = {
  name: "ERC20SignatureMintable",
  namespace: "token.signature",
  docLinks: {
    sdk: "sdk.erc20signaturemintable",
    contracts: "erc20signaturemint"
  },
  abis: [ERC20Abi, ISignatureMintERC20Abi],
  features: {}
};
const FEATURE_TOKEN_BATCH_MINTABLE = {
  name: "ERC20BatchMintable",
  namespace: "token.mint.batch",
  docLinks: {
    sdk: "sdk.erc20batchmintable",
    contracts: "erc20batchmintable"
  },
  abis: [ERC20Abi, IMintableERC20Abi, MulticallAbi],
  features: {}
};
const FEATURE_TOKEN_MINTABLE = {
  name: "ERC20Mintable",
  namespace: "token.mint",
  docLinks: {
    sdk: "sdk.erc20mintable",
    contracts: "erc20mintable"
  },
  abis: [ERC20Abi, IMintableERC20Abi],
  features: {
    [FEATURE_TOKEN_BATCH_MINTABLE.name]: FEATURE_TOKEN_BATCH_MINTABLE
  }
};
const FEATURE_TOKEN_PERMIT = {
  name: "ERC20Permit",
  namespace: "token.permit",
  docLinks: {
    sdk: "sdk.erc20permit",
    contracts: "erc20permit"
  },
  abis: [ERC20Abi, IERC20PermitAbi],
  features: {}
};
const FEATURE_TOKEN = {
  name: "ERC20",
  namespace: "token",
  docLinks: {
    sdk: "sdk.erc20",
    contracts: "erc20"
  },
  abis: [ERC20Abi, IERC20MetadataAbi],
  features: {
    [FEATURE_TOKEN_BURNABLE.name]: FEATURE_TOKEN_BURNABLE,
    [FEATURE_TOKEN_MINTABLE.name]: FEATURE_TOKEN_MINTABLE,
    [FEATURE_TOKEN_CLAIM_CONDITIONS_V1.name]: FEATURE_TOKEN_CLAIM_CONDITIONS_V1,
    [FEATURE_TOKEN_CLAIM_CONDITIONS_V2.name]: FEATURE_TOKEN_CLAIM_CONDITIONS_V2,
    [FEATURE_TOKEN_CLAIM_PHASES_V1.name]: FEATURE_TOKEN_CLAIM_PHASES_V1,
    [FEATURE_TOKEN_CLAIM_PHASES_V2.name]: FEATURE_TOKEN_CLAIM_PHASES_V2,
    [FEATURE_TOKEN_SIGNATURE_MINTABLE.name]: FEATURE_TOKEN_SIGNATURE_MINTABLE,
    [FEATURE_TOKEN_PERMIT.name]: FEATURE_TOKEN_PERMIT
  }
};

const FEATURE_NFT_BURNABLE = {
  name: "ERC721Burnable",
  namespace: "nft.burn",
  docLinks: {
    sdk: "sdk.erc721burnable",
    contracts: "erc721burnable"
  },
  abis: [Erc721Abi, IBurnableERC721Abi],
  features: {}
};
const FEATURE_NFT_REVEALABLE = {
  name: "ERC721Revealable",
  namespace: "nft.drop.revealer",
  docLinks: {
    sdk: "sdk.delayedreveal",
    contracts: "erc721revealable"
  },
  abis: [Erc721Abi, ILazyMintAbi, DelayedRevealAbi],
  features: {}
};
const FEATURE_NFT_TIERED_DROP = {
  name: "ERC721TieredDrop",
  namespace: "nft.tieredDrop",
  docLinks: {
    sdk: "sdk.erc721tiereddrop",
    //TODO
    contracts: ""
  },
  abis: [Erc721Abi, TieredDropAbi],
  features: {}
};
const FEATURE_NFT_CLAIM_CONDITIONS_V1 = {
  name: "ERC721ClaimConditionsV1",
  namespace: "nft.drop.claim",
  docLinks: {
    sdk: "sdk.erc721claimable",
    contracts: "erc721claimconditions"
  },
  abis: [Erc721Abi, IDropSinglePhaseV1],
  features: {}
};
const FEATURE_NFT_CLAIM_CONDITIONS_V2 = {
  name: "ERC721ClaimConditionsV2",
  namespace: "nft.drop.claim",
  docLinks: {
    sdk: "sdk.erc721claimable",
    contracts: "erc721claimconditions"
  },
  abis: [Erc721Abi, IDropSinglePhase],
  features: {}
};
const FEATURE_NFT_CLAIM_PHASES_V1 = {
  name: "ERC721ClaimPhasesV1",
  namespace: "nft.drop.claim",
  docLinks: {
    sdk: "sdk.erc721claimable",
    contracts: "erc721claimphases"
  },
  abis: [DropERC721_V3Abi],
  features: {}
};
const FEATURE_NFT_CLAIM_PHASES_V2 = {
  name: "ERC721ClaimPhasesV2",
  namespace: "nft.drop.claim",
  docLinks: {
    sdk: "sdk.erc721claimable",
    contracts: "erc721claimphases"
  },
  abis: [Erc721Abi, IDrop],
  features: {}
};
const FEATURE_NFT_CLAIM_CUSTOM = {
  name: "ERC721ClaimCustom",
  namespace: "nft.drop.claim",
  docLinks: {
    sdk: "sdk.erc721claimable",
    contracts: "erc721claimcustom"
  },
  abis: [Erc721Abi, IClaimableERC721],
  features: {}
};
const FEATURE_NFT_CLAIM_ZORA = {
  name: "ERC721ClaimZora",
  namespace: "nft.drop.claim",
  docLinks: {
    sdk: "sdk.erc721claimable",
    contracts: "erc721claimzora"
  },
  abis: [Erc721Abi, zora_IDropERC721],
  features: {}
};
const FEATURE_NFT_LAZY_MINTABLE = {
  name: "ERC721LazyMintable",
  namespace: "nft.drop",
  docLinks: {
    sdk: "sdk.erc721lazymintable",
    contracts: "lazymint"
  },
  abis: [Erc721Abi, ILazyMintAbi],
  features: {
    [FEATURE_NFT_REVEALABLE.name]: FEATURE_NFT_REVEALABLE
  }
};
const FEATURE_NFT_BATCH_MINTABLE = {
  name: "ERC721BatchMintable",
  namespace: "nft.mint.batch",
  docLinks: {
    sdk: "sdk.erc721batchmintable",
    contracts: "erc721batchmintable"
  },
  abis: [Erc721Abi, IMintableERC721Abi, MulticallAbi],
  features: {}
};
const FEATURE_NFT_MINTABLE = {
  name: "ERC721Mintable",
  namespace: "nft.mint",
  docLinks: {
    sdk: "sdk.erc721mintable",
    contracts: "erc721mintable"
  },
  abis: [Erc721Abi, IMintableERC721Abi],
  features: {
    [FEATURE_NFT_BATCH_MINTABLE.name]: FEATURE_NFT_BATCH_MINTABLE
  }
};
const FEATURE_NFT_SIGNATURE_MINTABLE_V2 = {
  name: "ERC721SignatureMintV2",
  namespace: "nft.signature",
  docLinks: {
    sdk: "sdk.erc721signaturemint",
    contracts: "erc721signaturemint"
  },
  abis: [Erc721Abi, SignatureMintERC721Abi],
  features: {}
};
const FEATURE_NFT_SIGNATURE_MINTABLE_V1 = {
  name: "ERC721SignatureMintV1",
  namespace: "nft.signature",
  docLinks: {
    sdk: "sdk.erc721signaturemint",
    contracts: "erc721signaturemint"
  },
  abis: [SignatureMintERC721_V1Abi],
  features: {}
};
const FEATURE_NFT_ENUMERABLE = {
  name: "ERC721Enumerable",
  namespace: "nft.query.owned",
  docLinks: {
    sdk: "sdk.erc721enumerable",
    contracts: "erc721enumerable"
  },
  abis: [Erc721Abi, Erc721EnumerableAbi],
  features: {}
};
const FEATURE_NFT_QUERYABLE = {
  name: "ERC721AQueryable",
  namespace: "nft.query.owned",
  docLinks: {
    sdk: "",
    contracts: ""
  },
  abis: [Erc721AQueryableAbi],
  features: {}
};
const FEATURE_NFT_SUPPLY = {
  name: "ERC721Supply",
  namespace: "nft.query",
  docLinks: {
    sdk: "sdk.erc721supply",
    contracts: "erc721supply"
  },
  abis: [Erc721Abi, Erc721SupplyAbi],
  features: {
    [FEATURE_NFT_ENUMERABLE.name]: FEATURE_NFT_ENUMERABLE,
    [FEATURE_NFT_QUERYABLE.name]: FEATURE_NFT_QUERYABLE
  }
};
const FEATURE_NFT_SHARED_METADATA = {
  name: "ERC721SharedMetadata",
  namespace: "nft.sharedmetadata",
  docLinks: {
    sdk: "sdk.sharedmetadata",
    contracts: "SharedMetadata"
  },
  abis: [Erc721Abi, SharedMetadataAbi],
  features: {}
};
const FEATURE_NFT_LOYALTY_CARD = {
  name: "ERC721LoyaltyCard",
  namespace: "nft.loyaltyCard",
  docLinks: {
    // TODO
    sdk: "",
    contracts: ""
  },
  abis: [ILoyaltyCardAbi],
  features: {}
};
const FEATURE_NFT_UPDATABLE_METADATA = {
  name: "ERC721UpdatableMetadata",
  namespace: "nft.metadata",
  docLinks: {
    // TODO
    sdk: "",
    contracts: ""
  },
  abis: [Erc721Abi, INFTMetadataAbi],
  features: {}
};
const FEATURE_NFT = {
  name: "ERC721",
  namespace: "nft",
  docLinks: {
    sdk: "sdk.erc721",
    contracts: "erc721"
  },
  abis: [Erc721Abi, IERC721MetadataAbi],
  features: {
    [FEATURE_NFT_BURNABLE.name]: FEATURE_NFT_BURNABLE,
    [FEATURE_NFT_SUPPLY.name]: FEATURE_NFT_SUPPLY,
    [FEATURE_NFT_MINTABLE.name]: FEATURE_NFT_MINTABLE,
    [FEATURE_NFT_LAZY_MINTABLE.name]: FEATURE_NFT_LAZY_MINTABLE,
    [FEATURE_NFT_SIGNATURE_MINTABLE_V1.name]: FEATURE_NFT_SIGNATURE_MINTABLE_V1,
    [FEATURE_NFT_SIGNATURE_MINTABLE_V2.name]: FEATURE_NFT_SIGNATURE_MINTABLE_V2,
    [FEATURE_NFT_TIERED_DROP.name]: FEATURE_NFT_TIERED_DROP,
    [FEATURE_NFT_CLAIM_CUSTOM.name]: FEATURE_NFT_CLAIM_CUSTOM,
    [FEATURE_NFT_CLAIM_ZORA.name]: FEATURE_NFT_CLAIM_ZORA,
    [FEATURE_NFT_CLAIM_CONDITIONS_V1.name]: FEATURE_NFT_CLAIM_CONDITIONS_V1,
    [FEATURE_NFT_CLAIM_CONDITIONS_V2.name]: FEATURE_NFT_CLAIM_CONDITIONS_V2,
    [FEATURE_NFT_CLAIM_PHASES_V1.name]: FEATURE_NFT_CLAIM_PHASES_V1,
    [FEATURE_NFT_CLAIM_PHASES_V2.name]: FEATURE_NFT_CLAIM_PHASES_V2,
    [FEATURE_NFT_SHARED_METADATA.name]: FEATURE_NFT_SHARED_METADATA,
    [FEATURE_NFT_LOYALTY_CARD.name]: FEATURE_NFT_LOYALTY_CARD,
    [FEATURE_NFT_UPDATABLE_METADATA.name]: FEATURE_NFT_UPDATABLE_METADATA
  }
};

// TODO could be part of IERC1155Metadata even though its not in the spec
const NAME_SYMBOL_ABI = [{
  inputs: [],
  name: "name",
  outputs: [{
    internalType: "string",
    name: "",
    type: "string"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "symbol",
  outputs: [{
    internalType: "string",
    name: "",
    type: "string"
  }],
  stateMutability: "view",
  type: "function"
}];
const FEATURE_EDITION_BURNABLE = {
  name: "ERC1155Burnable",
  namespace: "edition.burn",
  docLinks: {
    sdk: "sdk.erc1155burnable",
    contracts: "erc1155burnable"
  },
  abis: [Erc1155Abi, IBurnableERC1155Abi],
  features: {}
};
const FEATURE_EDITION_CLAIM_CONDITIONS_V1 = {
  name: "ERC1155ClaimConditionsV1",
  namespace: "edition.drop.claim",
  docLinks: {
    sdk: "sdk.erc1155claimable",
    contracts: "erc1155dropsinglephase"
  },
  abis: [Erc1155Abi, IDropSinglePhase1155_V1],
  features: {}
};
const FEATURE_EDITION_CLAIM_CONDITIONS_V2 = {
  name: "ERC1155ClaimConditionsV2",
  namespace: "edition.drop.claim",
  docLinks: {
    sdk: "sdk.erc1155claimable",
    contracts: "erc1155claimconditions"
  },
  abis: [Erc1155Abi, IDropSinglePhase1155],
  features: {}
};
const FEATURE_EDITION_CLAIM_PHASES_V2 = {
  name: "ERC1155ClaimPhasesV2",
  namespace: "edition.drop.claim",
  docLinks: {
    sdk: "sdk.erc1155claimable",
    contracts: "erc1155claimphases"
  },
  abis: [Erc1155Abi, IDropMultiPhase1155],
  features: {}
};
const FEATURE_EDITION_CLAIM_PHASES_V1 = {
  name: "ERC1155ClaimPhasesV1",
  namespace: "edition.drop.claim",
  docLinks: {
    sdk: "sdk.erc1155claimable",
    contracts: "erc1155claimphases"
  },
  abis: [DropERC1155_V2Abi],
  features: {}
};
const FEATURE_EDITION_CLAIM_CUSTOM = {
  name: "ERC1155ClaimCustom",
  namespace: "edition.drop.claim",
  docLinks: {
    sdk: "sdk.erc1155claimable",
    contracts: "erc1155claimcustom"
  },
  abis: [Erc1155Abi, IClaimableERC1155],
  features: {}
};
const FEATURE_EDITION_REVEALABLE = {
  name: "ERC1155Revealable",
  namespace: "edition.drop.revealer",
  docLinks: {
    sdk: "sdk.drop.delayedreveal",
    contracts: "erc1155revealable"
  },
  abis: [Erc1155Abi, ILazyMintAbi, DelayedRevealAbi],
  features: {}
};
const FEATURE_EDITION_LAZY_MINTABLE_V2 = {
  name: "ERC1155LazyMintableV2",
  namespace: "edition.drop",
  docLinks: {
    sdk: "sdk.erc1155droppable",
    contracts: "lazymint"
  },
  abis: [Erc1155Abi, ILazyMintAbi],
  features: {
    [FEATURE_EDITION_REVEALABLE.name]: FEATURE_EDITION_REVEALABLE
  }
};
const FEATURE_EDITION_LAZY_MINTABLE_V1 = {
  name: "ERC1155LazyMintableV1",
  namespace: "edition.drop",
  docLinks: {
    sdk: "sdk.erc1155droppable",
    contracts: "lazymint"
  },
  abis: [DropERC1155_V2Abi],
  features: {
    [FEATURE_EDITION_CLAIM_PHASES_V1.name]: FEATURE_EDITION_CLAIM_PHASES_V1
  }
};
const FEATURE_EDITION_SIGNATURE_MINTABLE = {
  name: "ERC1155SignatureMintable",
  namespace: "edition.signature",
  docLinks: {
    sdk: "sdk.erc1155signaturemintable",
    contracts: "erc1155signaturemint"
  },
  abis: [Erc1155Abi, ISignatureMintERC1155Abi],
  features: {}
};
const FEATURE_EDITION_BATCH_MINTABLE = {
  name: "ERC1155BatchMintable",
  namespace: "edition.mint.batch",
  docLinks: {
    sdk: "sdk.erc1155batchmintable",
    contracts: "erc1155batchmintable"
  },
  abis: [Erc1155Abi, IMintableERC1155Abi, MulticallAbi],
  features: {}
};
const FEATURE_EDITION_MINTABLE = {
  name: "ERC1155Mintable",
  namespace: "edition.mint",
  docLinks: {
    sdk: "sdk.erc1155mintable",
    contracts: "erc1155mintable"
  },
  abis: [Erc1155Abi, IMintableERC1155Abi],
  features: {
    [FEATURE_EDITION_BATCH_MINTABLE.name]: FEATURE_EDITION_BATCH_MINTABLE
  }
};
const FEATURE_EDITION_ENUMERABLE = {
  name: "ERC1155Enumerable",
  namespace: "edition.query",
  docLinks: {
    sdk: "sdk.erc1155",
    contracts: "erc1155enumerable"
  },
  abis: [Erc1155Abi, Erc1155EnumerableAbi],
  features: {}
};
const FEATURE_EDITION_UPDATABLE_METADATA = {
  name: "ERC1155UpdatableMetadata",
  namespace: "edition.metadata",
  docLinks: {
    // TODO
    sdk: "",
    contracts: ""
  },
  abis: [Erc1155Abi, INFTMetadataAbi],
  features: {}
};
const FEATURE_EDITION_SUPPLY = {
  name: "ERC1155Supply",
  namespace: "edition.supply",
  docLinks: {
    sdk: "",
    contracts: ""
  },
  abis: [Erc1155Abi, Erc1155SupplyAbi],
  features: {}
};
const FEATURE_EDITION = {
  name: "ERC1155",
  namespace: "edition",
  docLinks: {
    sdk: "sdk.erc1155enumerable",
    contracts: "erc1155"
  },
  abis: [Erc1155Abi, Erc1155MetadataAbi, NAME_SYMBOL_ABI],
  features: {
    [FEATURE_EDITION_SUPPLY.name]: FEATURE_EDITION_SUPPLY,
    [FEATURE_EDITION_BURNABLE.name]: FEATURE_EDITION_BURNABLE,
    [FEATURE_EDITION_ENUMERABLE.name]: FEATURE_EDITION_ENUMERABLE,
    [FEATURE_EDITION_MINTABLE.name]: FEATURE_EDITION_MINTABLE,
    [FEATURE_EDITION_LAZY_MINTABLE_V1.name]: FEATURE_EDITION_LAZY_MINTABLE_V1,
    [FEATURE_EDITION_LAZY_MINTABLE_V2.name]: FEATURE_EDITION_LAZY_MINTABLE_V2,
    [FEATURE_EDITION_REVEALABLE.name]: FEATURE_EDITION_REVEALABLE,
    [FEATURE_EDITION_SIGNATURE_MINTABLE.name]: FEATURE_EDITION_SIGNATURE_MINTABLE,
    [FEATURE_EDITION_CLAIM_CUSTOM.name]: FEATURE_EDITION_CLAIM_CUSTOM,
    [FEATURE_EDITION_CLAIM_CONDITIONS_V1.name]: FEATURE_EDITION_CLAIM_CONDITIONS_V1,
    [FEATURE_EDITION_CLAIM_CONDITIONS_V2.name]: FEATURE_EDITION_CLAIM_CONDITIONS_V2,
    [FEATURE_EDITION_CLAIM_PHASES_V2.name]: FEATURE_EDITION_CLAIM_PHASES_V2,
    [FEATURE_EDITION_UPDATABLE_METADATA.name]: FEATURE_EDITION_UPDATABLE_METADATA
  }
};

const fallbackAbi = [{
  stateMutability: "payable",
  type: "fallback"
}];
const getAllPluginsAbi = [{
  inputs: [],
  name: "getAllPlugins",
  outputs: [{
    components: [{
      internalType: "bytes4",
      name: "functionSelector",
      type: "bytes4"
    }, {
      internalType: "string",
      name: "functionSignature",
      type: "string"
    }, {
      internalType: "address",
      name: "pluginAddress",
      type: "address"
    }],
    internalType: "struct IPluginMap.Plugin[]",
    name: "registered",
    type: "tuple[]"
  }],
  stateMutability: "view",
  type: "function"
}];
const getAllExtensionsAbi = [{
  inputs: [],
  name: "getAllExtensions",
  outputs: [{
    components: [{
      components: [{
        internalType: "string",
        name: "name",
        type: "string"
      }, {
        internalType: "string",
        name: "metadataURI",
        type: "string"
      }, {
        internalType: "address",
        name: "implementation",
        type: "address"
      }],
      internalType: "struct IExtension.ExtensionMetadata",
      name: "metadata",
      type: "tuple"
    }, {
      components: [{
        internalType: "bytes4",
        name: "functionSelector",
        type: "bytes4"
      }, {
        internalType: "string",
        name: "functionSignature",
        type: "string"
      }],
      internalType: "struct IExtension.ExtensionFunction[]",
      name: "functions",
      type: "tuple[]"
    }],
    internalType: "struct IExtension.Extension[]",
    name: "allExtensions",
    type: "tuple[]"
  }],
  stateMutability: "view",
  type: "function"
}];
const FEATURE_ROYALTY = {
  name: "Royalty",
  namespace: "royalty",
  docLinks: {
    sdk: "sdk.contractroyalty",
    contracts: "royalty"
  },
  abis: [IThirdwebRoyaltyAbi],
  features: {}
};
const FEATURE_PRIMARY_SALE = {
  name: "PrimarySale",
  namespace: "sales",
  docLinks: {
    sdk: "sdk.contractprimarysale",
    contracts: "primarysale"
  },
  abis: [IThirdwebPrimarySaleAbi],
  features: {}
};
const FEATURE_PLATFORM_FEE = {
  name: "PlatformFee",
  namespace: "platformFees",
  docLinks: {
    sdk: "sdk.platformfee",
    contracts: "platformfee"
  },
  abis: [IThirdwebPlatformFeeAbi],
  features: {}
};
const FEATURE_PERMISSIONS_ENUMERABLE = {
  name: "PermissionsEnumerable",
  namespace: "roles",
  docLinks: {
    sdk: "sdk.contractroles",
    contracts: "permissionsenumerable"
  },
  abis: [IPermissionsEnumerableAbi],
  features: {}
};
const FEATURE_PERMISSIONS = {
  name: "Permissions",
  namespace: "roles",
  docLinks: {
    sdk: "sdk.contractroles",
    contracts: "permissions"
  },
  abis: [IPermissionsAbi],
  features: {
    [FEATURE_PERMISSIONS_ENUMERABLE.name]: FEATURE_PERMISSIONS_ENUMERABLE
  }
};
const FEATURE_METADATA = {
  name: "ContractMetadata",
  namespace: "metadata",
  docLinks: {
    sdk: "sdk.contractmetadata",
    contracts: "contractmetadata"
  },
  abis: [IContractMetadataAbi],
  features: {}
};
const FEATURE_APPURI = {
  name: "AppURI",
  namespace: "appURI",
  docLinks: {
    sdk: "sdk.appURI",
    //TODO
    contracts: ""
  },
  abis: [IAppURI],
  features: {}
};
const FEATURE_OWNER = {
  name: "Ownable",
  namespace: "owner",
  docLinks: {
    sdk: "sdk.owner",
    contracts: "ownable"
  },
  abis: [IOwnableAbi],
  features: {}
};
const FEATURE_GASLESS = {
  name: "Gasless",
  namespace: "gasless",
  docLinks: {
    sdk: "sdk.gaslesstransaction",
    // TODO add the correct name for this once it's added to portal
    contracts: "IERC2771Context"
  },
  abis: [IERC2771ContextAbi],
  features: {}
};
const FEATURE_PACK_VRF = {
  name: "PackVRF",
  namespace: "pack.vrf",
  docLinks: {
    sdk: "sdk.packvrf",
    //TODO
    contracts: "IPackVRF"
  },
  abis: [IPackVRFAbi],
  features: {}
};
const FEATURE_PLUGIN_ROUTER = {
  name: "PluginRouter",
  namespace: "plugin.router",
  docLinks: {
    sdk: "sdk.pluginrouter",
    //TODO
    contracts: "PluginRouter"
  },
  abis: [getAllPluginsAbi],
  features: {}
};
const FEATURE_DYNAMIC_CONTRACT = {
  name: "DynamicContract",
  namespace: "dynamic.contract",
  docLinks: {
    sdk: "",
    //TODO
    contracts: "IExtensionsManager"
  },
  abis: [getAllExtensionsAbi],
  features: {}
};
const FEATURE_DIRECT_LISTINGS = {
  name: "DirectListings",
  namespace: "direct.listings",
  docLinks: {
    // TODO
    sdk: "",
    contracts: "IDirectListings"
  },
  abis: [IDirectListingsAbi],
  features: {}
};
const FEATURE_ENGLISH_AUCTIONS = {
  name: "EnglishAuctions",
  namespace: "english.auctions",
  docLinks: {
    // TODO
    sdk: "",
    contracts: "IEnglishAuctions"
  },
  abis: [IEnglishAuctionsAbi],
  features: {}
};
const FEATURE_OFFERS = {
  name: "Offers",
  namespace: "offers",
  docLinks: {
    // TODO
    sdk: "",
    contracts: "IOffers"
  },
  abis: [IOffersAbi],
  features: {}
};
const FEATURE_ACCOUNT_FACTORY = {
  name: "AccountFactory",
  namespace: "accountFactory",
  docLinks: {
    // TODO
    sdk: "sdk.accountFactory",
    contracts: "IAccountFactory"
  },
  abis: [IAccountFactoryCore],
  features: {}
};
const FEATURE_ACCOUNT_PERMISSIONS_V1 = {
  name: "AccountPermissionsV1",
  namespace: "accountPermissions",
  docLinks: {
    // TODO
    sdk: "sdk.account",
    contracts: "IAccountPermissions"
  },
  abis: [IAccountPermissionsV1],
  features: {}
};
const FEATURE_ACCOUNT_PERMISSIONS = {
  name: "AccountPermissions",
  namespace: "accountPermissions",
  docLinks: {
    // TODO
    sdk: "sdk.account",
    contracts: "IAccountPermissions"
  },
  abis: [IAccountPermissions],
  features: {}
};
const FEATURE_ACCOUNT = {
  name: "Account",
  namespace: "account",
  docLinks: {
    // TODO
    sdk: "sdk.account",
    contracts: "IAccount"
  },
  abis: [IAccount],
  features: {
    [FEATURE_ACCOUNT_PERMISSIONS.name]: FEATURE_ACCOUNT_PERMISSIONS,
    [FEATURE_ACCOUNT_PERMISSIONS_V1.name]: FEATURE_ACCOUNT_PERMISSIONS_V1
  }
};
const FEATURE_AIRDROP_ERC20 = {
  name: "AirdropERC20",
  namespace: "airdrop20",
  docLinks: {
    // TODO
    sdk: "",
    contracts: "IAirdropERC20"
  },
  abis: [IAirdropERC20],
  features: {}
};
const FEATURE_AIRDROP_ERC721 = {
  name: "AirdropERC721",
  namespace: "airdrop721",
  docLinks: {
    // TODO
    sdk: "",
    contracts: "IAirdropERC721"
  },
  abis: [IAirdropERC721],
  features: {}
};
const FEATURE_AIRDROP_ERC1155 = {
  name: "AirdropERC1155",
  namespace: "airdrop1155",
  docLinks: {
    // TODO
    sdk: "",
    contracts: "IAirdropERC1155"
  },
  abis: [IAirdropERC1155],
  features: {}
};
const FEATURE_FALLBACK = {
  name: "Fallback",
  namespace: "fallback",
  docLinks: {
    sdk: "",
    contracts: ""
  },
  abis: [fallbackAbi],
  features: {}
};

/**
 * @internal
 */

/**
 * @internal
 */

/**
 * @internal
 */

/**
 * @internal
 */
const SUPPORTED_FEATURES = {
  [FEATURE_TOKEN.name]: FEATURE_TOKEN,
  [FEATURE_NFT.name]: FEATURE_NFT,
  [FEATURE_EDITION.name]: FEATURE_EDITION,
  [FEATURE_ROYALTY.name]: FEATURE_ROYALTY,
  [FEATURE_PLATFORM_FEE.name]: FEATURE_PLATFORM_FEE,
  [FEATURE_PRIMARY_SALE.name]: FEATURE_PRIMARY_SALE,
  [FEATURE_PERMISSIONS.name]: FEATURE_PERMISSIONS,
  [FEATURE_METADATA.name]: FEATURE_METADATA,
  [FEATURE_APPURI.name]: FEATURE_APPURI,
  [FEATURE_OWNER.name]: FEATURE_OWNER,
  [FEATURE_GASLESS.name]: FEATURE_GASLESS,
  [FEATURE_PACK_VRF.name]: FEATURE_PACK_VRF,
  [FEATURE_PLUGIN_ROUTER.name]: FEATURE_PLUGIN_ROUTER,
  [FEATURE_DYNAMIC_CONTRACT.name]: FEATURE_DYNAMIC_CONTRACT,
  [FEATURE_DIRECT_LISTINGS.name]: FEATURE_DIRECT_LISTINGS,
  [FEATURE_ENGLISH_AUCTIONS.name]: FEATURE_ENGLISH_AUCTIONS,
  [FEATURE_OFFERS.name]: FEATURE_OFFERS,
  [FEATURE_AIRDROP_ERC20.name]: FEATURE_AIRDROP_ERC20,
  [FEATURE_AIRDROP_ERC721.name]: FEATURE_AIRDROP_ERC721,
  [FEATURE_AIRDROP_ERC1155.name]: FEATURE_AIRDROP_ERC1155,
  [FEATURE_ACCOUNT_FACTORY.name]: FEATURE_ACCOUNT_FACTORY,
  [FEATURE_ACCOUNT.name]: FEATURE_ACCOUNT,
  [FEATURE_NFT_LOYALTY_CARD.name]: FEATURE_NFT_LOYALTY_CARD,
  [FEATURE_NFT_UPDATABLE_METADATA.name]: FEATURE_NFT_UPDATABLE_METADATA,
  [FEATURE_FALLBACK.name]: FEATURE_FALLBACK
};

/**
 * @internal
 */
function toJSType(contractType) {
  let isReturnType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  let withName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  let jsType = contractType.type;
  let isArray = false;
  if (jsType.endsWith("[]")) {
    isArray = true;
    jsType = jsType.slice(0, -2);
  }
  if (jsType.startsWith("bytes")) {
    jsType = "BytesLike";
  }
  if (jsType.startsWith("uint") || jsType.startsWith("int")) {
    jsType = isReturnType ? "BigNumber" : "BigNumberish";
  }
  if (jsType.startsWith("bool")) {
    jsType = "boolean";
  }
  if (jsType === "address") {
    jsType = "string";
  }
  if (jsType === "tuple") {
    if (contractType.components) {
      jsType = `{ ${contractType.components.map(a => toJSType(a, false, true)).join(", ")} }`;
    }
  }
  if (isArray) {
    jsType += "[]";
  }
  if (withName) {
    jsType = `${contractType.name}: ${jsType}`;
  }
  return jsType;
}

/**
 * @internal
 * @param name - The name of the function to extract the comment from
 * @param metadata - The metadata to extract the comment from
 * @param type - The type of the function to extract the comment from
 */
function extractCommentFromMetadata(name, metadata, type) {
  return metadata?.output?.userdoc?.[type]?.[Object.keys(metadata?.output?.userdoc[type] || {}).find(fn => fn.includes(name || "unknown")) || ""]?.notice || metadata?.output?.devdoc?.[type]?.[Object.keys(metadata?.output?.devdoc[type] || {}).find(fn => fn.includes(name || "unknown")) || ""]?.details;
}

/**
 * @internal
 * @param abi - The abi to extract functions from
 * @param metadata - The metadata to extract comments from
 */
function extractFunctionsFromAbi(abi, metadata) {
  const functions = (abi || []).filter(el => el.type === "function");
  const parsed = [];
  for (const f of functions) {
    const doc = extractCommentFromMetadata(f.name, metadata, "methods");
    const args = f.inputs?.map(i => `${i.name || "key"}: ${toJSType(i)}`)?.join(", ") || "";
    const fargs = args ? `, [${args}]` : "";
    const out = f.outputs?.map(o => toJSType(o, true))?.join(", ");
    const promise = out ? `: Promise<${out}>` : `: Promise<TransactionResult>`;
    const signature = `contract.call("${f.name}"${fargs})${promise}`;
    parsed.push({
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore we know AbiTypeBaseSchema.name is not going to be undefined since we're doing `.default("")`
      inputs: f.inputs || [],
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore we know the AbiTypeBaseSchema.name is not going to be undefined since we're doing `.default("")`
      outputs: f.outputs || [],
      name: f.name || "unknown",
      signature,
      stateMutability: f.stateMutability || "",
      comment: doc
    });
  }
  return parsed;
}

/**
 * @internal
 * @param contractAbi - The abi to check
 * @param featureAbis - The feature abi to check
 * @returns
 */
function hasMatchingAbi(contractAbi, featureAbis) {
  const contractFn = extractFunctionsFromAbi(contractAbi);
  const interfaceFn = featureAbis.flatMap(i => extractFunctionsFromAbi(i));
  // match every function and their arguments
  const intersection = contractFn.filter(fn => {
    const match = interfaceFn.find(iFn => iFn.name === fn.name && iFn.inputs.length === fn.inputs.length && iFn.inputs.every((i, index) => {
      if (i.type === "tuple" || i.type === "tuple[]") {
        // check that all properties in the tuple are the same type
        return i.type === fn.inputs[index].type && i.components?.every((c, cIndex) => {
          return c.type === fn.inputs[index].components?.[cIndex]?.type;
        });
      }
      return i.type === fn.inputs[index].type;
    }));
    return match !== undefined;
  });
  return intersection.length === interfaceFn.length;
}

/**
 * @internal
 */
function matchesAbiFromBytecode(contractBytecode, featureAbis) {
  const interfaces = featureAbis.map(abi => new Interface(abi));
  const selectors = interfaces.flatMap(i => {
    return Object.values(i.functions).map(fn => Number(i.getSighash(fn)).toString(16));
  });
  const uniqueSelectors = [...new Set(selectors)];
  // checks that all unique selectors are found in the bytecode
  return uniqueSelectors.every(selector => contractBytecode.includes(selector));
}

const lruCache = /* @__PURE__ */createLruCache(10);

/**
 * Processes ALL supported features and sets whether the passed in abi supports each individual feature
 * @internal
 * @param abi - The abi to detect features in
 * @param features - The features to detect
 * @returns The nested struct of all features and whether they're detected in the abi
 */
function detectFeatures(abi) {
  let features = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SUPPORTED_FEATURES;
  const cacheKey = JSON.stringify(abi);
  if (lruCache.has(cacheKey)) {
    return lruCache.get(cacheKey);
  }
  const results = detectFeaturesInternal(abi, features);
  lruCache.put(cacheKey, results);
  return results;
}
function detectFeaturesInternal(abi, features) {
  const results = {};
  for (const featureKey in features) {
    const feature = features[featureKey];
    const enabled = matchesAbiInterface(abi, feature);
    const childResults = detectFeaturesInternal(abi, feature.features);
    results[featureKey] = {
      ...feature,
      features: childResults,
      enabled
    };
  }
  return results;
}

/**
 * @internal
 */
function detectFeaturesFromBytecode(bytecode) {
  let features = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SUPPORTED_FEATURES;
  const results = {};
  for (const featureKey in features) {
    const feature = features[featureKey];
    const enabled = matchesAbiFromBytecode(bytecode, feature.abis);
    const childResults = detectFeaturesFromBytecode(bytecode, feature.features);
    results[featureKey] = {
      ...feature,
      features: childResults,
      enabled
    };
  }
  return results;
}

/**
 * @internal
 * @param abi - The abi to check
 * @param feature - The feature to check
 */
function matchesAbiInterface(abi, feature) {
  // returns true if all the functions in `interfaceToMatch` are found in `contract` (removing any duplicates)
  return hasMatchingAbi(abi, feature.abis);
}

/**
 * @internal
 */
function extractFeatures(input, enabledExtensions) {
  if (!input) {
    return;
  }
  for (const extensionKey in input) {
    const extension = input[extensionKey];
    // if extension is enabled, then add it to enabledFeatures
    if (extension.enabled) {
      enabledExtensions.push(extension);
    }
    // recurse
    extractFeatures(extension.features, enabledExtensions);
  }
}

/**
 * Return all the detected features in the abi
 * @param abi - parsed array of abi entries
 * @returns Array of all detected extensions with full information on each feature
 * @internal
 * @deprecated use getAllDetectedExtensions instead
 */
function getAllDetectedFeatures(abi) {
  const features = [];
  extractFeatures(detectFeatures(abi), features);
  return features;
}

/**
 * @internal
 */
function getAllDetectedExtensionsFromBytecode(bytecode) {
  const features = [];
  extractFeatures(detectFeaturesFromBytecode(bytecode), features);
  return features;
}

/**
 * @internal
 */
function constructAbiFromBytecode(bytecode) {
  let extensions = getAllDetectedExtensionsFromBytecode(bytecode);
  // special deduping for ERC721 and ERC20
  if (extensions.find(f => f.name === "ERC721")) {
    extensions = extensions.filter(f => f.name !== "ERC20");
  }
  const abi = joinABIs(extensions.map(f => joinABIs(f.abis)));
  return abi;
}

/**
 * Return all the detected extensions in the abi
 * @param abi - parsed array of abi entries
 * @returns Array of all detected extensions with full information on each feature
 * @public
 */
function getAllDetectedExtensions(abi) {
  return getAllDetectedFeatures(abi).map(f => ({
    ...f,
    extensions: f.features
  }));
}

const CONTRACT_RESOLVER_BASE_URL = "https://contract.thirdweb.com/metadata";

// Internal static cache
const metadataCache = /* @__PURE__ */createLruCache(20);
let multichainRegistry = undefined;
function getCacheKey(address, chainId) {
  return `${address}-${chainId}`;
}
function putInCache(address, chainId, metadata) {
  metadataCache.put(getCacheKey(address, chainId), metadata);
}

/**
 * @internal
 */
function getContractMetadataFromCache(address, chainId) {
  return metadataCache.get(getCacheKey(address, chainId));
}

/**
 * @internal
 * @param address - The address to fetch the metadata for
 * @param provider - The provider to use
 * @param storage - The storage to use
 */
async function fetchContractMetadataFromAddress(address, provider, storage) {
  let sdkOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  const chainId = (await provider.getNetwork()).chainId; // TODO resolve from sdk network
  const cached = getContractMetadataFromCache(address, chainId);
  if (cached) {
    return cached;
  }
  let metadata;

  // try to resolve from DNS first
  const isLocalChain = chainId === 31337 || chainId === 1337;
  if (!isLocalChain) {
    try {
      const response = await fetch(`${CONTRACT_RESOLVER_BASE_URL}/${chainId}/${address}`, {
        headers: {
          ...getAnalyticsHeaders()
        }
      });
      if (response.ok) {
        const resolvedData = await response.json();
        metadata = formatCompilerMetadata(resolvedData);
      }
    } catch (e) {
      // fallback to IPFS
    }
  }
  if (!metadata) {
    metadata = await fetchContractMetadataFromBytecode(address, chainId, provider, storage, sdkOptions);
  }
  if (!metadata) {
    throw new Error(`Could not resolve contract. Try importing it by visiting: https://thirdweb.com/${chainId}/${address}`);
  }
  if (!metadata.isPartialAbi) {
    putInCache(address, chainId, metadata);
  } else {
    console.warn(`Contract metadata could only be partially resolved, some contract functions might be unavailable. Try importing the contract by visiting: https://thirdweb.com/${chainId}/${address}`);
  }
  return metadata;
}

/**
 * @internal
 */
async function fetchContractMetadataFromBytecode(address, chainId, provider, storage) {
  let sdkOptions = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
  let metadata;
  // we can't race here, because the contract URI might resolve first with a non pinned URI
  const [ipfsData, registryData] = await Promise.all([resolveContractUriAndBytecode(address, provider).catch(() => undefined), getMetadataUriFromMultichainRegistry(address, chainId, sdkOptions).then(uri => {
    if (!uri) {
      return undefined;
    }
    return {
      uri,
      bytecode: ""
    };
  }).catch(() => undefined)]);
  const bytecode = ipfsData?.bytecode;
  const metadataUri = registryData?.uri || ipfsData?.uri;
  if (!metadataUri && !bytecode) {
    throw new Error(`Could not fetch bytecode for contract at ${address} on chain ${chainId}, double check that the address and chainId are correct.`);
  }
  try {
    metadata = await fetchContractMetadata(metadataUri, storage);
  } catch (e) {
    // Don't warn here, its common to not have IPFS metadata for a contract, fallback to bytecode
  }
  if (!metadata && bytecode) {
    const abi = constructAbiFromBytecode(bytecode);
    if (abi && abi.length > 0) {
      // return partial ABI
      metadata = {
        name: "Unimported Contract",
        abi: abi,
        metadata: {},
        info: {},
        licenses: [],
        isPartialAbi: true
      };
      // return without caching
      return metadata;
    }
  }
  return metadata;
}
async function getMetadataUriFromMultichainRegistry(address, chainId, sdkOptions) {
  const TWRegistryABI = (await import('@thirdweb-dev/contracts-js/dist/abis/TWMultichainRegistryLogic.json')).default;
  if (!multichainRegistry) {
    const polygonChain = sdkOptions?.supportedChains?.find(c => c.chainId === 137);
    const chain = polygonChain || Polygon;
    multichainRegistry = new Contract(getMultichainRegistryAddress(), TWRegistryABI, getChainProvider(chain, sdkOptions));
  }
  const importedUri = await multichainRegistry.getMetadataUri(chainId, address);
  return importedUri;
}

/**
 * @internal
 * @param address - The address to fetch the metadata for
 * @param provider - The provider to use
 * @param storage - The storage to use
 * @returns
 */
async function fetchAbiFromAddress(address, provider, storage) {
  try {
    const metadata = await fetchContractMetadataFromAddress(address, provider, storage);
    if (metadata && metadata.abi) {
      return metadata.abi;
    }
  } catch (e) {
    // ignore and return undefined
    // will fallback to embedded ABIs for prebuilts
  }
  return undefined;
}

async function getCompositeABIfromRelease(publishMetadataUri, storage) {
  const {
    extendedMetadata
  } = await fetchAndCacheDeployMetadata(publishMetadataUri, storage);
  const compositeAbi = extendedMetadata?.compositeAbi || [];
  return compositeAbi;
}

const ERROR_SUBSTRINGS = ["eip-155", "eip155", "protected", "invalid chain id for signer", "chain id none", "chain_id mismatch", "recovered sender mismatch", "transaction hash mismatch", "chainid no support", "chainid (0)", "chainid(0)"];
const ERROR_SUBSTRINGS_COMPOSITE = [["account", "not found"], ["wrong", "chainid"]];
const CUSTOM_GAS_BINS = [1, 1 * 10 ** 9, 100 * 10 ** 9, 500 * 10 ** 9, 1000 * 10 ** 9, 2500 * 10 ** 9, 5000 * 10 ** 9, 7500 * 10 ** 9, 10_000 * 10 ** 9, 25_000 * 10 ** 9, 50_000 * 10 ** 9, 75_000 * 10 ** 9, 100_000 * 10 ** 9, 250_000 * 10 ** 9, 500_000 * 10 ** 9, 750_000 * 10 ** 9, 1_000_000 * 10 ** 9];

/* eslint-disable no-useless-computed-key */
const CUSTOM_GAS_FOR_CHAIN = {
  [5001]: {
    name: "Mantle Testnet",
    gasPrice: 1
  },
  [71402]: {
    name: "Godwoken Mainnet",
    gasPrice: 40000 * 10 ** 9
  },
  [1351057110]: {
    name: "Chaos (SKALE Testnet)",
    gasPrice: 100000
  },
  [361]: {
    name: "Theta Mainnet",
    gasPrice: 4000 * 10 ** 9
  },
  [365]: {
    name: "Theta Testnet",
    gasPrice: 4000 * 10 ** 9
  },
  [7700]: {
    name: "Canto",
    gasPrice: 1000 * 10 ** 9
  },
  [7701]: {
    name: "Canto Testnet",
    gasPrice: 1000 * 10 ** 9
  },
  [338]: {
    name: "Cronos Testnet",
    gasPrice: 2000 * 10 ** 9
  },
  [47]: {
    name: "Xpla Testnet",
    gasPrice: 850 * 10 ** 9
  },
  [37]: {
    name: "Xpla Mainnet",
    gasPrice: 5100 * 10 ** 9
  },
  [199]: {
    name: "BitTorrent Chain",
    gasPrice: 300000 * 10 ** 9
  },
  [88882]: {
    name: "Spicy Chain",
    gasPrice: 2500 * 10 ** 9,
    gasLimit: 200000
  },
  [88888]: {
    name: "Chiliz Chain",
    gasPrice: 2500 * 10 ** 9,
    gasLimit: 200000
  }
};
function matchError(error) {
  const hasError = ERROR_SUBSTRINGS.some(substring => error.includes(substring));
  // can early exit if we find a match
  if (hasError) {
    return true;
  }
  const hasCompositeError = ERROR_SUBSTRINGS_COMPOSITE.some(arr => {
    return arr.some(substring => error.includes(substring));
  });
  return hasCompositeError;
}

/**
 * @internal
 */
const CREATE2_FACTORY_BYTECODE = "0x604580600e600039806000f350fe7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf3";
/**
 * @internal
 */
const SIGNATURE = {
  v: 27,
  r: "0x2222222222222222222222222222222222222222222222222222222222222222",
  s: "0x2222222222222222222222222222222222222222222222222222222222222222"
};
const COMMON_FACTORY = "0x4e59b44847b379578588920cA78FbF26c0B4956C"; // for pre-eip-155 supporting chains

/**
 * @internal
 */
const GAS_LIMIT_FOR_DEPLOYER = 5000000;
/**
 * @internal
 */
const DEPLOYER_BYTECODE = "0x60806040526040516107f33803806107f383398101604081905261002291610359565b805160005b818110156100c157828181518110610041576100416104c9565b6020026020010151600001516001600160a01b03163b600014156100af576100ad838281518110610074576100746104c9565b602002602001015160200151848381518110610092576100926104c9565b6020026020010151604001516100c960201b6100091760201c565b505b806100b9816104df565b915050610027565b505050610557565b606061011183836040518060400160405280601e81526020017f416464726573733a206c6f772d6c6576656c2063616c6c206661696c6564000081525061011860201b60201c565b9392505050565b6060610127848460008561012f565b949350505050565b6060824710156101955760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b60648201526084015b60405180910390fd5b6001600160a01b0385163b6101ec5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000604482015260640161018c565b600080866001600160a01b031685876040516102089190610508565b60006040518083038185875af1925050503d8060008114610245576040519150601f19603f3d011682016040523d82523d6000602084013e61024a565b606091505b50909250905061025b828286610266565b979650505050505050565b60608315610275575081610111565b8251156102855782518084602001fd5b8160405162461bcd60e51b815260040161018c9190610524565b634e487b7160e01b600052604160045260246000fd5b604051606081016001600160401b03811182821017156102d7576102d761029f565b60405290565b604051601f8201601f191681016001600160401b03811182821017156103055761030561029f565b604052919050565b80516001600160a01b038116811461032457600080fd5b919050565b60005b8381101561034457818101518382015260200161032c565b83811115610353576000848401525b50505050565b6000602080838503121561036c57600080fd5b82516001600160401b038082111561038357600080fd5b818501915085601f83011261039757600080fd5b8151818111156103a9576103a961029f565b8060051b6103b88582016102dd565b91825283810185019185810190898411156103d257600080fd5b86860192505b838310156104bc578251858111156103f05760008081fd5b86016060601f19828d0381018213156104095760008081fd5b6104116102b5565b61041c8b850161030d565b8152604061042b81860161030d565b828d01529284015192898411156104425760008081fd5b83850194508e603f86011261045957600093508384fd5b8b85015193508984111561046f5761046f61029f565b61047f8c84601f870116016102dd565b92508383528e818587010111156104965760008081fd5b6104a5848d8501838801610329565b8101919091528452505091860191908601906103d8565b9998505050505050505050565b634e487b7160e01b600052603260045260246000fd5b600060001982141561050157634e487b7160e01b600052601160045260246000fd5b5060010190565b6000825161051a818460208701610329565b9190910192915050565b6020815260008251806020840152610543816040850160208701610329565b601f01601f19169190910160400192915050565b61028d806105666000396000f3fe6080604052600080fd5b606061004b83836040518060400160405280601e81526020017f416464726573733a206c6f772d6c6576656c2063616c6c206661696c65640000815250610052565b9392505050565b60606100618484600085610069565b949350505050565b6060824710156100cf5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b60648201526084015b60405180910390fd5b6001600160a01b0385163b6101265760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016100c6565b600080866001600160a01b031685876040516101429190610208565b60006040518083038185875af1925050503d806000811461017f576040519150601f19603f3d011682016040523d82523d6000602084013e610184565b606091505b509150915061019482828661019f565b979650505050505050565b606083156101ae57508161004b565b8251156101be5782518084602001fd5b8160405162461bcd60e51b81526004016100c69190610224565b60005b838110156101f35781810151838201526020016101db565b83811115610202576000848401525b50505050565b6000825161021a8184602087016101d8565b9190910192915050565b60208152600082518060208401526102438160408501602087016101d8565b601f01601f1916919091016040019291505056fea26469706673582212200b524eb8ceaafe6c603273ee859fddbc2d6f1b7860c3d853dcf6f129f9d9371364736f6c634300080c0033";
/**
 * @internal
 */
const DEPLOYER_ABI = [{
  inputs: [{
    components: [{
      internalType: "address",
      name: "predictedAddress",
      type: "address"
    }, {
      internalType: "address",
      name: "to",
      type: "address"
    }, {
      internalType: "bytes",
      name: "data",
      type: "bytes"
    }],
    internalType: "struct IDeployer.Transaction[]",
    name: "transactions",
    type: "tuple[]"
  }],
  stateMutability: "payable",
  type: "constructor"
}];

/**
 * Check if a contract exists at the given address
 * @deploy
 * @public
 * @param address - The address to check
 * @param provider - The provider to use
 */
async function isContractDeployed(address, provider) {
  const code = await provider.getCode(address);
  return code !== "0x" && code !== "0x0";
}

/**
 * Check if a chain enforces EIP-155 transactions
 * Ref: https://eips.ethereum.org/EIPS/eip-155
 *
 * @internal
 * @param provider - The provider to use
 */
async function isEIP155Enforced(provider) {
  try {
    // TODO: Find a better way to check this.

    // Send a random transaction of legacy type (pre-eip-155).
    // It will fail. Parse the error message to check whether eip-155 is enforced.
    await provider.sendTransaction("0xf8a58085174876e800830186a08080b853604580600e600039806000f350fe7fffffffffffffffafffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf31ba02222222222222222222222222222222222222222222222222222222222222222a02222222222222222222222222222222222222222222222222222222222222222");
  } catch (e) {
    const errorMsg = e.toString().toLowerCase();
    const errorJson = JSON.stringify(e).toLowerCase();
    if (matchError(errorMsg) || matchError(errorJson)) {
      return true;
    }
    return false;
  }
  return false;
}

/**
 * Generate a transaction to be sent with a keyless signer.
 * @deploy
 * @public
 * @param transaction - Unsigned transaction object
 * @param signature - Signature bytes
 */
function getKeylessTxn(transaction, signature) {
  // 1. Create serialized txn string
  const digest = utils.arrayify(utils.keccak256(utils.serializeTransaction(transaction)));

  // 2. Determine signer address from custom signature + txn
  const signer = utils.recoverAddress(digest, signature);

  // 3. Create the signed serialized txn string.
  // To be sent directly to the chain using a provider.
  const signedSerializedTx = utils.serializeTransaction(transaction, signature);
  return {
    signer: signer,
    transaction: signedSerializedTx
  };
}

/**
 *
 * @internal
 * @param transaction - Unsigned transaction object
 * @param signature - Signature bytes
 */
function getCreate2FactoryDeploymentInfo(chainId, gasOptions) {
  const signature = utils.joinSignature(SIGNATURE);

  // 100000 is default deployment gas limit and 100 gwei is default gas price for create2 factory deployment
  // (See: https://github.com/Arachnid/deterministic-deployment-proxy?tab=readme-ov-file#deployment-gas-limit)
  const gasPrice = gasOptions.gasPrice ? gasOptions.gasPrice : 100 * 10 ** 9;
  const gasLimit = gasOptions.gasLimit ? gasOptions.gasLimit : 100000;
  const deploymentTransaction = getKeylessTxn({
    gasPrice,
    gasLimit,
    nonce: 0,
    data: CREATE2_FACTORY_BYTECODE,
    chainId: chainId
  }, signature);
  const create2FactoryAddress = utils.getContractAddress({
    from: deploymentTransaction.signer,
    nonce: 0
  });
  return {
    ...deploymentTransaction,
    deployment: create2FactoryAddress,
    valueToSend: BigNumber.from(gasPrice).mul(gasLimit)
  };
}

/**
 * Get the CREATE2 Factory address for a network
 * Source code of the factory:
 * https://github.com/Arachnid/deterministic-deployment-proxy/blob/master/source/deterministic-deployment-proxy.yul
 *
 * @internal
 * @param provider - The provider to use
 */
async function getCreate2FactoryAddress(provider) {
  const deploymentInfo = await computeCreate2FactoryTransaction(provider);
  return deploymentInfo.deployment;
}

/**
 * @internal
 */
async function computeCreate2FactoryTransaction(provider) {
  const networkId = (await provider.getNetwork()).chainId;

  // special handling for chains with hardcoded gasPrice and gasLimit
  if (CUSTOM_GAS_FOR_CHAIN[networkId]) {
    const enforceEip155 = await isEIP155Enforced(provider);
    const chainId = enforceEip155 ? networkId : 0;
    const gasPrice = CUSTOM_GAS_FOR_CHAIN[networkId]?.gasPrice;
    const gasLimit = CUSTOM_GAS_FOR_CHAIN[networkId]?.gasLimit;
    const deploymentInfo = getCreate2FactoryDeploymentInfo(chainId, {
      gasPrice: gasPrice ? BigNumber.from(gasPrice) : undefined,
      gasLimit: gasLimit ? BigNumber.from(gasLimit) : undefined
    });
    if (await isContractDeployed(deploymentInfo.deployment, provider)) {
      deploymentInfo.transaction = "";
    }
    return deploymentInfo;
  }

  // default flow
  const allBinsInfo = [...CUSTOM_GAS_BINS.map(b =>
  // to generate EIP-155 transaction
  getCreate2FactoryDeploymentInfo(networkId, {
    gasPrice: BigNumber.from(b)
  })),
  // to generate pre-EIP-155 transaction, hence chainId 0
  ...CUSTOM_GAS_BINS.map(b => getCreate2FactoryDeploymentInfo(0, {
    gasPrice: BigNumber.from(b)
  }))];
  const allFactories = await Promise.all(allBinsInfo.map(b => isContractDeployed(b.deployment, provider)));
  const indexOfCommonFactory = allBinsInfo.findIndex(b => b.deployment === COMMON_FACTORY);
  if (indexOfCommonFactory && allFactories[indexOfCommonFactory]) {
    return {
      ...allBinsInfo[indexOfCommonFactory],
      transaction: ""
    };
  }
  const indexOfExistingDeployment = allFactories.findIndex(b => b);
  if (indexOfExistingDeployment && allBinsInfo[indexOfExistingDeployment]) {
    return {
      ...allBinsInfo[indexOfExistingDeployment],
      transaction: ""
    };
  }
  const [enforceEip155, gasPriceFetched] = await Promise.all([isEIP155Enforced(provider), provider.getGasPrice()]);
  const chainId = enforceEip155 ? networkId : 0;
  const bin = _getNearestGasPriceBin(gasPriceFetched);
  return getCreate2FactoryDeploymentInfo(chainId, {
    gasPrice: bin
  });
}
function _getNearestGasPriceBin(gasPrice) {
  const bin = CUSTOM_GAS_BINS.find(e => BigNumber.from(e).gte(gasPrice));
  return bin ? BigNumber.from(bin) : gasPrice;
}

const bytecode = "0x60606040526040805190810160405280600d81526020017f57726170706564204574686572000000000000000000000000000000000000008152506000908051906020019061004f9291906100c8565b506040805190810160405280600481526020017f57455448000000000000000000000000000000000000000000000000000000008152506001908051906020019061009b9291906100c8565b506012600260006101000a81548160ff021916908360ff16021790555034156100c357600080fd5b61016d565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061010957805160ff1916838001178555610137565b82800160010185558215610137579182015b8281111561013657825182559160200191906001019061011b565b5b5090506101449190610148565b5090565b61016a91905b8082111561016657600081600090555060010161014e565b5090565b90565b610c348061017c6000396000f3006060604052600436106100af576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806306fdde03146100b9578063095ea7b31461014757806318160ddd146101a157806323b872dd146101ca5780632e1a7d4d14610243578063313ce5671461026657806370a082311461029557806395d89b41146102e2578063a9059cbb14610370578063d0e30db0146103ca578063dd62ed3e146103d4575b6100b7610440565b005b34156100c457600080fd5b6100cc6104dd565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561010c5780820151818401526020810190506100f1565b50505050905090810190601f1680156101395780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561015257600080fd5b610187600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803590602001909190505061057b565b604051808215151515815260200191505060405180910390f35b34156101ac57600080fd5b6101b461066d565b6040518082815260200191505060405180910390f35b34156101d557600080fd5b610229600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803590602001909190505061068c565b604051808215151515815260200191505060405180910390f35b341561024e57600080fd5b61026460048080359060200190919050506109d9565b005b341561027157600080fd5b610279610b05565b604051808260ff1660ff16815260200191505060405180910390f35b34156102a057600080fd5b6102cc600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610b18565b6040518082815260200191505060405180910390f35b34156102ed57600080fd5b6102f5610b30565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561033557808201518184015260208101905061031a565b50505050905090810190601f1680156103625780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561037b57600080fd5b6103b0600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091908035906020019091905050610bce565b604051808215151515815260200191505060405180910390f35b6103d2610440565b005b34156103df57600080fd5b61042a600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610be3565b6040518082815260200191505060405180910390f35b34600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055503373ffffffffffffffffffffffffffffffffffffffff167fe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c346040518082815260200191505060405180910390a2565b60008054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156105735780601f1061054857610100808354040283529160200191610573565b820191906000526020600020905b81548152906001019060200180831161055657829003601f168201915b505050505081565b600081600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925846040518082815260200191505060405180910390a36001905092915050565b60003073ffffffffffffffffffffffffffffffffffffffff1631905090565b600081600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054101515156106dc57600080fd5b3373ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff16141580156107b457507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205414155b156108cf5781600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541015151561084457600080fd5b81600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825403925050819055505b81600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254039250508190555081600360008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a3600190509392505050565b80600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205410151515610a2757600080fd5b80600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825403925050819055503373ffffffffffffffffffffffffffffffffffffffff166108fc829081150290604051600060405180830381858888f193505050501515610ab457600080fd5b3373ffffffffffffffffffffffffffffffffffffffff167f7fcf532c15f0a6db0bd6d0e038bea71d30d808c7d98cb3bf7268a95bf5081b65826040518082815260200191505060405180910390a250565b600260009054906101000a900460ff1681565b60036020528060005260406000206000915090505481565b60018054600181600116156101000203166002900480601f016020809104026020016040519081016040528092919081815260200182805460018160011615610100020316600290048015610bc65780601f10610b9b57610100808354040283529160200191610bc6565b820191906000526020600020905b815481529060010190602001808311610ba957829003601f168201915b505050505081565b6000610bdb33848461068c565b905092915050565b60046020528160005260406000206020528060005260406000206000915091505054815600a165627a7a72305820deb4c2ccab3c2fdca32ab3f46728389c2fe2c165d5fafa07661e4e004f6c344a0029";

/**
 * Generate salt for deployment with Create2
 * Note: Salt component is generated by appending `tw` (thirdweb) to the bytecode
 *
 * @internal
 * @param bytecode - Creation bytecode of the contract to deploy
 */
function getSaltHash(bytecode) {
  const bytecodePrefixed = bytecode.startsWith("0x") ? bytecode : `0x${bytecode}`;
  const bytecodeHash = utils.id(bytecodePrefixed);
  const salt = `tw.${bytecodeHash}`;
  const saltHash = utils.id(salt);
  return saltHash;
}

/**
 *
 * Construct init-bytecode, packed with salthash.
 * This hex data is intended to be sent to the CREATE2 factory address
 *
 * @internal
 * @param bytecode - Creation bytecode of the contract to deploy
 * @param encodedArgs - Abi-encoded constructor params
 */
function getInitBytecodeWithSalt(bytecode, encodedArgs, salt) {
  const bytecodePrefixed = bytecode.startsWith("0x") ? bytecode : `0x${bytecode}`;
  const saltHash = salt ? utils.id(salt) : getSaltHash(bytecodePrefixed);
  const initBytecodeWithSalt = utils.solidityPack(["bytes32", "bytes", "bytes"], [saltHash, bytecodePrefixed, encodedArgs]);
  return initBytecodeWithSalt;
}

/**
 * Pre-compute a contract's deployment address for a CREATE2 deployment.
 *
 * @internal
 * @param bytecode - Creation bytecode of the contract to deploy
 * @param encodedArgs - Abi-encoded constructor params
 * @param create2FactoryAddress - The create2 factory address to use
 */
function computeDeploymentAddress(bytecode, encodedArgs, create2FactoryAddress, salt) {
  const bytecodePrefixed = bytecode.startsWith("0x") ? bytecode : `0x${bytecode}`;
  const saltHash = salt ? utils.id(salt) : getSaltHash(bytecodePrefixed);

  // 1. create init bytecode hash with contract's bytecode and encoded args
  const initBytecode = utils.solidityPack(["bytes", "bytes"], [bytecodePrefixed, encodedArgs]);

  // 2. abi-encode pack the deployer address, salt, and bytecode hash
  const deployInfoPacked = utils.solidityPack(["bytes1", "address", "bytes32", "bytes32"], ["0xff", create2FactoryAddress, saltHash, utils.solidityKeccak256(["bytes"], [initBytecode])]);

  // 3. hash the packed deploy info
  const hashedDeployInfo = utils.solidityKeccak256(["bytes"], [deployInfoPacked]);

  // 4. return last 20 bytes (40 characters) of the hash -- this is the predicted address
  return `0x${hashedDeployInfo.slice(26)}`;
}

/**
 * @public
 */
let ChainId = /*#__PURE__*/function (ChainId) {
  ChainId[ChainId["Mainnet"] = 1] = "Mainnet";
  ChainId[ChainId["Goerli"] = 5] = "Goerli";
  ChainId[ChainId["Polygon"] = 137] = "Polygon";
  ChainId[ChainId["Mumbai"] = 80001] = "Mumbai";
  ChainId[ChainId["Localhost"] = 1337] = "Localhost";
  ChainId[ChainId["Hardhat"] = 31337] = "Hardhat";
  ChainId[ChainId["Fantom"] = 250] = "Fantom";
  ChainId[ChainId["FantomTestnet"] = 4002] = "FantomTestnet";
  ChainId[ChainId["Avalanche"] = 43114] = "Avalanche";
  ChainId[ChainId["AvalancheFujiTestnet"] = 43113] = "AvalancheFujiTestnet";
  ChainId[ChainId["Optimism"] = 10] = "Optimism";
  ChainId[ChainId["OptimismGoerli"] = 420] = "OptimismGoerli";
  ChainId[ChainId["Arbitrum"] = 42161] = "Arbitrum";
  ChainId[ChainId["ArbitrumGoerli"] = 421613] = "ArbitrumGoerli";
  ChainId[ChainId["BinanceSmartChainMainnet"] = 56] = "BinanceSmartChainMainnet";
  ChainId[ChainId["BinanceSmartChainTestnet"] = 97] = "BinanceSmartChainTestnet";
  return ChainId;
}({});

/**
 * @public
 */
const NATIVE_TOKEN_ADDRESS = "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee";

/**
 * @public
 */
const NATIVE_TOKENS = {
  [ChainId.Mainnet]: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.Goerli]: {
    name: "Grli Ether",
    symbol: "GOR",
    decimals: 18,
    wrapped: {
      address: "0xb4fbf271143f4fbf7b91a5ded31805e42b2208d6",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  11155111: {
    name: "Sepolia Ether",
    symbol: "SEP",
    decimals: 18,
    wrapped: {
      address: "0x7b79995e5f793A07Bc00c21412e50Ecae098E7f9",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.Polygon]: {
    name: "Matic",
    symbol: "MATIC",
    decimals: 18,
    wrapped: {
      address: "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270",
      name: "Wrapped Matic",
      symbol: "WMATIC"
    }
  },
  [ChainId.Mumbai]: {
    name: "Matic",
    symbol: "MATIC",
    decimals: 18,
    wrapped: {
      address: "0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889",
      name: "Wrapped Matic",
      symbol: "WMATIC"
    }
  },
  [ChainId.Avalanche]: {
    name: "Avalanche",
    symbol: "AVAX",
    decimals: 18,
    wrapped: {
      address: "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7",
      name: "Wrapped AVAX",
      symbol: "WAVAX"
    }
  },
  [ChainId.AvalancheFujiTestnet]: {
    name: "Avalanche",
    symbol: "AVAX",
    decimals: 18,
    wrapped: {
      address: "0xd00ae08403B9bbb9124bB305C09058E32C39A48c",
      name: "Wrapped AVAX",
      symbol: "WAVAX"
    }
  },
  [ChainId.Fantom]: {
    name: "Fantom",
    symbol: "FTM",
    decimals: 18,
    wrapped: {
      address: "0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83",
      name: "Wrapped Fantom",
      symbol: "WFTM"
    }
  },
  [ChainId.FantomTestnet]: {
    name: "Fantom",
    symbol: "FTM",
    decimals: 18,
    wrapped: {
      address: "0xf1277d1Ed8AD466beddF92ef448A132661956621",
      name: "Wrapped Fantom",
      symbol: "WFTM"
    }
  },
  [ChainId.Arbitrum]: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x82af49447d8a07e3bd95bd0d56f35241523fbab1",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.ArbitrumGoerli]: {
    name: "Arbitrum Goerli Ether",
    symbol: "AGOR",
    decimals: 18,
    wrapped: {
      address: "0xe39Ab88f8A4777030A534146A9Ca3B52bd5D43A3",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.Optimism]: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x4200000000000000000000000000000000000006",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.OptimismGoerli]: {
    name: "Goerli Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x4200000000000000000000000000000000000006",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.BinanceSmartChainMainnet]: {
    name: "Binance Chain Native Token",
    symbol: "BNB",
    decimals: 18,
    wrapped: {
      address: "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
      name: "Wrapped Binance Chain Token",
      symbol: "WBNB"
    }
  },
  [ChainId.BinanceSmartChainTestnet]: {
    name: "Binance Chain Native Token",
    symbol: "TBNB",
    decimals: 18,
    wrapped: {
      address: "0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd",
      name: "Wrapped Binance Chain Testnet Token",
      symbol: "WBNB"
    }
  },
  [ChainId.Hardhat]: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x5FbDB2315678afecb367f032d93F642f64180aa3",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.Localhost]: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x5FbDB2315678afecb367f032d93F642f64180aa3",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  84531: {
    name: "Base Goerli Testnet",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x4200000000000000000000000000000000000006",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  // eslint-disable-next-line no-useless-computed-key
  [280]: {
    name: "zkSync Era Testnet",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x5AEa5775959fBC2557Cc8789bC1bf90A239D9a91",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  }
};

/**
 * Returns the native token for a given chain
 * @param chainId - the chain id
 * @public
 */
function getNativeTokenByChainId(chainId) {
  const chain = getSupportedChains().find(c => c.chainId === chainId);
  if (chain && chain.nativeCurrency) {
    return {
      name: chain.nativeCurrency.name,
      symbol: chain.nativeCurrency.symbol,
      decimals: 18,
      wrapped: {
        address: constants.AddressZero,
        name: `Wrapped ${chain.nativeCurrency.name}`,
        symbol: `W${chain.nativeCurrency.symbol}`
      }
    };
  }
  return NATIVE_TOKENS[chainId] || {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: constants.AddressZero,
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  };
}
const LINK_TOKEN_ADDRESS = {
  [ChainId.Mainnet]: "0x514910771AF9Ca656af840dff83E8264EcF986CA",
  [ChainId.Goerli]: "0x326C977E6efc84E512bB9C30f76E30c160eD06FB",
  [ChainId.BinanceSmartChainMainnet]: "0x404460C6A5EdE2D891e8297795264fDe62ADBB75",
  [ChainId.Polygon]: "0xb0897686c545045aFc77CF20eC7A532E3120E0F1",
  [ChainId.Mumbai]: "0x326C977E6efc84E512bB9C30f76E30c160eD06FB",
  [ChainId.Avalanche]: "0x5947BB275c521040051D82396192181b413227A3",
  [ChainId.AvalancheFujiTestnet]: "0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846",
  [ChainId.Fantom]: "0x6F43FF82CCA38001B6699a8AC47A2d0E66939407",
  [ChainId.FantomTestnet]: "0xfaFedb041c0DD4fA2Dc0d87a6B0979Ee6FA7af5F"
};

/**
 *
 * @param abi - The abi to extract constructor params from
 * @returns
 * @internal
 */
function extractConstructorParamsFromAbi(abi) {
  const parsedAbi = AbiSchema.parse(abi || []);
  for (const input of parsedAbi) {
    if (input.type === "constructor") {
      return input.inputs || [];
    }
  }
  return [];
}

const caches = {
  deploymentPresets: {}
};

/**
 * Returns the RoyaltyEngineV1 address for a given chain
 * @param chainId - the chain id
 * @public
 */
function getRoyaltyEngineV1ByChainId(chainId) {
  return ROYALTY_ENGINE_V1_ADDRESS[chainId] || constants.AddressZero;
}
const ROYALTY_ENGINE_V1_ADDRESS = {
  [ChainId.Mainnet]: "0x0385603ab55642cb4dd5de3ae9e306809991804f",
  [ChainId.Goerli]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
  [ChainId.BinanceSmartChainMainnet]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
  [ChainId.Polygon]: "0x28EdFcF0Be7E86b07493466e7631a213bDe8eEF2",
  [ChainId.Mumbai]: "0x0a01E11887f727D1b1Cd81251eeEE9BEE4262D07",
  [ChainId.Avalanche]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
  [ChainId.Optimism]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
  [ChainId.Arbitrum]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15"
};

const AddressZero = "0x0000000000000000000000000000000000000000";

/**
 * @internal
 */
async function computeDeploymentInfo(contractType, provider, storage, create2Factory, contractOptions, clientId, secretKey) {
  const contractName = contractOptions && contractOptions.contractName;
  const version = contractOptions && contractOptions.version;
  let publisherAddress = contractOptions && contractOptions.publisherAddress;
  let metadata = contractOptions && contractOptions.metadata;
  invariant(contractName || metadata, "Require contract name or metadata");
  if (contractName && caches.deploymentPresets[contractName]) {
    return caches.deploymentPresets[contractName];
  }

  // Different treatment for WETH contract
  if (contractName === "WETH9") {
    const address = computeDeploymentAddress(bytecode, [], create2Factory);
    const contractDeployed = await isContractDeployed(address, provider);
    let initBytecodeWithSalt = "";
    if (!contractDeployed) {
      initBytecodeWithSalt = getInitBytecodeWithSalt(bytecode, []);
    }
    return {
      name: contractName,
      type: contractType,
      transaction: {
        predictedAddress: address,
        to: create2Factory,
        data: initBytecodeWithSalt
      }
    };
  }
  if (!metadata) {
    invariant(contractName, "Require contract name");
    if (!publisherAddress) {
      publisherAddress = THIRDWEB_DEPLOYER;
    }
    const publishedContract = await fetchPublishedContractFromPolygon(publisherAddress, contractName, version, storage, clientId, secretKey);
    metadata = (await fetchAndCacheDeployMetadata(publishedContract.metadataUri, storage)).compilerMetadata;
  }
  const encodedArgs = await encodeConstructorParamsForImplementation(metadata, provider, storage, create2Factory, contractOptions?.constructorParams, clientId, secretKey);
  const address = computeDeploymentAddress(metadata.bytecode, encodedArgs, create2Factory);
  const contractDeployed = await isContractDeployed(address, provider);
  let initBytecodeWithSalt = "";
  if (!contractDeployed) {
    initBytecodeWithSalt = getInitBytecodeWithSalt(metadata.bytecode, encodedArgs);
  }
  return {
    name: contractName,
    type: contractType,
    transaction: {
      predictedAddress: address,
      to: create2Factory,
      data: initBytecodeWithSalt
    },
    encodedArgs
  };
}

/**
 * @internal
 *
 * Determine constructor params required by an implementation contract.
 * Return abi-encoded params.
 */
async function encodeConstructorParamsForImplementation(compilerMetadata, provider, storage, create2Factory, constructorParamMap, clientId, secretKey) {
  const constructorParams = extractConstructorParamsFromAbi(compilerMetadata.abi);
  const constructorParamTypes = constructorParams.map(p => {
    if (p.type === "tuple[]" || p.type === "tuple") {
      return utils.ParamType.from(p);
    } else {
      return p.type;
    }
  });
  const constructorParamValues = await Promise.all(constructorParams.map(async p => {
    if (constructorParamMap && constructorParamMap[p.name]) {
      if (constructorParamMap[p.name].type) {
        invariant(constructorParamMap[p.name].type === p.type, `Provided type ${constructorParamMap[p.name].type} doesn't match the actual type ${p.type} from Abi`);
      }
      return constructorParamMap[p.name].value;
    }
    if (p.name && p.name.includes("nativeTokenWrapper")) {
      return await nativeTokenInputArg(provider, storage, create2Factory, clientId, secretKey);
    } else if (p.name && p.name.includes("trustedForwarder")) {
      if (compilerMetadata.name === "Pack") {
        return AddressZero;
      }
      const deploymentInfo = await computeDeploymentInfo("infra", provider, storage, create2Factory, {
        contractName: "Forwarder"
      }, clientId, secretKey);
      if (!caches.deploymentPresets["Forwarder"]) {
        caches.deploymentPresets["Forwarder"] = deploymentInfo;
      }
      return deploymentInfo.transaction.predictedAddress;
    } else if (p.name && p.name.includes("royaltyEngineAddress")) {
      const chainId = (await provider.getNetwork()).chainId;
      return getRoyaltyEngineV1ByChainId(chainId);
    } else if (p.name && p.name.includes("marketplaceV3Params")) {
      const chainId = (await provider.getNetwork()).chainId;
      const royaltyEngineAddress = getRoyaltyEngineV1ByChainId(chainId);
      const nativeTokenWrapper = await nativeTokenInputArg(provider, storage, create2Factory, clientId, secretKey);
      const extensions = constructorParamMap ? constructorParamMap["_extensions"].value : [];
      return {
        extensions: extensions,
        royaltyEngineAddress: royaltyEngineAddress,
        nativeTokenWrapper: nativeTokenWrapper
      };
    } else {
      throw new Error("Can't resolve constructor arguments");
    }
  }));
  const encodedArgs = utils.defaultAbiCoder.encode(constructorParamTypes, constructorParamValues);
  return encodedArgs;
}
async function nativeTokenInputArg(provider, storage, create2Factory, clientId, secretKey) {
  const chainId = (await provider.getNetwork()).chainId;
  let nativeTokenWrapperAddress = getNativeTokenByChainId(chainId).wrapped.address;
  if (nativeTokenWrapperAddress === constants.AddressZero) {
    const deploymentInfo = await computeDeploymentInfo("infra", provider, storage, create2Factory, {
      contractName: "WETH9"
    }, clientId, secretKey);
    if (!caches.deploymentPresets["WETH9"]) {
      caches.deploymentPresets["WETH9"] = deploymentInfo;
    }
    nativeTokenWrapperAddress = deploymentInfo.transaction.predictedAddress;
  }
  return nativeTokenWrapperAddress;
}

/**
 *
 * @internal
 * @param provider - The provider to use
 * @param storage - The storage to use
 * @param create2Factory - The create2 factory to use
 */
async function computeEOAForwarderAddress(provider, storage, create2Factory, clientId, secretKey) {
  if (!create2Factory || create2Factory === "") {
    create2Factory = await getCreate2FactoryAddress(provider);
  }
  return (await computeDeploymentInfo("infra", provider, storage, create2Factory, {
    contractName: "ForwarderEOAOnly"
  }, clientId, secretKey)).transaction.predictedAddress;
}

/**
 *
 * @internal
 * @param provider - The provider to use
 * @param storage - The storage to use
 * @param create2Factory - The create2 factory to use
 */
async function computeForwarderAddress(provider, storage, create2Factory, clientId, secretKey) {
  if (!create2Factory || create2Factory === "") {
    create2Factory = await getCreate2FactoryAddress(provider);
  }
  return (await computeDeploymentInfo("infra", provider, storage, create2Factory, {
    contractName: "Forwarder"
  }, clientId, secretKey)).transaction.predictedAddress;
}

/**
 * Error that may get thrown if IPFS returns nothing for a given uri.
 * @internal
 */
class NotFoundError extends Error {
  /** @internal */
  constructor(identifier) {
    super(identifier ? `Object with id ${identifier} NOT FOUND` : "NOT_FOUND");
  }
}

/**
 * Error that may get thrown if an invalid address was passed
 * @internal
 */
class InvalidAddressError extends Error {
  /** @internal */
  constructor(address) {
    super(address ? `'${address}' is an invalid address` : "Invalid address passed");
  }
}

/**
 * @internal
 */
class MissingRoleError extends Error {
  /** @internal */
  /** @internal */
  constructor(address, role) {
    super(`MISSING ROLE: ${address} does not have the '${role}' role`);
  }
}

/**
 * @internal
 */
class AssetNotFoundError extends Error {
  /** @internal */
  /** @internal */
  constructor() {
    let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "The asset you're trying to use could not be found.";
    super(`message: ${message}`);
  }
}

/**
 * @internal
 */
class UploadError extends Error {
  /** @internal */
  constructor(message) {
    super(`UPLOAD_FAILED: ${message}`);
  }
}

/**
 * @internal
 */
class FileNameMissingError extends Error {
  /** @internal */
  constructor() {
    super("File name is required when object is not a `File` type object.");
  }
}

/**
 * @internal
 */
class DuplicateFileNameError extends Error {
  /** @internal */
  constructor(fileName) {
    super(`DUPLICATE_FILE_NAME_ERROR: File name ${fileName} was passed for more than one file.`);
  }
}

/**
 * @internal
 */
class NotEnoughTokensError extends Error {
  /** @internal */
  constructor(contractAddress, quantity, available) {
    super(`BALANCE ERROR: you do not have enough balance on contract ${contractAddress} to use ${quantity} tokens. You have ${available} tokens available.`);
  }
}

/**
 * @internal
 */
class MissingOwnerRoleError extends Error {
  /** @internal */
  constructor() {
    super(`LIST ERROR: you should be the owner of the token to list it.`);
  }
}

/**
 * @internal
 */
class QuantityAboveLimitError extends Error {
  /** @internal */
  constructor(quantity) {
    super(`BUY ERROR: You cannot buy more than ${quantity} tokens`);
  }
}

/**
 * Thrown when data fails to fetch from storage.
 * @internal
 */
class FetchError extends Error {
  /** @internal */
  constructor(message, innerError) {
    super(`FETCH_FAILED: ${message}`);
    this.innerError = innerError;
  }
}

/**
 * Thrown when attempting to create a snapshot with duplicate leafs
 * @internal
 */
class DuplicateLeafsError extends Error {
  constructor(message) {
    super(`DUPLICATE_LEAFS${message ? ` : ${message}` : ""}`);
  }
}

/**
 * Thrown when attempting to update/cancel an auction that already started
 * @internal
 */
class AuctionAlreadyStartedError extends Error {
  constructor(id) {
    super(`Auction already started with existing bid${id ? `, id: ${id}` : ""}`);
  }
}

/**
 * @internal
 */
class FunctionDeprecatedError extends Error {
  /** @internal */
  constructor(message) {
    super(`FUNCTION DEPRECATED. ${message ? `Use ${message} instead` : ""}`);
  }
}

/**
 * Thrown when trying to retrieve a listing from a marketplace that doesn't exist
 * @internal
 */
class ListingNotFoundError extends Error {
  constructor(marketplaceContractAddress, listingId) {
    super(`Could not find listing.${marketplaceContractAddress ? ` marketplace address: ${marketplaceContractAddress}` : ""}${listingId ? ` listing id: ${listingId}` : ""}`);
  }
}

/**
 * Thrown when trying to retrieve a listing of the wrong type
 * @internal
 */
class WrongListingTypeError extends Error {
  constructor(marketplaceContractAddress, listingId, actualType, expectedType) {
    super(`Incorrect listing type. Are you sure you're using the right method?.${marketplaceContractAddress ? ` marketplace address: ${marketplaceContractAddress}` : ""}${listingId ? ` listing id: ${listingId}` : ""}${expectedType ? ` expected type: ${expectedType}` : ""}${actualType ? ` actual type: ${actualType}` : ""}`);
  }
}

/**
 * Thrown when attempting to transfer an asset that has restricted transferability
 * @internal
 */
class RestrictedTransferError extends Error {
  constructor(assetAddress) {
    super(`Failed to transfer asset, transfer is restricted.${assetAddress ? ` Address : ${assetAddress}` : ""}`);
  }
}

/**
 * Thrown when attempting to execute an admin-role function.
 * @internal
 */
class AdminRoleMissingError extends Error {
  constructor(address, contractAddress) {
    let message = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "Failed to execute transaction";
    super(`${message}, admin role is missing${address ? ` on address: ${address}` : ""}${contractAddress ? ` on contract: ${contractAddress}` : ""}`);
  }
}

/**
 * Thrown when attempting to close an auction that has not ended
 * @internal
 */
class AuctionHasNotEndedError extends Error {
  constructor(id, endTime) {
    super(`Auction has not ended yet${id ? `, id: ${id}` : ""}${endTime ? `, end time: ${endTime.toString()}` : ""}`);
  }
}

/**
 * Thrown when attempting to call a contract function that is not implemented
 * @internal
 */
class ExtensionNotImplementedError extends Error {
  constructor(feature) {
    super(`This functionality is not available because the contract does not implement the '${feature.name}' Extension. Learn how to unlock this functionality at https://portal.thirdweb.com/contracts/build/extensions `);
  }
}

/**
 * @internal
 */

/**
 * @public
 */
class TransactionError extends Error {
  constructor(info, raw) {
    let errorMessage = `\n\n\n\n TRANSACTION ERROR \n\n\n`;
    errorMessage += `Reason: ${info.reason}`;
    errorMessage += `\n\n\n\n TRANSACTION INFORMATION \n\n`;
    errorMessage += withSpaces("from", info.from);
    if (info.to) {
      errorMessage += withSpaces("to", info.contractName ? `${info.to} (${info.contractName})` : info.to);
    }
    errorMessage += withSpaces(`chain`, `${info.network.name} (${info.network.chainId})`);
    if (info.rpcUrl) {
      try {
        const url = new URL(info.rpcUrl);
        errorMessage += withSpaces(`rpc`, url.hostname);
      } catch (e2) {
        // ignore if can't parse URL
      }
    }
    if (info.hash) {
      errorMessage += withSpaces(`tx hash`, info.hash);
    }
    if (info.value && info.value.gt(0)) {
      errorMessage += withSpaces("value", `${utils.formatEther(info.value)} ${NATIVE_TOKENS[info.network.chainId]?.symbol || ""}`);
    }
    errorMessage += withSpaces(`data`, `${info.data}`);
    if (info.method) {
      errorMessage += withSpaces("method", info.method);
    }
    if (info.sources) {
      const revertFile = info.sources.find(file => file.source.includes(info.reason));
      if (revertFile) {
        const lines = revertFile.source.split("\n").map((line, index) => `${index + 1}  ${line}`);
        const revertLine = lines.findIndex(line => line.includes(info.reason));
        lines[revertLine] += "   <-- REVERT";
        const errorLines = lines.slice(revertLine - 8, revertLine + 4);
        errorMessage += `\n\n\n\n SOLIDITY STACK TRACE \n\n\n`;
        errorMessage += `File: ${revertFile.filename.replace("node_modules/", "")}\n\n`;
        errorMessage += errorLines.join("\n");
      }
    }
    errorMessage += `\n\n\n\n DEBUGGING RESOURCES \n\n\n`;
    errorMessage += `Need helping debugging? Visit our support site: https://thirdweb.com/support`;
    errorMessage += `\n\n`;
    super(errorMessage);
    this._reason = info.reason;
    this._info = info;
    this._raw = raw;
  }

  // Keep reason here for backwards compatibility
  get reason() {
    return this._reason;
  }
  get raw() {
    return this._raw;
  }
  get info() {
    return this._info;
  }
}

/**
 * @internal
 */
function parseRevertReason(error) {
  if (error.reason && !error.reason.includes("cannot estimate gas")) {
    return error.reason;
  }
  if (error.error) {
    return error.error;
  }

  // I think this code path should never be hit, but just in case

  let errorString = error;
  if (typeof error === "object") {
    // MetaMask errors come as objects so parse them first
    errorString = JSON.stringify(error);
  } else if (typeof error !== "string") {
    errorString = error.toString();
  }

  // if the error is just too long, just return the message to limit Regexp processing time
  // see: https://cwe.mitre.org/data/definitions/1333.html
  if (errorString.length > 5000) {
    return error.message || "";
  }
  return parseMessageParts(/.*?"message":"([^"\\]*).*?/, errorString) || parseMessageParts(/.*?"reason":"([^"\\]*).*?/, errorString) || error.message || "";
}
function withSpaces(label, content) {
  if (content === "") {
    return content;
  }
  const spaces = Array(10 - label.length).fill(" ").join("");
  if (content.includes("\n")) {
    content = "\n\n  " + content.split("\n").join(`\n  `);
  } else {
    content = `${spaces}${content}`;
  }
  return `\n${label}:${content}`;
}
function parseMessageParts(regex, raw) {
  const msgMatches = raw.match(regex) || [];
  let extracted = "";
  if (msgMatches?.length > 0) {
    extracted += msgMatches[1];
  }
  return extracted;
}

/**
 * @internal
 * @param err - The error to check
 * @param message - The message to check for
 */
function includesErrorMessage(err, message) {
  if (!err) {
    return false;
  }
  return err && err.toString().includes(message) || err && err.message && err.message.toString().includes(message) || err && err.error && err.error.toString().includes(message);
}

/**
 * @internal
 * @param publishedMetadata - The published metadata to fetch the sources for
 * @param storage - The storage to use
 */

async function fetchSourceFilesFromMetadata(publishedMetadata, storage) {
  return await Promise.all(Object.entries(publishedMetadata.metadata.sources).map(async _ref => {
    let [path, info] = _ref;
    const urls = info.urls;
    const ipfsLink = urls ? urls.find(url => url.includes("ipfs")) : undefined;
    if (ipfsLink) {
      const ipfsHash = ipfsLink.split("ipfs/")[1];
      // 3 sec timeout for sources that haven't been uploaded to ipfs
      const timeout = new Promise((_r, rej) => setTimeout(() => rej("timeout"), 3000));
      const source = await Promise.race([(await storage.download(`ipfs://${ipfsHash}`)).text(), timeout]);
      return {
        filename: path,
        source
      };
    } else {
      return {
        filename: path,
        source: info.content || "Could not find source for this contract"
      };
    }
  }));
}

/**
 * @internal
 */
const ForwardRequest = [{
  name: "from",
  type: "address"
}, {
  name: "to",
  type: "address"
}, {
  name: "value",
  type: "uint256"
}, {
  name: "gas",
  type: "uint256"
}, {
  name: "nonce",
  type: "uint256"
}, {
  name: "data",
  type: "bytes"
}];
const ChainAwareForwardRequest = [{
  name: "from",
  type: "address"
}, {
  name: "to",
  type: "address"
}, {
  name: "value",
  type: "uint256"
}, {
  name: "gas",
  type: "uint256"
}, {
  name: "nonce",
  type: "uint256"
}, {
  name: "data",
  type: "bytes"
}, {
  name: "chainid",
  type: "uint256"
}];

/**
 * @internal
 */
const BiconomyForwarderAbi = [{
  inputs: [{
    internalType: "address",
    name: "from",
    type: "address"
  }, {
    internalType: "uint256",
    name: "batchId",
    type: "uint256"
  }],
  name: "getNonce",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}];
const _nonces = {};
const _noncesSyncTimestamp = {};

/**
 * @internal
 */
async function getAndIncrementNonce(forwarder, forwarderFunction, forwarderArgs) {
  // address is only used for internal caching :)
  const address = forwarderArgs.join("|");
  const timestamp = _noncesSyncTimestamp[address];
  // if it's within 2 seconds we're optimistically increment the nonce
  // should we always sync?
  const shouldSync = Date.now() - timestamp >= 2000;
  if (!(address in _nonces) || shouldSync) {
    const nonceResult = await forwarder.functions[forwarderFunction](...forwarderArgs);
    if (Array.isArray(nonceResult) && nonceResult.length > 0) {
      _nonces[address] = BigNumber.from(nonceResult[0]);
    } else {
      _nonces[address] = BigNumber.from(nonceResult);
    }
    _noncesSyncTimestamp[address] = Date.now();
  }
  const nonce = _nonces[address];
  _nonces[address] = BigNumber.from(_nonces[address]).add(1);
  return nonce;
}

async function getDefaultGasOverrides(provider) {
  // handle smart wallet provider
  if (provider.originalProvider) {
    provider = provider.originalProvider;
  }
  const feeData = await getDynamicFeeData(provider);
  if (feeData.maxFeePerGas && feeData.maxPriorityFeePerGas) {
    return {
      maxFeePerGas: feeData.maxFeePerGas,
      maxPriorityFeePerGas: feeData.maxPriorityFeePerGas
    };
  } else {
    return {
      gasPrice: await getGasPrice(provider)
    };
  }
}
async function getDynamicFeeData(provider) {
  let maxFeePerGas = null;
  let maxPriorityFeePerGas = null;
  const [{
    chainId
  }, block, eth_maxPriorityFeePerGas] = await Promise.all([provider.getNetwork(), provider.getBlock("latest"), provider.send("eth_maxPriorityFeePerGas", []).catch(() => null)]);
  const baseBlockFee = block && block.baseFeePerGas ? block.baseFeePerGas : utils.parseUnits("100", "wei");

  // flag-chain overrides
  if (chainId === Flag.chainId || chainId === FlagTestnet.chainId) {
    // chains does not support eip-1559, return null for all
    return {
      maxFeePerGas: null,
      maxPriorityFeePerGas: null,
      baseFee: null
    };
  } else if (chainId === Mumbai.chainId || chainId === Polygon.chainId) {
    // for polygon, get fee data from gas station
    maxPriorityFeePerGas = await getPolygonGasPriorityFee(chainId);
  } else if (eth_maxPriorityFeePerGas) {
    // prioritize fee from eth_maxPriorityFeePerGas
    maxPriorityFeePerGas = BigNumber.from(eth_maxPriorityFeePerGas);
  } else {
    // if eth_maxPriorityFeePerGas is not available, use 1.5 gwei default
    const feeData = await provider.getFeeData();
    maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
    if (!maxPriorityFeePerGas) {
      // chain does not support eip-1559, return null for both
      return {
        maxFeePerGas: null,
        maxPriorityFeePerGas: null,
        baseFee: null
      };
    }
  }

  // add 10% tip to maxPriorityFeePerGas for faster processing
  maxPriorityFeePerGas = getPreferredPriorityFee(maxPriorityFeePerGas);
  // eip-1559 formula, doubling the base fee ensures that the tx can be included in the next 6 blocks no matter how busy the network is
  // good article on the subject: https://www.blocknative.com/blog/eip-1559-fees
  maxFeePerGas = baseBlockFee.mul(2).add(maxPriorityFeePerGas);
  return {
    maxFeePerGas,
    maxPriorityFeePerGas,
    baseFee: baseBlockFee
  };
}
function getPreferredPriorityFee(defaultPriorityFeePerGas) {
  let percentMultiplier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;
  const extraTip = defaultPriorityFeePerGas.div(100).mul(percentMultiplier); // + 10%
  const totalPriorityFee = defaultPriorityFeePerGas.add(extraTip);
  return totalPriorityFee;
}
async function getGasPrice(provider) {
  const gasPrice = await provider.getGasPrice();
  const maxGasPrice = utils.parseUnits("300", "gwei"); // 300 gwei
  const extraTip = gasPrice.div(100).mul(10); // + 10%
  const txGasPrice = gasPrice.add(extraTip);
  if (txGasPrice.gt(maxGasPrice)) {
    return maxGasPrice;
  }
  return txGasPrice;
}
async function estimateTransactionCost(provider, tx) {
  const chainId = (await provider.getNetwork()).chainId;
  let l1GasCost = BigNumber.from(0);
  if (isOpStackChain(chainId)) {
    const {
      asL2Provider
    } = await import('@eth-optimism/sdk');
    const l2RpcProvider = asL2Provider(provider);
    l1GasCost = await l2RpcProvider.estimateL1GasCost(tx);
  }
  const gasLimit = tx.gasLimit || (await provider.estimateGas(tx));
  const gasPrice = await getGasPrice(provider);
  const gasCost = BigNumber.from(gasLimit).mul(gasPrice);
  return gasCost.add(l1GasCost);
}
function isOpStackChain(chainId) {
  return chainId === Optimism.chainId || chainId === OpSepoliaTestnet.chainId || chainId === Base.chainId || chainId === BaseSepoliaTestnet.chainId || chainId === Zora.chainId || chainId === ZoraSepoliaTestnet.chainId || chainId === Celo.chainId || chainId === CeloAlfajoresTestnet.chainId;
}

/**
 * @internal
 */
function getGasStationUrl(chainId) {
  switch (chainId) {
    case ChainId.Polygon:
      return "https://gasstation.polygon.technology/v2";
    case ChainId.Mumbai:
      return "https://gasstation-testnet.polygon.technology/v2";
  }
}
const MIN_POLYGON_GAS_PRICE = /* @__PURE__ */(() => utils.parseUnits("31", "gwei"))();
const MIN_MUMBAI_GAS_PRICE = /* @__PURE__ */(() => utils.parseUnits("1", "gwei"))();

/**
 * @internal
 */
function getDefaultGasFee(chainId) {
  switch (chainId) {
    case ChainId.Polygon:
      return MIN_POLYGON_GAS_PRICE;
    case ChainId.Mumbai:
      return MIN_MUMBAI_GAS_PRICE;
  }
}

/**
 *
 * @returns The gas price
 * @internal
 */
async function getPolygonGasPriorityFee(chainId) {
  const gasStationUrl = getGasStationUrl(chainId);
  try {
    const data = await (await fetch(gasStationUrl)).json();
    // take the standard speed here, SDK options will define the extra tip
    const priorityFee = data["fast"]["maxPriorityFee"];
    if (priorityFee > 0) {
      const fixedFee = parseFloat(priorityFee).toFixed(9);
      return utils.parseUnits(fixedFee, "gwei");
    }
  } catch {
    // if the gas station is down, return the default gas fee
  }
  return getDefaultGasFee(chainId);
}

/**
 * @internal
 */

/**
 * @internal
 */

/**
 * @internal
 */

/**
 * eip712 sign typed data with different wallet handling including ledger live
 * @internal
 */
async function signTypedDataInternal(signerInput, domain, types, message) {
  // Handle ERC4337Signer
  let signer = signerInput;
  if (signerInput.originalSigner) {
    signer = signerInput.originalSigner;
  }
  const provider = signer?.provider;
  if (!provider) {
    throw new Error("missing provider");
  }
  const payload = utils._TypedDataEncoder.getPayload(domain, types, message);
  let signature = "";
  const signerAddress = (await signer.getAddress()).toLowerCase();

  // an indirect way for accessing walletconnect's underlying provider
  if (provider?.provider?.isWalletConnect) {
    signature = await provider.send("eth_signTypedData", [signerAddress, JSON.stringify(payload)]);
  } else {
    try {
      signature = await signer._signTypedData(domain, types, message);
    } catch (err) {
      if (err?.message?.includes("eth_signTypedData_v4")) {
        signature = await provider.send("eth_signTypedData", [signerAddress, JSON.stringify(payload)]);
      } else {
        // magic.link signer only supports this way
        try {
          await provider.send("eth_signTypedData_v4", [signerAddress, JSON.stringify(payload)]);
        } catch (finalErr) {
          throw finalErr;
        }
      }
    }
  }

  // fix ledger live where signature result in v = 0, 1. ethers magically fix it in split/join.
  return {
    payload,
    signature: utils.joinSignature(utils.splitSignature(signature))
  };
}

const NAME_ABI = [{
  inputs: [],
  name: "name",
  outputs: [{
    internalType: "string",
    name: "",
    type: "string"
  }],
  stateMutability: "view",
  type: "function"
}];
const DOMAIN_SEPARATOR_ABI = [{
  constant: true,
  inputs: [],
  name: "DOMAIN_SEPARATOR",
  outputs: [{
    internalType: "bytes32",
    name: "",
    type: "bytes32"
  }],
  payable: false,
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "getDomainSeperator",
  outputs: [{
    internalType: "bytes32",
    name: "",
    type: "bytes32"
  }],
  stateMutability: "view",
  type: "function"
}];
const NONCES_ABI = [{
  inputs: [{
    internalType: "address",
    name: "owner",
    type: "address"
  }],
  name: "nonces",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "user",
    type: "address"
  }],
  name: "getNonce",
  outputs: [{
    internalType: "uint256",
    name: "nonce",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}];
async function getSignerNonce(signer, contractAddress) {
  const contract = new Contract(contractAddress, NONCES_ABI, signer);
  try {
    return await contract.nonces(await signer.getAddress());
  } catch (err) {
    return await contract.getNonce(await signer.getAddress());
  }
}
async function getDomainSeperator(signer, contractAddress) {
  const contract = new Contract(contractAddress, DOMAIN_SEPARATOR_ABI, signer);
  try {
    return await contract.DOMAIN_SEPARATOR();
  } catch (err) {
    try {
      return await contract.getDomainSeperator();
    } catch (err2) {
      console.error("Error getting domain separator", err2);
    }
  }
}
async function getTokenName(signer, contractAddress) {
  return new Contract(contractAddress, NAME_ABI, signer).name();
}

/**
 * Polygon chain has different EIP712 domain separator for USDC, DAI compared to other chains and slightly different than EIP-2612.
 */
async function getChainDomainSeperator(signer, domain) {
  const contractDomainSeparator = await getDomainSeperator(signer, domain.verifyingContract);
  const polygonDomain = {
    name: domain.name,
    version: domain.version,
    verifyingContract: domain.verifyingContract,
    salt: utils.hexZeroPad(BigNumber.from(domain.chainId).toHexString(), 32)
  };
  if (utils._TypedDataEncoder.hashDomain(polygonDomain) === contractDomainSeparator) {
    return polygonDomain;
  }
  return domain;
}

/**
 * @internal
 */
async function signEIP2612Permit(signer, currencyAddress, owner, spender, value, deadline, nonce, domainSeparatorVersion) {
  const [name, chainId, signerNonce] = await Promise.all([getTokenName(signer, currencyAddress), signer.getChainId(), getSignerNonce(signer, currencyAddress)]);
  const domain = await getChainDomainSeperator(signer, {
    name,
    version: domainSeparatorVersion || "1",
    chainId,
    verifyingContract: currencyAddress
  });
  nonce = nonce || signerNonce.toString();
  deadline = deadline || constants.MaxUint256;
  const message = {
    owner,
    spender,
    value,
    nonce,
    deadline
  };
  const types = {
    Permit: [{
      name: "owner",
      type: "address"
    }, {
      name: "spender",
      type: "address"
    }, {
      name: "value",
      type: "uint256"
    }, {
      name: "nonce",
      type: "uint256"
    }, {
      name: "deadline",
      type: "uint256"
    }]
  };
  const {
    signature
  } = await signTypedDataInternal(signer, domain, types, message);
  return {
    message,
    signature
  };
}

const TWRegistry_address = "0x7c487845f98938Bb955B1D5AD069d9a30e4131fd";
const TWFactory_address = "0x5DBC7B840baa9daBcBe9D2492E45D7244B54A2A0";

/**
 * @internal
 */
const OZ_DEFENDER_FORWARDER_ADDRESS = "0xc82BbE41f2cF04e3a8efA18F7032BDD7f6d98a81";

/**
 * @internal
 */
const CONTRACT_ADDRESSES = {
  [ChainId.Mainnet]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0x76ce2CB1Ae48Fa067f4fb8c5f803111AE0B24BEA",
    biconomyForwarder: "0x84a0856b038eaAd1cC7E297cF34A7e72685A8693",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: AddressZero
  },
  [ChainId.Goerli]: {
    openzeppelinForwarder: "0x5001A14CA6163143316a7C614e30e6041033Ac20",
    openzeppelinForwarderEOA: "0xe73c50cB9c5B378627ff625BB6e6725A4A5D65d2",
    biconomyForwarder: "0xE041608922d06a4F26C0d4c27d8bCD01daf1f792",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: "0xB1Bd9d7942A250BA2Dce27DD601F2ED4211A60C4"
  },
  [ChainId.Polygon]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0x4f247c69184ad61036EC2Bb3213b69F10FbEDe1F",
    biconomyForwarder: "0x86C80a8aa58e0A4fa09A69624c31Ab2a6CAD56b8",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: "0x308473Be900F4185A56587dE54bDFF5E8f7a6AE7"
  },
  [ChainId.Mumbai]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",
    biconomyForwarder: "0x9399BB24DBB5C4b782C70c2969F58716Ebbd6a3b",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: "0x3F17972CB27506eb4a6a3D59659e0B57a43fd16C"
  },
  [ChainId.Avalanche]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",
    biconomyForwarder: "0x64CD353384109423a966dCd3Aa30D884C9b2E057",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: AddressZero
  },
  [ChainId.AvalancheFujiTestnet]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0xe73c50cB9c5B378627ff625BB6e6725A4A5D65d2",
    biconomyForwarder: "0x6271Ca63D30507f2Dcbf99B52787032506D75BBF",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: "0x3E6eE864f850F5e5A98bc950B68E181Cf4010F23"
  },
  [ChainId.Fantom]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",
    biconomyForwarder: "0x64CD353384109423a966dCd3Aa30D884C9b2E057",
    twFactory: "0x97EA0Fcc552D5A8Fb5e9101316AAd0D62Ea0876B",
    twRegistry: TWRegistry_address,
    twBYOCRegistry: AddressZero
  },
  [ChainId.FantomTestnet]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0x42D3048b595B6e1c28a588d70366CcC2AA4dB47b",
    biconomyForwarder: "0x69FB8Dca8067A5D38703b9e8b39cf2D51473E4b4",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: "0x3E6eE864f850F5e5A98bc950B68E181Cf4010F23"
  },
  [ChainId.Arbitrum]: {
    openzeppelinForwarder: "0x4a8AC7f22DeD2CF923A51e4A1c67490bd8868add",
    openzeppelinForwarderEOA: "0x4f247c69184ad61036EC2Bb3213b69F10FbEDe1F",
    biconomyForwarder: "0xfe0fa3C06d03bDC7fb49c892BbB39113B534fB57",
    twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
    twRegistry: TWRegistry_address,
    twBYOCRegistry: AddressZero
  },
  [ChainId.ArbitrumGoerli]: {
    openzeppelinForwarder: "0x8cbc8B5d71702032904750A66AEfE8B603eBC538",
    openzeppelinForwarderEOA: "0x119704314Ef304EaAAE4b3c7C9ABd59272A28310",
    biconomyForwarder: AddressZero,
    twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
    twRegistry: TWRegistry_address,
    twBYOCRegistry: AddressZero
  },
  [ChainId.Optimism]: {
    openzeppelinForwarder: "0xd85da690EF288A6976DE0E85Fb2Aad512eBAfbf7",
    openzeppelinForwarderEOA: "0x7e80648EB2071E26937F9D42A513ccf4815fc702",
    biconomyForwarder: "0xefba8a2a82ec1fb1273806174f5e28fbb917cf95",
    twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
    twRegistry: TWRegistry_address,
    twBYOCRegistry: AddressZero
  },
  [ChainId.OptimismGoerli]: {
    openzeppelinForwarder: "0x8cbc8B5d71702032904750A66AEfE8B603eBC538",
    openzeppelinForwarderEOA: "0x119704314Ef304EaAAE4b3c7C9ABd59272A28310",
    biconomyForwarder: AddressZero,
    twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
    twRegistry: TWRegistry_address,
    twBYOCRegistry: AddressZero
  },
  [ChainId.BinanceSmartChainMainnet]: {
    openzeppelinForwarder: "0x7C4717039B89d5859c4Fbb85EDB19A6E2ce61171",
    openzeppelinForwarderEOA: "0xE8dd2Ff0212F86d3197b4AfDC6dAC6ac47eb10aC",
    biconomyForwarder: "0x86C80a8aa58e0A4fa09A69624c31Ab2a6CAD56b8",
    twBYOCRegistry: AddressZero,
    twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
    twRegistry: TWRegistry_address
  },
  [ChainId.BinanceSmartChainTestnet]: {
    openzeppelinForwarder: "0x44bE9D54B9C8b5e57a3325E8Ec9154640e7c6955",
    openzeppelinForwarderEOA: "0x7e80648EB2071E26937F9D42A513ccf4815fc702",
    biconomyForwarder: "0x61456BF1715C1415730076BB79ae118E806E74d2",
    twBYOCRegistry: AddressZero,
    twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
    twRegistry: TWRegistry_address
  },
  [ChainId.Hardhat]: {
    openzeppelinForwarder: AddressZero,
    openzeppelinForwarderEOA: AddressZero,
    biconomyForwarder: AddressZero,
    twFactory: AddressZero,
    twRegistry: AddressZero,
    twBYOCRegistry: AddressZero
  },
  [ChainId.Localhost]: {
    openzeppelinForwarder: AddressZero,
    openzeppelinForwarderEOA: AddressZero,
    biconomyForwarder: AddressZero,
    twFactory: AddressZero,
    twRegistry: AddressZero,
    twBYOCRegistry: AddressZero
  }
};

/**
 * @internal
 */
function getContractAddressByChainId(chainId, contractName) {
  // for testing only
  if (chainId === ChainId.Hardhat || chainId === ChainId.Localhost) {
    if (contractName === "twFactory") {
      return getProcessEnv("factoryAddress");
    } else if (contractName === "twRegistry") {
      return getProcessEnv("registryAddress");
    } else {
      return AddressZero;
    }
  }
  // real output here
  return CONTRACT_ADDRESSES[chainId]?.[contractName];
}

/**
 * @public
 */
let EventType = /*#__PURE__*/function (EventType) {
  EventType["Transaction"] = "transaction";
  EventType["Signature"] = "signature";
  return EventType;
}({});

const CallOverrideSchema = /* @__PURE__ */(() => z.object({
  gasLimit: BigNumberishSchema.optional(),
  gasPrice: BigNumberishSchema.optional(),
  maxFeePerGas: BigNumberishSchema.optional(),
  maxPriorityFeePerGas: BigNumberishSchema.optional(),
  nonce: BigNumberishSchema.optional(),
  value: BigNumberishSchema.optional(),
  blockTag: z.union([z.string(), z.number()]).optional(),
  from: AddressOrEnsSchema.optional(),
  type: z.number().optional()
}).strict())();

/**
 * @internal
 */
class RPCConnectionHandler extends EventEmitter {
  constructor(network, options) {
    super();
    try {
      this.options = SDKOptionsSchema.parse(options);
    } catch (optionParseError) {
      console.error("invalid sdk options object passed, falling back to default options", optionParseError);
      this.options = SDKOptionsSchema.parse({});
    }
    const [signer, provider] = getSignerAndProvider(network, this.options);
    this.network = network;
    this.signer = signer;
    this.provider = provider;
  }
  /**
   * The function to call whenever the network changes, such as when the users connects their wallet, disconnects their wallet, the connected chain changes, etc.
   *
   * @param network - a network, signer or provider that ethers js can interpret
   */
  updateSignerOrProvider(network) {
    const [signer, provider] = getSignerAndProvider(network, this.options);
    this.network = network;
    this.signer = signer;
    this.provider = provider;
  }
  /**
   *
   * @returns whether or not a signer is set, `true` if there is no signer so the class is in "read only" mode
   */
  isReadOnly() {
    return !isSigner(this.signer);
  }

  /**
   * Explicitly get the active signer.
   * @returns The active signer, if there is one
   */
  getSigner() {
    return this.signer;
  }

  /**
   * Explicitly get the active provider.
   * @returns The active provider
   */
  getProvider() {
    return this.provider;
  }

  /**
   *
   * @returns The current signer if there is one, otherwise the active provider
   */
  getSignerOrProvider() {
    return this.getSigner() || this.getProvider();
  }
}

/**
 * @internal
 */
class ContractWrapper extends RPCConnectionHandler {
  isValidContract = false;
  customOverrides = () => ({});
  /**
   * @internal
   */

  constructor(network, contractAddress, contractAbi, options, storage) {
    super(network, options);
    this.abi = AbiSchema.parse(contractAbi);
    this.address = contractAddress;
    // set up the contract
    this.writeContract = new Contract(contractAddress, contractAbi, this.getSignerOrProvider());
    // setup the read only contract
    this.readContract = this.writeContract.connect(this.getProvider());
    this.storage = storage;
    this.functions = extractFunctionsFromAbi(this.abi);
    this.extensions = detectFeatures(this.abi);
  }
  updateSignerOrProvider(network) {
    // update the underlying base class
    super.updateSignerOrProvider(network);
    // re-connect the contract with the new signer / provider
    this.writeContract = this.writeContract.connect(this.getSignerOrProvider());
    // setup the read only contract
    this.readContract = this.writeContract.connect(this.getProvider());
  }
  updateAbi(updatedAbi) {
    // re-connect the contract with the new signer / provider
    this.writeContract = new Contract(this.address, updatedAbi, this.getSignerOrProvider());

    // setup the read only contract
    this.readContract = this.writeContract.connect(this.getProvider());
    this.abi = AbiSchema.parse(updatedAbi);
    this.functions = extractFunctionsFromAbi(this.abi);
    this.extensions = detectFeatures(this.abi);
  }

  /**
   * @internal
   */
  async getChainID() {
    const provider = this.getProvider();
    const {
      chainId
    } = await provider.getNetwork();
    return chainId;
  }
  /**
   * @internal
   */
  async getSignerAddress() {
    const signer = this.getSigner();
    if (!signer) {
      throw new Error("This action requires a connected wallet to sign the transaction. Please pass a valid signer to the SDK.");
    }
    return await signer.getAddress();
  }

  /**
   * @internal
   */
  callStatic() {
    return this.writeContract.callStatic;
  }

  /**
   * @internal
   */
  async getCallOverrides() {
    // If we're running in the browser, let users configure gas price in their wallet UI
    if (isBrowser()) {
      return {};
    }
    return getDefaultGasOverrides(this.getProvider());
  }

  /**
   * @internal
   */
  emitTransactionEvent(status, transactionHash) {
    this.emit(EventType.Transaction, {
      status,
      transactionHash
    });
  }

  /**
   * @internal
   */
  async multiCall(encoded) {
    return this.sendTransaction("multicall", [encoded]);
  }

  /**
   * @internal
   */
  async estimateGas(fn, args) {
    return this.writeContract.estimateGas[fn](...args);
  }
  async populateTransaction(fn, args) {
    return this.writeContract.populateTransaction[fn](...args);
  }

  /**
   * @internal
   */
  withTransactionOverride(hook) {
    this.customOverrides = hook;
  }

  /**
   *
   * @param functionName - The function name on the contract to call
   * @param args - The arguments to be passed to the functionName
   * @returns The return value of the function call
   */
  async read(functionName, args) {
    const functions = this.functions.filter(f => f.name === functionName);
    if (!functions.length) {
      throw new Error(`Function "${functionName.toString()}" not found in contract. Check your dashboard for the list of functions available`);
    }
    const fn = functions.find(f => f.name === functionName && f.inputs.length === args.length);

    // TODO extract this and re-use for deploy function to check constructor args
    if (!fn) {
      throw new Error(`Function "${functionName.toString()}" requires ${functions[0].inputs.length} arguments, but ${args.length} were provided.\nExpected function signature: ${functions[0].signature}`);
    }
    const ethersFnName = `${functionName.toString()}(${fn.inputs.map(i => i.type).join()})`;

    // check if the function exists on the contract, otherwise use the name passed in
    const fnName = ethersFnName in this.readContract.functions ? ethersFnName : functionName;
    if (fn.stateMutability === "view" || fn.stateMutability === "pure") {
      // read function
      const result = await this.readContract[fnName.toString()](...args);
      return result;
    }
    throw new Error("Cannot call a write function with read()");
  }

  /**
   * @internal
   */
  async call(functionName) {
    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    let overrides = arguments.length > 2 ? arguments[2] : undefined;
    // parse last arg as tx options if present
    const txOptions = overrides ? await CallOverrideSchema.parseAsync(overrides) : undefined;
    const functions = extractFunctionsFromAbi(AbiSchema.parse(this.abi)).filter(f => f.name === functionName);
    if (!functions.length) {
      throw new Error(`Function "${functionName}" not found in contract. Check your dashboard for the list of functions available`);
    }
    const fn = functions.find(f => f.name === functionName && f.inputs.length === args.length);

    // TODO extract this and re-use for deploy function to check constructor args
    if (!fn) {
      throw new Error(`Function "${functionName}" requires ${functions[0].inputs.length} arguments, but ${args.length} were provided.\nExpected function signature: ${functions[0].signature}`);
    }
    const ethersFnName = `${functionName}(${fn.inputs.map(i => i.type).join()})`;

    // check if the function exists on the contract, otherwise use the name passed in
    const fnName = ethersFnName in this.readContract.functions ? ethersFnName : functionName;

    // TODO validate each argument
    if (fn.stateMutability === "view" || fn.stateMutability === "pure") {
      // read function
      return txOptions ? this.readContract[fnName](...args, txOptions) : this.readContract[fnName](...args);
    } else {
      // write function
      const receipt = await this.sendTransaction(fnName, args, txOptions);
      return {
        receipt
      };
    }
  }

  /**
   * @internal
   */
  async sendTransaction(
  // eslint-disable-next-line @typescript-eslint/ban-types
  fn, args, callOverrides) {
    if (!callOverrides) {
      callOverrides = await this.getCallOverrides();
    }
    // if a custom override is set, merge our override with the custom one
    callOverrides = {
      ...callOverrides,
      ...this.customOverrides()
    };
    // clear up the override (single use)
    this.customOverrides = () => ({});
    if (this.options?.gasless && ("openzeppelin" in this.options.gasless || "biconomy" in this.options.gasless || "engine" in this.options.gasless)) {
      if (fn === "multicall" && Array.isArray(args[0]) && args[0].length > 0) {
        const from = await this.getSignerAddress();
        args[0] = args[0].map(tx => utils.solidityPack(["bytes", "address"], [tx, from]));
      }
      const provider = this.getProvider();
      const txHash = await this.sendGaslessTransaction(fn, args, callOverrides);
      this.emitTransactionEvent("submitted", txHash);
      const receipt = await provider.waitForTransaction(txHash);
      this.emitTransactionEvent("completed", txHash);
      return receipt;
    } else {
      // one time verification that this is a valid contract (to avoid sending funds to wrong addresses)
      if (!this.isValidContract) {
        const code = await this.getProvider().getCode(this.address);
        this.isValidContract = code !== "0x";
        if (!this.isValidContract) {
          throw new Error("The address you're trying to send a transaction to is not a smart contract. Make sure you are on the correct network and the contract address is correct");
        }
      }
      const tx = await this.sendTransactionByFunction(fn, args, callOverrides);
      this.emitTransactionEvent("submitted", tx.hash);

      // tx.wait() can fail so we need to wrap it with a catch
      let receipt;
      try {
        receipt = await tx.wait();
      } catch (err) {
        try {
          // If tx.wait() fails, it just gives us a generic "transaction failed"
          // error. So instead, we need to call static to get an informative error message
          await this.writeContract.callStatic[fn](...args, ...(callOverrides.value ? [{
            value: callOverrides.value
          }] : []));
        } catch (staticErr) {
          throw await this.formatError(staticErr, fn, args, callOverrides);
        }
        throw await this.formatError(err, fn, args, callOverrides);
      }
      this.emitTransactionEvent("completed", tx.hash);
      return receipt;
    }
  }

  /**
   * @internal
   */
  async sendTransactionByFunction(fn, args, callOverrides) {
    const func = this.writeContract.functions[fn];
    if (!func) {
      throw new Error(`invalid function: "${fn.toString()}"`);
    }

    // First, if no gasLimit is passed, call estimate gas ourselves
    if (!callOverrides.gasLimit) {
      try {
        callOverrides.gasLimit = await this.writeContract.estimateGas[fn](...args, callOverrides);
      } catch (e) {
        // If gas estimation fails, we'll call static to get a better error message
        try {
          await this.writeContract.callStatic[fn](...args, ...(callOverrides.value ? [{
            value: callOverrides.value
          }] : []));
        } catch (err) {
          throw await this.formatError(err, fn, args, callOverrides);
        }
      }
    }

    // Now there should be no gas estimate errors
    try {
      return await func(...args, callOverrides);
    } catch (err) {
      throw await this.formatError(err, fn, args, callOverrides);
    }
  }
  async formatError(error, fn, args, callOverrides) {
    const provider = this.getProvider();

    // Get metadata for transaction to populate into error
    const network = await provider.getNetwork();
    const from = await (callOverrides.from || this.getSignerAddress());
    const to = this.address;
    const data = this.readContract.interface.encodeFunctionData(fn, args);
    const value = BigNumber.from(callOverrides.value || 0);
    const rpcUrl = provider.connection?.url;

    // Render function signature with arguments filled in
    const functionSignature = this.readContract.interface.getFunction(fn);
    const methodArgs = args.map(arg => {
      if (JSON.stringify(arg).length <= 80) {
        return JSON.stringify(arg);
      }
      return JSON.stringify(arg, undefined, 2);
    });
    const joinedArgs = methodArgs.join(", ").length <= 80 ? methodArgs.join(", ") : "\n" + methodArgs.map(arg => "  " + arg.split("\n").join("\n  ")).join(",\n") + "\n";
    const method = `${functionSignature.name}(${joinedArgs})`;
    const hash = error.transactionHash || error.transaction?.hash || error.receipt?.transactionHash;

    // Parse the revert reason from the error
    const reason = parseRevertReason(error);

    // Get contract sources for stack trace
    let sources = undefined;
    let contractName = undefined;
    try {
      const metadata = await fetchContractMetadataFromAddress(this.address, this.getProvider(), this.storage, this.options);
      if (metadata.name) {
        contractName = metadata.name;
      }
      if (metadata.metadata.sources) {
        sources = await fetchSourceFilesFromMetadata(metadata, this.storage);
      }
    } catch (err) {
      // no-op
    }
    return new TransactionError({
      reason,
      from,
      to,
      method,
      data,
      network,
      rpcUrl,
      value,
      hash,
      contractName,
      sources
    }, error);
  }

  /**
   * @internal
   */
  async sendGaslessTransaction(fn) {
    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    let callOverrides = arguments.length > 2 ? arguments[2] : undefined;
    const signer = this.getSigner();
    invariant(signer, "Cannot execute gasless transaction without valid signer");
    const chainId = await this.getChainID();
    const from = await this.getSignerAddress();
    const to = this.writeContract.address;
    const value = callOverrides?.value || 0;
    if (BigNumber.from(value).gt(0)) {
      throw new Error("Cannot send native token value with gasless transaction");
    }
    const data = this.writeContract.interface.encodeFunctionData(fn, args);
    let gas = BigNumber.from(0);
    try {
      const gasEstimate = await this.readContract.estimateGas[fn](...args);
      gas = gasEstimate.mul(2);
    } catch (e) {
      // ignore
    }

    // in some cases WalletConnect doesn't properly gives an estimate for how much gas it would actually use.
    // as a fix, we're setting it to a high arbitrary number (500k) as the gas limit that should cover for most function calls.
    if (gas.lt(100000)) {
      gas = BigNumber.from(500000);
    }

    // check for gas override in callOverrides
    if (callOverrides.gasLimit && BigNumber.from(callOverrides.gasLimit).gt(gas)) {
      gas = BigNumber.from(callOverrides.gasLimit);
    }
    const tx = {
      from,
      to,
      data,
      chainId,
      gasLimit: gas,
      functionName: fn.toString(),
      functionArgs: args,
      callOverrides
    };
    return await this.defaultGaslessSendFunction(tx);
  }
  async signTypedData(signer, domain, types, message) {
    this.emit(EventType.Signature, {
      status: "submitted",
      message,
      signature: ""
    });
    const {
      signature: sig
    } = await signTypedDataInternal(signer, domain, types, message);
    this.emit(EventType.Signature, {
      status: "completed",
      message,
      signature: sig
    });
    return sig;
  }
  parseLogs(eventName, logs) {
    if (!logs || logs.length === 0) {
      return [];
    }
    const topic = this.writeContract.interface.getEventTopic(eventName);
    const parsedLogs = logs.filter(x => x.topics.indexOf(topic) >= 0);
    return parsedLogs.map(l => this.writeContract.interface.parseLog(l));
  }
  async defaultGaslessSendFunction(transaction) {
    if (this.options.gasless && "biconomy" in this.options.gasless) {
      return this.biconomySendFunction(transaction);
    } else if (this.options.gasless && "openzeppelin" in this.options.gasless) {
      return this.defenderSendFunction(transaction);
    }
    return this.engineSendFunction(transaction);
  }
  async engineSendFunction(transaction) {
    invariant(this.options.gasless && "engine" in this.options.gasless, "calling engine gasless transaction without engine config in the SDK options");
    const request = await this.enginePrepareRequest(transaction);
    const res = await fetch(this.options.gasless.engine.relayerUrl, {
      ...request,
      headers: {
        "Content-Type": "application/json"
      }
    });
    const data = await res.json();
    if (data.error) {
      throw new Error(data.error?.message || JSON.stringify(data.error));
    }
    const queueId = data.result.queueId;
    const engineUrl = this.options.gasless.engine.relayerUrl.split("/relayer/")[0];
    const startTime = Date.now();
    while (true) {
      const txRes = await fetch(`${engineUrl}/transaction/status/${queueId}`);
      const txData = await txRes.json();
      if (txData.result.transactionHash) {
        return txData.result.transactionHash;
      }

      // Time out after 30s
      if (Date.now() - startTime > 30 * 1000) {
        throw new Error("timeout");
      }

      // Poll to check if the transaction was mined
      await new Promise(resolve => setTimeout(resolve, 2000));
    }
  }
  async enginePrepareRequest(transaction) {
    invariant(this.options.gasless && "engine" in this.options.gasless, "calling engine gasless transaction without openzeppelin config in the SDK options");
    const signer = this.getSigner();
    const provider = this.getProvider();
    const storage = this.storage;
    invariant(signer, "signer is not set");
    try {
      const {
        abi
      } = await fetchContractMetadataFromAddress(transaction.to, provider, storage);
      const chainId = (await provider.getNetwork()).chainId;
      const contract = new ContractWrapper(signer, transaction.to, abi, {}, storage);
      if (abi.find(item => item.name === "executeMetaTransaction")) {
        const name = await contract.call("name", []);
        const domain = {
          name,
          version: "1",
          salt: "0x" + chainId.toString(16).padStart(64, "0"),
          // Use 64 length hex chain id as salt
          verifyingContract: transaction.to
        };
        const types = {
          MetaTransaction: [{
            name: "nonce",
            type: "uint256"
          }, {
            name: "from",
            type: "address"
          }, {
            name: "functionSignature",
            type: "bytes"
          }]
        };
        const nonce = await contract.call("getNonce", [transaction.from]);
        const message = {
          nonce: nonce,
          from: transaction.from,
          functionSignature: transaction.data
        };
        const {
          signature
        } = await signTypedDataInternal(signer, domain, types, message);
        return {
          method: "POST",
          body: JSON.stringify({
            type: "execute-meta-transaction",
            request: {
              from: transaction.from,
              to: transaction.to,
              data: transaction.data
            },
            signature
          })
        };
      }
    } catch {
      // no-op
    }
    if (transaction.functionName === "approve" && transaction.functionArgs.length === 2) {
      const spender = transaction.functionArgs[0];
      const amount = transaction.functionArgs[1];
      // TODO: support DAI permit by signDAIPermit
      const {
        message: permit,
        signature: sig
      } = await signEIP2612Permit(signer, transaction.to, transaction.from, spender, amount, this.options.gasless.engine.domainSeparatorVersion);
      const message = {
        to: transaction.to,
        owner: permit.owner,
        spender: permit.spender,
        value: BigNumber.from(permit.value).toString(),
        nonce: BigNumber.from(permit.nonce).toString(),
        deadline: BigNumber.from(permit.deadline).toString()
      };
      return {
        method: "POST",
        body: JSON.stringify({
          type: "permit",
          request: message,
          signature: sig
        })
      };
    } else {
      const forwarderAddress = this.options.gasless.engine.relayerForwarderAddress || CONTRACT_ADDRESSES[transaction.chainId]?.openzeppelinForwarder || (await computeForwarderAddress(provider, storage));
      const ForwarderABI = (await import('@thirdweb-dev/contracts-js/dist/abis/Forwarder.json')).default;
      const forwarder = new Contract(forwarderAddress, ForwarderABI, provider);
      const nonce = await getAndIncrementNonce(forwarder, "getNonce", [transaction.from]);
      let domain;
      let types;
      let message;
      if (this.options.gasless.experimentalChainlessSupport) {
        domain = {
          name: "GSNv2 Forwarder",
          version: "0.0.1",
          verifyingContract: forwarderAddress
        };
        types = {
          ForwardRequest: ChainAwareForwardRequest
        };
        message = {
          from: transaction.from,
          to: transaction.to,
          value: BigNumber.from(0).toString(),
          gas: BigNumber.from(transaction.gasLimit).toString(),
          nonce: BigNumber.from(nonce).toString(),
          data: transaction.data,
          chainid: BigNumber.from(transaction.chainId).toString()
        };
      } else {
        domain = {
          name: this.options.gasless.engine.domainName,
          version: this.options.gasless.engine.domainVersion,
          chainId: transaction.chainId,
          verifyingContract: forwarderAddress
        };
        types = {
          ForwardRequest
        };
        message = {
          from: transaction.from,
          to: transaction.to,
          value: BigNumber.from(0).toString(),
          gas: BigNumber.from(transaction.gasLimit).toString(),
          nonce: BigNumber.from(nonce).toString(),
          data: transaction.data
        };
      }
      const {
        signature: sig
      } = await signTypedDataInternal(signer, domain, types, message);
      const signature = sig;
      return {
        method: "POST",
        body: JSON.stringify({
          type: "forward",
          request: message,
          signature,
          forwarderAddress
        })
      };
    }
  }
  async biconomySendFunction(transaction) {
    invariant(this.options.gasless && "biconomy" in this.options.gasless, "calling biconomySendFunction without biconomy");
    const signer = this.getSigner();
    const provider = this.getProvider();
    invariant(signer && provider, "signer and provider must be set");
    const forwarder = new Contract(getContractAddressByChainId(transaction.chainId, "biconomyForwarder"), BiconomyForwarderAbi, provider);
    const batchId = 0;
    const batchNonce = await getAndIncrementNonce(forwarder, "getNonce", [transaction.from, batchId]);
    const request = {
      from: transaction.from,
      to: transaction.to,
      token: constants.AddressZero,
      txGas: transaction.gasLimit.toNumber(),
      tokenGasPrice: "0",
      batchId,
      batchNonce: batchNonce.toNumber(),
      deadline: Math.floor(Date.now() / 1000 + (this.options?.gasless && "biconomy" in this.options.gasless && this.options.gasless.biconomy?.deadlineSeconds || 3600)),
      data: transaction.data
    };
    const hashToSign = utils.arrayify(utils.solidityKeccak256(["address", "address", "address", "uint256", "uint256", "uint256", "uint256", "uint256", "bytes32"], [request.from, request.to, request.token, request.txGas, request.tokenGasPrice, request.batchId, request.batchNonce, request.deadline, utils.keccak256(request.data)]));
    this.emit(EventType.Signature, {
      status: "submitted",
      message: hashToSign,
      signature: ""
    });
    const signature = await signer.signMessage(hashToSign);
    this.emit(EventType.Signature, {
      status: "completed",
      message: hashToSign,
      signature
    });
    const response = await fetch("https://api.biconomy.io/api/v2/meta-tx/native", {
      method: "POST",
      body: JSON.stringify({
        from: transaction.from,
        apiId: this.options.gasless.biconomy.apiId,
        params: [request, signature],
        to: transaction.to,
        gasLimit: transaction.gasLimit.toHexString()
      }),
      headers: {
        "x-api-key": this.options.gasless.biconomy.apiKey,
        "Content-Type": "application/json;charset=utf-8"
      }
    });
    if (response.ok) {
      const resp = await response.json();
      if (!resp.txHash) {
        throw new Error(`relay transaction failed: ${resp.log}`);
      }
      return resp.txHash;
    }
    throw new Error(`relay transaction failed with status: ${response.status} (${response.statusText})`);
  }
  async defenderSendFunction(transaction) {
    invariant(this.options.gasless && "openzeppelin" in this.options.gasless, "calling openzeppelin gasless transaction without openzeppelin config in the SDK options");
    const signer = this.getSigner();
    const provider = this.getProvider();
    invariant(signer, "provider is not set");
    invariant(provider, "provider is not set");
    const ForwarderABI = (await import('@thirdweb-dev/contracts-js/dist/abis/Forwarder.json')).default;
    const forwarderAddress = this.options.gasless.openzeppelin.relayerForwarderAddress || (this.options.gasless.openzeppelin.useEOAForwarder ? CONTRACT_ADDRESSES[transaction.chainId]?.openzeppelinForwarderEOA || (await computeEOAForwarderAddress(this.getProvider(), this.storage, "", this.options.clientId, this.options.secretKey)) : CONTRACT_ADDRESSES[transaction.chainId]?.openzeppelinForwarder || (await computeForwarderAddress(this.getProvider(), this.storage, "", this.options.clientId, this.options.secretKey)));
    const forwarder = new Contract(forwarderAddress, ForwarderABI, provider);
    const nonce = await getAndIncrementNonce(forwarder, "getNonce", [transaction.from]);
    let domain;
    let types;
    let message;
    if (this.options.gasless.experimentalChainlessSupport) {
      domain = {
        name: "GSNv2 Forwarder",
        version: "0.0.1",
        verifyingContract: forwarderAddress
      };
      types = {
        ForwardRequest: ChainAwareForwardRequest
      };
      message = {
        from: transaction.from,
        to: transaction.to,
        value: BigNumber.from(0).toString(),
        gas: BigNumber.from(transaction.gasLimit).toString(),
        nonce: BigNumber.from(nonce).toString(),
        data: transaction.data,
        chainid: BigNumber.from(transaction.chainId).toString()
      };
    } else {
      domain = {
        name: this.options.gasless.openzeppelin.domainName,
        version: this.options.gasless.openzeppelin.domainVersion,
        chainId: transaction.chainId,
        verifyingContract: forwarderAddress
      };
      types = {
        ForwardRequest
      };
      message = {
        from: transaction.from,
        to: transaction.to,
        value: BigNumber.from(0).toString(),
        gas: BigNumber.from(transaction.gasLimit).toString(),
        nonce: BigNumber.from(nonce).toString(),
        data: transaction.data
      };
    }
    let signature;
    this.emit(EventType.Signature, {
      status: "submitted",
      message,
      signature: ""
    });

    // if the executing function is "approve" and matches with erc20 approve signature
    // and if the token supports permit, then we use permit for gasless instead of approve.
    if (transaction.functionName === "approve" && transaction.functionArgs.length === 2) {
      const spender = transaction.functionArgs[0];
      const amount = transaction.functionArgs[1];
      // TODO: support DAI permit by signDAIPermit
      const {
        message: permit,
        signature: sig
      } = await signEIP2612Permit(signer, this.writeContract.address, transaction.from, spender, amount, this.options.gasless.openzeppelin.domainSeparatorVersion);
      const {
        r,
        s,
        v
      } = utils.splitSignature(sig);
      message = {
        to: this.address,
        owner: permit.owner,
        spender: permit.spender,
        value: BigNumber.from(permit.value).toString(),
        nonce: BigNumber.from(permit.nonce).toString(),
        deadline: BigNumber.from(permit.deadline).toString(),
        r,
        s,
        v
      };
      signature = sig;
    } else {
      const {
        signature: sig
      } = await signTypedDataInternal(signer, domain, types, message);
      signature = sig;
    }
    let messageType = "forward";

    // if has owner property then it's permit :)
    if (message?.owner) {
      messageType = "permit";
    }
    const body = JSON.stringify({
      request: message,
      signature,
      forwarderAddress,
      type: messageType
    });
    this.emit(EventType.Signature, {
      status: "completed",
      message,
      signature
    });
    const response = await fetch(this.options.gasless.openzeppelin.relayerUrl, {
      method: "POST",
      body
    });
    if (response.ok) {
      const resp = await response.json();
      if (!resp.result) {
        throw new Error(`Relay transaction failed: ${resp.message}`);
      }
      const result = JSON.parse(resp.result);
      return result.txHash;
    }
    throw new Error(`relay transaction failed with status: ${response.status} (${response.statusText})`);
  }
}

/**
 * Checks whether the given ABI supports a given feature
 * @deprecated use isExtensionEnabled instead
 * @param abi - The abi to check
 * @param featureName - The feature name to check
 * @internal
 */
function isFeatureEnabled(abi, featureName, features) {
  return _featureEnabled(features, featureName);
}

/**
 * Checks whether the given ABI supports a given extension
 * @public
 * @param abi - The abi to check
 * @param featureName - The feature name to check
 */
function isExtensionEnabled(abi, featureName, features) {
  return isFeatureEnabled(abi, featureName, features);
}

/**
 * Searches the feature map for featureName and returns whether its enabled
 * @internal
 * @param features - The feature map to search
 * @param featureName - The feature name to search for
 */
function _featureEnabled(features, featureName) {
  const keys = Object.keys(features);
  if (!keys.includes(featureName)) {
    let found = false;
    for (const key of keys) {
      const f = features[key];
      found = _featureEnabled(f.features, featureName);
      if (found) {
        break;
      }
    }
    return found;
  }
  const feature = features[featureName];
  return feature.enabled;
}

/**
 * @internal
 */
async function getPluginABI(addresses, provider, storage) {
  return (await Promise.all(addresses.map(address => fetchContractMetadataFromAddress(address, provider, storage).catch(err => {
    console.error(`Failed to fetch plug-in for ${address}`, err);
    return {
      abi: []
    };
  })))).map(metadata => metadata.abi);
}

/**
 * @internal
 */
async function getCompositeABI(address, abi, provider, options, storage) {
  let pluginABIs = [];
  try {
    // TODO this should not be needed here, should only be done once in getContract()
    const features = detectFeatures(abi);
    // check if contract is plugin-pattern / dynamic
    const isPluginRouter = isExtensionEnabled(abi, "PluginRouter", features);
    const isbaseRouter = isExtensionEnabled(abi, "DynamicContract", features);
    // check if the contract has fallback function - we'll further check for diamond pattern if needed
    const isFallback = isExtensionEnabled(abi, "Fallback", features);
    if (isbaseRouter) {
      const contract = new ContractWrapper(provider, address, getAllExtensionsAbi, options, storage);
      const plugins = await contract.call("getAllExtensions");

      // get extension addresses
      const pluginAddresses = plugins.map(item => item.metadata.implementation);

      // get ABIs of extension contracts --
      pluginABIs = await getPluginABI(pluginAddresses, provider, storage);
    } else if (isPluginRouter) {
      const contract = new ContractWrapper(provider, address, getAllPluginsAbi, options, storage);
      const pluginMap = await contract.call("getAllPlugins");

      // get extension addresses
      const allPlugins = pluginMap.map(item => item.pluginAddress);
      const plugins = Array.from(new Set(allPlugins));

      // get ABIs of extension contracts
      pluginABIs = await getPluginABI(plugins, provider, storage);
    } else if (isFallback) {
      // check if diamond pattern
      const dimaondAbi = ["function facets() external view returns (tuple(address,bytes4[])[])"];
      const contract = new Contract(address, dimaondAbi, provider);

      // get facets
      const facets = await contract.facets();

      // filter facet addresses
      const facetAddresses = facets.map(item => item[0]);

      // get ABI of facets
      pluginABIs = await getPluginABI(facetAddresses, provider, storage);
    }
  } catch (err) {}
  return pluginABIs.length > 0 ? joinABIs([...pluginABIs], abi) : abi;
}

/**
 *
 * @internal
 */
const roleMap = {
  admin: "",
  transfer: "TRANSFER_ROLE",
  minter: "MINTER_ROLE",
  pauser: "PAUSER_ROLE",
  lister: "LISTER_ROLE",
  asset: "ASSET_ROLE",
  unwrap: "UNWRAP_ROLE",
  factory: "FACTORY_ROLE",
  signer: "SIGNER_ROLE",
  metadata: "METADATA_ROLE",
  revoke: "REVOKE_ROLE",
  migration: "MIGRATION_ROLE"
};

/**
 * @public
 */

/**
 * @public
 */
const ALL_ROLES = /* @__PURE__ */(() => Object.keys(roleMap))();

/**
 * @internal
 */
function getRoleHash(role) {
  if (role === "admin") {
    return utils.hexZeroPad([0], 32);
  }
  return utils.id(roleMap[role]);
}

const DropErc1155ContractInput = /* @__PURE__ */(() => CommonContractSchema.merge(CommonRoyaltySchema).merge(MerkleSchema).merge(CommonSymbolSchema))();
const DropErc1155ContractOutput = /* @__PURE__ */(() => CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(MerkleSchema).merge(CommonSymbolSchema))();
const DropErc1155ContractDeploy = /* @__PURE__ */(() => DropErc1155ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema))();
const DropErc1155ContractSchema = {
  deploy: DropErc1155ContractDeploy,
  output: DropErc1155ContractOutput,
  input: DropErc1155ContractInput
};

const DropErc20ContractInput = /* @__PURE__ */(() => CommonContractSchema.merge(MerkleSchema).merge(CommonSymbolSchema))();
const DropErc20ContractOutput = /* @__PURE__ */(() => CommonContractOutputSchema.merge(MerkleSchema).merge(CommonSymbolSchema))();
const DropErc20ContractDeploy = /* @__PURE__ */(() => DropErc20ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema))();
const DropErc20ContractSchema = {
  deploy: DropErc20ContractDeploy,
  output: DropErc20ContractOutput,
  input: DropErc20ContractInput
};

const DropErc721ContractInput = /* @__PURE__ */(() => CommonContractSchema.merge(CommonRoyaltySchema).merge(MerkleSchema).merge(CommonSymbolSchema))();
const DropErc721ContractOutput = /* @__PURE__ */(() => CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(MerkleSchema).merge(CommonSymbolSchema))();
const DropErc721ContractDeploy = /* @__PURE__ */(() => DropErc721ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema))();
const DropErc721ContractSchema = {
  deploy: DropErc721ContractDeploy,
  output: DropErc721ContractOutput,
  input: DropErc721ContractInput
};

const MarketplaceContractInput = CommonContractSchema;
const MarketplaceContractOutput = CommonContractOutputSchema;
const MarketplaceContractDeploy = /* @__PURE__ */(() => MarketplaceContractInput.merge(CommonPlatformFeeSchema).merge(CommonTrustedForwarderSchema))();
const MarketplaceContractSchema = {
  deploy: MarketplaceContractDeploy,
  output: MarketplaceContractOutput,
  input: MarketplaceContractInput
};

const MultiwrapContractInput = /* @__PURE__ */(() => CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema))();
const MultiwrapContractOutput = /* @__PURE__ */(() => CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema))();
const MultiwrapContractDeploy = /* @__PURE__ */(() => MultiwrapContractInput.merge(CommonTrustedForwarderSchema))();
const MultiwrapContractSchema = {
  deploy: MultiwrapContractDeploy,
  output: MultiwrapContractOutput,
  input: MultiwrapContractInput
};

const PackContractInput = /* @__PURE__ */(() => CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema))();
const PackContractOutput = /* @__PURE__ */(() => CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema))();
const PackContractDeploy = /* @__PURE__ */(() => PackContractInput.merge(CommonPlatformFeeSchema).merge(CommonTrustedForwarderSchema))();
const PackContractSchema = {
  deploy: PackContractDeploy,
  output: PackContractOutput,
  input: PackContractInput
};

const SplitRecipientInputSchema = /* @__PURE__ */(() => z.object({
  address: AddressOrEnsSchema,
  sharesBps: BasisPointsSchema.gt(0, "Shares must be greater than 0")
}))();
const SplitRecipientOuputSchema = /* @__PURE__ */(() => SplitRecipientInputSchema.extend({
  address: AddressOrEnsSchema,
  sharesBps: BasisPointsSchema
}))();
const SplitsContractInput = /* @__PURE__ */(() => CommonContractSchema.extend({
  recipients: z.array(SplitRecipientInputSchema).default([]).superRefine((val, context) => {
    const addressMap = {};
    let totalShares = 0;
    for (let index = 0; index < val.length; index++) {
      const entry = val[index];
      if (addressMap[entry.address]) {
        context.addIssue({
          code: z.ZodIssueCode.custom,
          message: `Duplicate address.`,
          path: [index, `address`]
        });
      }
      addressMap[entry.address] = true;
      totalShares += entry.sharesBps;
      if (totalShares > 10000) {
        context.addIssue({
          code: z.ZodIssueCode.custom,
          message: `Total shares cannot go over 100%.`,
          path: [index, `sharesBps`]
        });
      }
    }
    if (totalShares !== 10000) {
      context.addIssue({
        code: z.ZodIssueCode.custom,
        message: `Total shares need to add up to 100%. Total shares are currently ${totalShares / 100}%`,
        path: []
      });
    }
  })
}))();
const SplitsContractOutput = /* @__PURE__ */(() => CommonContractOutputSchema.extend({
  recipients: z.array(SplitRecipientOuputSchema)
}))();
const SplitsContractDeploy = /* @__PURE__ */(() => SplitsContractInput.merge(SplitsContractInput).merge(CommonTrustedForwarderSchema))();
const SplitsContractSchema = {
  deploy: SplitsContractDeploy,
  output: SplitsContractOutput,
  input: SplitsContractInput
};

const TokenErc1155ContractInput = /* @__PURE__ */(() => CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema))();
const TokenErc1155ContractOutput = /* @__PURE__ */(() => CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema))();
const TokenErc1155ContractDeploy = /* @__PURE__ */(() => TokenErc1155ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema))();
const TokenErc1155ContractSchema = {
  deploy: TokenErc1155ContractDeploy,
  output: TokenErc1155ContractOutput,
  input: TokenErc1155ContractInput
};

const TokenErc20ContractInput = /* @__PURE__ */(() => CommonContractSchema.merge(CommonSymbolSchema))();
const TokenErc20ContractOutput = /* @__PURE__ */(() => CommonContractOutputSchema.merge(CommonSymbolSchema))();
const TokenErc20ContractDeploy = /* @__PURE__ */(() => TokenErc20ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema))();
const TokenErc20ContractSchema = {
  deploy: TokenErc20ContractDeploy,
  output: TokenErc20ContractOutput,
  input: TokenErc20ContractInput
};

const TokenErc721ContractInput = /* @__PURE__ */(() => CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema))();
const TokenErc721ContractOutput = /* @__PURE__ */(() => CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema))();
const TokenErc721ContractDeploy = /* @__PURE__ */(() => TokenErc721ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema))();
const TokenErc721ContractSchema = {
  deploy: TokenErc721ContractDeploy,
  output: TokenErc721ContractOutput,
  input: TokenErc721ContractInput
};

const VoteSettingsInputSchema = /* @__PURE__ */(() => z.object({
  voting_delay_in_blocks: z.number().min(0).default(0),
  voting_period_in_blocks: z.number().min(1).default(1),
  voting_token_address: AddressOrEnsSchema,
  voting_quorum_fraction: PercentSchema.default(0),
  proposal_token_threshold: BigNumberishSchema.default(1)
}))();
const VoteSettingsOuputSchema = /* @__PURE__ */(() => VoteSettingsInputSchema.extend({
  proposal_token_threshold: BigNumberSchema
}))();
const VoteContractInput = /* @__PURE__ */(() => CommonContractSchema.merge(VoteSettingsInputSchema))();
const VoteContractOutput = /* @__PURE__ */(() => CommonContractOutputSchema.merge(VoteSettingsOuputSchema))();
const VoteContractDeploy = /* @__PURE__ */(() => VoteContractInput.merge(CommonTrustedForwarderSchema))();
const VoteContractSchema = {
  deploy: VoteContractDeploy,
  output: VoteContractOutput,
  input: VoteContractInput
};
const ProposalOutputSchema = /* @__PURE__ */(() => z.object({
  proposalId: BigNumberSchema,
  proposer: z.string(),
  targets: z.array(z.string()),
  values: z.array(BigNumberSchema),
  signatures: z.array(z.string()),
  calldatas: z.array(z.string()),
  startBlock: BigNumberSchema,
  endBlock: BigNumberSchema,
  description: z.string()
}))();

const ADMIN_ROLE = ["admin"];
const NFT_BASE_CONTRACT_ROLES = ["admin", "minter", "transfer", "metadata"];
const MARKETPLACE_CONTRACT_ROLES = ["admin", "lister", "asset"];
const PACK_CONTRACT_ROLES = ["admin", "minter", "asset", "transfer"];
const TOKEN_DROP_CONTRACT_ROLES = ["admin", "transfer"];
const MULTIWRAP_CONTRACT_ROLES = ["admin", "transfer", "minter", "unwrap", "asset"];

const prebuiltContractTypes = {
  vote: "vote",
  token: "token",
  "edition-drop": "edition-drop",
  edition: "edition",
  marketplace: "marketplace",
  "marketplace-v3": "marketplace-v3",
  multiwrap: "multiwrap",
  "nft-collection": "nft-collection",
  "nft-drop": "nft-drop",
  pack: "pack",
  "signature-drop": "signature-drop",
  split: "split",
  "token-drop": "token-drop"
};
/**
 * @internal
 */
const EditionDropInitializer = {
  name: "DropERC1155",
  contractType: prebuiltContractTypes["edition-drop"],
  schema: DropErc1155ContractSchema,
  roles: NFT_BASE_CONTRACT_ROLES,
  initialize: async function () {
    for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
      _ref[_key] = arguments[_key];
    }
    let [network, address, storage, options] = _ref;
    const [, provider] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([EditionDropInitializer.getAbi(address, provider, storage), import('./edition-drop-2d33d27d.esm.js'), provider.getNetwork()]);
    return new contract.EditionDrop(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider, storage) => {
    const abi = await fetchAbiFromAddress(address, provider, storage);
    if (abi) {
      return abi;
    }
    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4
    const contractInfo = await getContractInfo(address, provider);
    return !contractInfo || contractInfo.version > 2 ? (await import('@thirdweb-dev/contracts-js/dist/abis/DropERC1155.json')).default : (await import('@thirdweb-dev/contracts-js/dist/abis/DropERC1155_V2.json')).default;
  }
};

/**
 * @internal
 */
const EditionInitializer = {
  name: "TokenERC1155",
  contractType: prebuiltContractTypes["edition"],
  schema: TokenErc1155ContractSchema,
  roles: NFT_BASE_CONTRACT_ROLES,
  initialize: async function () {
    for (var _len2 = arguments.length, _ref2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      _ref2[_key2] = arguments[_key2];
    }
    let [network, address, storage, options] = _ref2;
    const [, provider] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([EditionInitializer.getAbi(address, provider, storage), import('./edition-dd0a2e80.esm.js'), provider.getNetwork()]);
    return new contract.Edition(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider, storage) => {
    const abi = await fetchAbiFromAddress(address, provider, storage);
    if (abi) {
      return abi;
    }
    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4
    return (await import('@thirdweb-dev/contracts-js/dist/abis/TokenERC1155.json')).default;
  }
};

/**
 * @internal
 */
const MarketplaceInitializer = {
  name: "Marketplace",
  contractType: prebuiltContractTypes.marketplace,
  schema: MarketplaceContractSchema,
  roles: MARKETPLACE_CONTRACT_ROLES,
  initialize: async function () {
    for (var _len3 = arguments.length, _ref3 = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      _ref3[_key3] = arguments[_key3];
    }
    let [network, address, storage, options] = _ref3;
    const [, provider] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([MarketplaceInitializer.getAbi(address, provider, storage), import('./marketplace-67efcc9b.esm.js'), provider.getNetwork()]);
    return new contract.Marketplace(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider, storage) => {
    const abi = await fetchAbiFromAddress(address, provider, storage);
    if (abi) {
      return abi;
    }

    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4
    return (await import('@thirdweb-dev/contracts-js/dist/abis/Marketplace.json')).default;
  }
};

/**
 * @internal
 */
const MarketplaceV3Initializer = {
  name: "MarketplaceV3",
  contractType: prebuiltContractTypes["marketplace-v3"],
  schema: MarketplaceContractSchema,
  roles: MARKETPLACE_CONTRACT_ROLES,
  initialize: async function () {
    for (var _len4 = arguments.length, _ref4 = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      _ref4[_key4] = arguments[_key4];
    }
    let [network, address, storage, options] = _ref4;
    const [, provider] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([MarketplaceV3Initializer.getAbi(address, provider, storage, options), import('./marketplacev3-1c848700.esm.js'), provider.getNetwork()]);
    return new contract.MarketplaceV3(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider, storage, options) => {
    const chainId = (await provider.getNetwork()).chainId;
    const isZkSync = chainId === 280 || chainId === 324;

    // Can't resolve IPFS hash from plugin bytecode on ZkSync
    // Thus, pull the composite ABI from the release page
    if (isZkSync) {
      const publishedContract = await fetchPublishedContractFromPolygon(THIRDWEB_DEPLOYER, "MarketplaceV3", "latest", storage, options?.clientId, options?.secretKey);
      const uri = publishedContract.metadataUri;
      const compositeAbi = await getCompositeABIfromRelease(uri, storage);
      return compositeAbi;
    }
    const abi = await fetchAbiFromAddress(address, provider, storage);
    if (abi) {
      return await getCompositeABI(address, abi, provider, {}, storage);
    }

    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4
    const localAbi = (await import('@thirdweb-dev/contracts-js/dist/abis/MarketplaceV3.json')).default;
    return await getCompositeABI(address, AbiSchema.parse(localAbi || []), provider, {}, storage);
  }
};

/**
 * @internal
 */
const MultiwrapInitializer = {
  name: "Multiwrap",
  contractType: prebuiltContractTypes.multiwrap,
  schema: MultiwrapContractSchema,
  roles: MULTIWRAP_CONTRACT_ROLES,
  initialize: async function () {
    for (var _len5 = arguments.length, _ref5 = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      _ref5[_key5] = arguments[_key5];
    }
    let [network, address, storage, options] = _ref5;
    const [, provider] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([MultiwrapInitializer.getAbi(address, provider, storage), import('./multiwrap-d087fe98.esm.js'), provider.getNetwork()]);
    return new contract.Multiwrap(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider, storage) => {
    const abi = await fetchAbiFromAddress(address, provider, storage);
    if (abi) {
      return abi;
    }
    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4
    return (await import('@thirdweb-dev/contracts-js/dist/abis/Multiwrap.json')).default;
  }
};

/**
 * @internal
 */
const NFTCollectionInitializer = {
  name: "TokenERC721",
  contractType: prebuiltContractTypes["nft-collection"],
  schema: TokenErc721ContractSchema,
  roles: NFT_BASE_CONTRACT_ROLES,
  initialize: async function () {
    for (var _len6 = arguments.length, _ref6 = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      _ref6[_key6] = arguments[_key6];
    }
    let [network, address, storage, options] = _ref6;
    const [, provider] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([NFTCollectionInitializer.getAbi(address, provider, storage), import('./nft-collection-2764ae4e.esm.js'), provider.getNetwork()]);
    return new contract.NFTCollection(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider, storage) => {
    const abi = await fetchAbiFromAddress(address, provider, storage);
    if (abi) {
      return abi;
    }
    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4
    return (await import('@thirdweb-dev/contracts-js/dist/abis/TokenERC721.json')).default;
  }
};

/**
 * @internal
 */
const NFTDropInitializer = {
  name: "DropERC721",
  contractType: prebuiltContractTypes["nft-drop"],
  schema: DropErc721ContractSchema,
  roles: NFT_BASE_CONTRACT_ROLES,
  initialize: async function () {
    for (var _len7 = arguments.length, _ref7 = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      _ref7[_key7] = arguments[_key7];
    }
    let [network, address, storage, options] = _ref7;
    const [, provider] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([NFTDropInitializer.getAbi(address, provider, storage), import('./nft-drop-72e13dab.esm.js'), provider.getNetwork()]);
    return new contract.NFTDrop(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider, storage) => {
    const abi = await fetchAbiFromAddress(address, provider, storage);
    if (abi) {
      return abi;
    }
    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4
    const contractInfo = await getContractInfo(address, provider);
    return !contractInfo || contractInfo.version > 3 ? (await import('@thirdweb-dev/contracts-js/dist/abis/DropERC721.json')).default : (await import('@thirdweb-dev/contracts-js/dist/abis/DropERC721_V3.json')).default;
  }
};

/**
 * @internal
 */
const PackInitializer = {
  name: "Pack",
  contractType: prebuiltContractTypes["pack"],
  schema: PackContractSchema,
  roles: PACK_CONTRACT_ROLES,
  initialize: async function () {
    for (var _len8 = arguments.length, _ref8 = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      _ref8[_key8] = arguments[_key8];
    }
    let [network, address, storage, options] = _ref8;
    const [, provider] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([PackInitializer.getAbi(address, provider, storage), import('./pack-ed47fb0a.esm.js'), provider.getNetwork()]);
    return new contract.Pack(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider, storage) => {
    const abi = await fetchAbiFromAddress(address, provider, storage);
    if (abi) {
      return abi;
    }
    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4
    return AbiSchema.parse((await import('@thirdweb-dev/contracts-js/dist/abis/Pack.json')).default || []);
  }
};

/**
 * @internal
 */
const SignatureDropInitializer = {
  name: "SignatureDrop",
  contractType: prebuiltContractTypes["signature-drop"],
  schema: DropErc721ContractSchema,
  roles: NFT_BASE_CONTRACT_ROLES,
  initialize: async function () {
    for (var _len9 = arguments.length, _ref9 = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
      _ref9[_key9] = arguments[_key9];
    }
    let [network, address, storage, options] = _ref9;
    const [, provider] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([SignatureDropInitializer.getAbi(address, provider, storage), import('./signature-drop-5ecd8c9a.esm.js'), provider.getNetwork()]);
    return new contract.SignatureDrop(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider, storage) => {
    const abi = await fetchAbiFromAddress(address, provider, storage);
    if (abi) {
      return abi;
    }
    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4
    const contractInfo = await getContractInfo(address, provider);
    return !contractInfo || contractInfo.version > 4 ? (await import('@thirdweb-dev/contracts-js/dist/abis/SignatureDrop.json')).default : (await import('@thirdweb-dev/contracts-js/dist/abis/SignatureDrop_V4.json')).default;
  }
};

/**
 * @internal
 */
const SplitInitializer = {
  name: "Split",
  contractType: prebuiltContractTypes["split"],
  schema: SplitsContractSchema,
  roles: ADMIN_ROLE,
  initialize: async function () {
    for (var _len10 = arguments.length, _ref10 = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
      _ref10[_key10] = arguments[_key10];
    }
    let [network, address, storage, options] = _ref10;
    const [, provider] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([SplitInitializer.getAbi(address, provider, storage), import('./split-8b18b939.esm.js'), provider.getNetwork()]);
    return new contract.Split(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider, storage) => {
    const abi = await fetchAbiFromAddress(address, provider, storage);
    if (abi) {
      return abi;
    }
    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4
    return (await import('@thirdweb-dev/contracts-js/dist/abis/Split.json')).default;
  }
};

/**
 * @internal
 */
const TokenDropInitializer = {
  name: "DropERC20",
  contractType: prebuiltContractTypes["token-drop"],
  schema: DropErc20ContractSchema,
  roles: TOKEN_DROP_CONTRACT_ROLES,
  initialize: async function () {
    for (var _len11 = arguments.length, _ref11 = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
      _ref11[_key11] = arguments[_key11];
    }
    let [network, address, storage, options] = _ref11;
    const [, provider] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([TokenDropInitializer.getAbi(address, provider, storage), import('./token-drop-f3267f50.esm.js'), provider.getNetwork()]);
    return new contract.TokenDrop(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider, storage) => {
    const abi = await fetchAbiFromAddress(address, provider, storage);
    if (abi) {
      return abi;
    }
    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4
    const contractInfo = await getContractInfo(address, provider);
    return !contractInfo || contractInfo.version > 2 ? (await import('@thirdweb-dev/contracts-js/dist/abis/DropERC20.json')).default : (await import('@thirdweb-dev/contracts-js/dist/abis/DropERC20_V2.json')).default;
  }
};

/**
 * @internal
 */
const TokenInitializer = {
  name: "TokenERC20",
  contractType: prebuiltContractTypes.token,
  schema: TokenErc20ContractSchema,
  roles: NFT_BASE_CONTRACT_ROLES,
  initialize: async function () {
    for (var _len12 = arguments.length, _ref12 = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
      _ref12[_key12] = arguments[_key12];
    }
    let [network, address, storage, options] = _ref12;
    const [, provider] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([TokenInitializer.getAbi(address, provider, storage), import('./token-266f2eb5.esm.js'), provider.getNetwork()]);
    return new contract.Token(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider, storage) => {
    const abi = await fetchAbiFromAddress(address, provider, storage);
    if (abi) {
      return abi;
    }
    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4
    return (await import('@thirdweb-dev/contracts-js/dist/abis/TokenERC20.json')).default;
  }
};

/**
 * @internal
 */
const VoteInitializer = {
  name: "VoteERC20",
  contractType: prebuiltContractTypes.vote,
  schema: VoteContractSchema,
  roles: [],
  initialize: async function () {
    for (var _len13 = arguments.length, _ref13 = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
      _ref13[_key13] = arguments[_key13];
    }
    let [network, address, storage, options] = _ref13;
    const [, provider] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([VoteInitializer.getAbi(address, provider, storage), import('./vote-eb0a0ccd.esm.js'), provider.getNetwork()]);
    return new contract.Vote(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider, storage) => {
    const abi = await fetchAbiFromAddress(address, provider, storage);
    if (abi) {
      return abi;
    }
    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4
    return (await import('@thirdweb-dev/contracts-js/dist/abis/VoteERC20.json')).default;
  }
};
async function getContractInfo(address, provider) {
  try {
    return await getPrebuiltInfo(address, provider);
  } catch (e) {
    return undefined;
  }
}

/**
 * a map from contractType - contract metadata
 * @internal
 */
const PREBUILT_CONTRACTS_MAP = {
  [prebuiltContractTypes["edition-drop"]]: EditionDropInitializer,
  [prebuiltContractTypes.edition]: EditionInitializer,
  [prebuiltContractTypes.marketplace]: MarketplaceInitializer,
  [prebuiltContractTypes["marketplace-v3"]]: MarketplaceV3Initializer,
  [prebuiltContractTypes.multiwrap]: MultiwrapInitializer,
  [prebuiltContractTypes["nft-collection"]]: NFTCollectionInitializer,
  [prebuiltContractTypes["nft-drop"]]: NFTDropInitializer,
  [prebuiltContractTypes.pack]: PackInitializer,
  [prebuiltContractTypes["signature-drop"]]: SignatureDropInitializer,
  [prebuiltContractTypes.split]: SplitInitializer,
  [prebuiltContractTypes["token-drop"]]: TokenDropInitializer,
  [prebuiltContractTypes.token]: TokenInitializer,
  [prebuiltContractTypes.vote]: VoteInitializer
};

/**
 * @internal
 */
const PREBUILT_CONTRACTS_APPURI_MAP = {
  [prebuiltContractTypes["edition-drop"]]: "ipfs://QmNm3wRzpKYWo1SRtJfgfxtvudp5p2nXD6EttcsQJHwTmk",
  [prebuiltContractTypes.edition]: "",
  [prebuiltContractTypes.marketplace]: "ipfs://QmbAgC8YwY36n8H2kuvSWsRisxDZ15QZw3xGZyk9aDvcv7/marketplace.html",
  [prebuiltContractTypes["marketplace-v3"]]: "ipfs://QmbAgC8YwY36n8H2kuvSWsRisxDZ15QZw3xGZyk9aDvcv7/marketplace-v3.html",
  [prebuiltContractTypes.multiwrap]: "",
  [prebuiltContractTypes["nft-collection"]]: "",
  [prebuiltContractTypes["nft-drop"]]: "ipfs://QmZptmVipc6SGFbKAyXcxGgohzTwYRXZ9LauRX5ite1xDK",
  [prebuiltContractTypes.pack]: "",
  [prebuiltContractTypes["signature-drop"]]: "ipfs://QmZptmVipc6SGFbKAyXcxGgohzTwYRXZ9LauRX5ite1xDK",
  [prebuiltContractTypes.split]: "",
  [prebuiltContractTypes["token-drop"]]: "ipfs://QmbAgC8YwY36n8H2kuvSWsRisxDZ15QZw3xGZyk9aDvcv7/erc20.html",
  [prebuiltContractTypes.token]: "",
  [prebuiltContractTypes.vote]: ""
};
const SmartContract = {
  name: "SmartContract",
  contractType: "custom",
  schema: {},
  roles: ALL_ROLES
};

/**
 * @internal
 */
const CONTRACTS_MAP = {
  ...PREBUILT_CONTRACTS_MAP,
  [SmartContract.contractType]: SmartContract
};

/**
 * @internal
 */
function getContractTypeForRemoteName(name) {
  return Object.values(CONTRACTS_MAP).find(contract => contract.name === name)?.contractType || "custom";
}

/**
 * @internal
 */
function getContractName(type) {
  return Object.values(CONTRACTS_MAP).find(contract => contract.contractType === type)?.name;
}

/**
 * @internal
 */

/**
 * @internal
 */

/**
 * @internal
 */

/**
 * @internal
 */

/**
 * @internal
 */

/**
 * @internal
 */

/**
 * @internal
 */

/**
 * @internal
 */

export { estimateTransactionCost as $, AssetNotFoundError as A, includesErrorMessage as B, CONTRACTS_MAP as C, DuplicateFileNameError as D, EditionDropInitializer as E, FileNameMissingError as F, ALL_ROLES as G, getRoleHash as H, InvalidAddressError as I, getContractMetadataFromCache as J, fetchContractMetadataFromAddress as K, ListingNotFoundError as L, MarketplaceInitializer as M, NFTCollectionInitializer as N, fetchContractMetadataFromBytecode as O, PackInitializer as P, QuantityAboveLimitError as Q, RestrictedTransferError as R, StaticJsonRpcBatchProvider as S, TokenDropInitializer as T, UploadError as U, VoteInitializer as V, WrongListingTypeError as W, fetchAbiFromAddress as X, getDefaultGasOverrides as Y, getDynamicFeeData as Z, getGasPrice as _, EditionInitializer as a, NATIVE_TOKEN_ADDRESS as a$, getPolygonGasPriorityFee as a0, fetchContractMetadata as a1, formatCompilerMetadata as a2, hasMatchingAbi as a3, matchesAbiFromBytecode as a4, extractCommentFromMetadata as a5, extractConstructorParamsFromAbi as a6, extractFunctionsFromAbi as a7, extractMinimalProxyImplementationAddress as a8, resolveContractUriFromAddress as a9, isContractDeployed as aA, isEIP155Enforced as aB, getCreate2FactoryAddress as aC, computeCreate2FactoryTransaction as aD, getSaltHash as aE, getInitBytecodeWithSalt as aF, computeDeploymentAddress as aG, computeEOAForwarderAddress as aH, computeForwarderAddress as aI, getKeylessTxn as aJ, computeDeploymentInfo as aK, encodeConstructorParamsForImplementation as aL, getCreate2FactoryDeploymentInfo as aM, THIRDWEB_DEPLOYER as aN, fetchPublishedContractFromPolygon as aO, fetchAndCacheDeployMetadata as aP, resolveEns as aQ, resolveAddress as aR, signTypedDataInternal as aS, OZ_DEFENDER_FORWARDER_ADDRESS as aT, CONTRACT_ADDRESSES as aU, getContractAddressByChainId as aV, getContractPublisherAddress as aW, getMultichainRegistryAddress as aX, ChainId as aY, setSupportedChains as aZ, getSupportedChains as a_, resolveContractUriAndBytecode as aa, resolveImplementation as ab, extractIPFSHashFromBytecode as ac, fetchRawPredeployMetadata as ad, fetchPreDeployMetadata as ae, fetchExtendedReleaseMetadata as af, detectFeatures as ag, detectFeaturesFromBytecode as ah, getAllDetectedFeatures as ai, getAllDetectedExtensionsFromBytecode as aj, constructAbiFromBytecode as ak, getAllDetectedExtensions as al, isFeatureEnabled as am, isExtensionEnabled as an, joinABIs as ao, getCompositeABI as ap, toSemver as aq, isIncrementalVersion as ar, isDowngradeVersion as as, fetchSourceFilesFromMetadata as at, CREATE2_FACTORY_BYTECODE as au, SIGNATURE as av, COMMON_FACTORY as aw, GAS_LIMIT_FOR_DEPLOYER as ax, DEPLOYER_BYTECODE as ay, DEPLOYER_ABI as az, MarketplaceV3Initializer as b, DropErc1155ContractDeploy as b$, NATIVE_TOKENS as b0, getNativeTokenByChainId as b1, LINK_TOKEN_ADDRESS as b2, EventType as b3, getChainProvider as b4, getChainIdFromNetwork as b5, getChainIdOrName as b6, isChainConfig as b7, getProviderFromRpcUrl as b8, getSignerAndProvider as b9, FullPublishMetadataSchemaInput as bA, FullPublishMetadataSchemaOutput as bB, ProfileSchemaInput as bC, ProfileSchemaOutput as bD, PublishedContractSchema as bE, ContractInfoSchema as bF, CompilerMetadataFetchedSchema as bG, PreDeployMetadataFetchedSchema as bH, CommonContractSchema as bI, CommonContractOutputSchema as bJ, CommonRoyaltySchema as bK, CommonPrimarySaleSchema as bL, CommonPlatformFeeSchema as bM, CommonTrustedForwarderSchema as bN, CommonSymbolSchema as bO, MerkleSchema as bP, SnapshotEntryInput as bQ, SnapshotInputSchema as bR, SnapshotEntryWithProofSchema as bS, SnapshotSchema as bT, SnapshotInfoSchema as bU, DropErc721ContractInput as bV, DropErc721ContractOutput as bW, DropErc721ContractDeploy as bX, DropErc721ContractSchema as bY, DropErc1155ContractInput as bZ, DropErc1155ContractOutput as b_, SUPPORTED_FEATURES as ba, BigNumberSchema as bb, BigNumberishSchema as bc, BigNumberTransformSchema as bd, AddressSchema as be, AddressOrEnsSchema as bf, CallOverrideSchema as bg, SDKOptionsSchema as bh, BYOCContractMetadataSchema as bi, CustomContractInput as bj, CustomContractOutput as bk, CustomContractDeploy as bl, CustomContractSchema as bm, AbiTypeSchema as bn, AbiObjectSchema as bo, AbiSchema as bp, CompilerTypeInput as bq, PreDeployMetadata as br, ChainIdToAddressSchema as bs, CustomFactoryInput as bt, FactoryDeploymentSchema as bu, DeployTypeInput as bv, RouterTypeInput as bw, DeploymentNetworkInput as bx, ExtraPublishMetadataSchemaInput as by, ExtraPublishMetadataSchemaOutput as bz, MultiwrapInitializer as c, FEATURE_NFT_ENUMERABLE as c$, DropErc1155ContractSchema as c0, MarketplaceContractInput as c1, MarketplaceContractOutput as c2, MarketplaceContractDeploy as c3, MarketplaceContractSchema as c4, PackContractInput as c5, PackContractOutput as c6, PackContractDeploy as c7, PackContractSchema as c8, SplitsContractInput as c9, getProcessEnv as cA, AmountSchema as cB, BigNumberTransformSchema$1 as cC, FileOrBufferOrStringSchema as cD, HexColor as cE, QuantitySchema as cF, BytesLikeSchema as cG, BasisPointsSchema as cH, FEATURE_TOKEN_BURNABLE as cI, FEATURE_TOKEN_CLAIM_CONDITIONS_V2 as cJ, FEATURE_TOKEN_BATCH_MINTABLE as cK, FEATURE_TOKEN_MINTABLE as cL, FEATURE_TOKEN_SIGNATURE_MINTABLE as cM, FEATURE_TOKEN as cN, FEATURE_METADATA as cO, FEATURE_APPURI as cP, FEATURE_NFT_BURNABLE as cQ, FEATURE_NFT_CLAIM_CONDITIONS_V2 as cR, FEATURE_NFT_CLAIM_ZORA as cS, FEATURE_NFT_CLAIM_CUSTOM as cT, FEATURE_NFT_LAZY_MINTABLE as cU, FEATURE_NFT_REVEALABLE as cV, FEATURE_NFT_LOYALTY_CARD as cW, FEATURE_NFT_UPDATABLE_METADATA as cX, FEATURE_NFT_BATCH_MINTABLE as cY, FEATURE_NFT_MINTABLE as cZ, FEATURE_NFT_SHARED_METADATA as c_, SplitsContractOutput as ca, SplitsContractDeploy as cb, SplitsContractSchema as cc, TokenErc20ContractInput as cd, TokenErc20ContractOutput as ce, TokenErc20ContractDeploy as cf, TokenErc20ContractSchema as cg, TokenErc721ContractInput as ch, TokenErc721ContractOutput as ci, TokenErc721ContractDeploy as cj, TokenErc721ContractSchema as ck, TokenErc1155ContractInput as cl, TokenErc1155ContractOutput as cm, TokenErc1155ContractDeploy as cn, TokenErc1155ContractSchema as co, VoteSettingsInputSchema as cp, VoteSettingsOuputSchema as cq, VoteContractInput as cr, VoteContractOutput as cs, VoteContractDeploy as ct, VoteContractSchema as cu, ProposalOutputSchema as cv, RPCConnectionHandler as cw, ContractWrapper as cx, extractFeatures as cy, AddressZero as cz, NFTDropInitializer as d, FEATURE_NFT_QUERYABLE as d0, FEATURE_NFT_SUPPLY as d1, FEATURE_NFT_TIERED_DROP as d2, FEATURE_NFT_SIGNATURE_MINTABLE_V2 as d3, FEATURE_NFT as d4, createLruCache as d5, FEATURE_PERMISSIONS as d6, FEATURE_ROYALTY as d7, FEATURE_OWNER as d8, FEATURE_PRIMARY_SALE as d9, ForwardRequest as dA, BiconomyForwarderAbi as dB, FEATURE_DIRECT_LISTINGS as dC, FEATURE_ENGLISH_AUCTIONS as dD, FEATURE_OFFERS as dE, caches as dF, MAX_BPS as dG, getRoyaltyEngineV1ByChainId as dH, NFT_BASE_CONTRACT_ROLES as dI, MARKETPLACE_CONTRACT_ROLES as dJ, MULTIWRAP_CONTRACT_ROLES as dK, MultiwrapContractSchema as dL, FEATURE_PACK_VRF as dM, PACK_CONTRACT_ROLES as dN, ADMIN_ROLE as dO, TOKEN_DROP_CONTRACT_ROLES as dP, DropErc20ContractSchema as dQ, isNode as da, FEATURE_EDITION_CLAIM_CUSTOM as db, FEATURE_EDITION_CLAIM_CONDITIONS_V2 as dc, FEATURE_EDITION_SIGNATURE_MINTABLE as dd, getPrebuiltInfo as de, FEATURE_EDITION_BURNABLE as df, FEATURE_EDITION_ENUMERABLE as dg, FEATURE_EDITION_LAZY_MINTABLE_V2 as dh, FEATURE_EDITION_REVEALABLE as di, FEATURE_EDITION_BATCH_MINTABLE as dj, FEATURE_EDITION_MINTABLE as dk, FEATURE_EDITION as dl, FEATURE_EDITION_SUPPLY as dm, FEATURE_EDITION_UPDATABLE_METADATA as dn, FEATURE_ACCOUNT_PERMISSIONS as dp, FEATURE_ACCOUNT as dq, FEATURE_ACCOUNT_FACTORY as dr, FEATURE_DYNAMIC_CONTRACT as ds, FEATURE_AIRDROP_ERC20 as dt, FEATURE_AIRDROP_ERC721 as du, FEATURE_AIRDROP_ERC1155 as dv, FEATURE_PLATFORM_FEE as dw, signEIP2612Permit as dx, getAndIncrementNonce as dy, ChainAwareForwardRequest as dz, SignatureDropInitializer as e, SplitInitializer as f, TokenInitializer as g, PREBUILT_CONTRACTS_MAP as h, PREBUILT_CONTRACTS_APPURI_MAP as i, getContractTypeForRemoteName as j, getContractName as k, isProvider as l, isSigner as m, NotFoundError as n, MissingRoleError as o, NotEnoughTokensError as p, MissingOwnerRoleError as q, FetchError as r, DuplicateLeafsError as s, AuctionAlreadyStartedError as t, FunctionDeprecatedError as u, AdminRoleMissingError as v, AuctionHasNotEndedError as w, ExtensionNotImplementedError as x, TransactionError as y, parseRevertReason as z };
