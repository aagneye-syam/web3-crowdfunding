import { a3 as hasMatchingAbi, bp as AbiSchema, cB as AmountSchema, aC as getCreate2FactoryAddress, aK as computeDeploymentInfo, aA as isContractDeployed, aF as getInitBytecodeWithSalt, bd as BigNumberTransformSchema, bb as BigNumberSchema, bc as BigNumberishSchema, bf as AddressOrEnsSchema } from './index-ab5604e1.esm.js';
import { utils, BigNumber } from 'ethers';
import invariant from 'tiny-invariant';
import { GENERATED_ABI } from '@thirdweb-dev/generated-abis';
import { z } from 'zod';
import { a as CommonNFTOutput, C as CommonNFTInput, N as NFTInputOrUriSchema } from './setErc20Allowance-06e5c1b7.esm.js';
import { createThirdwebClient, getBuyWithCryptoQuote as getBuyWithCryptoQuote$1, prepareTransaction } from 'thirdweb';
import { getBuyWithCryptoHistory as getBuyWithCryptoHistory$1, getBuyWithCryptoStatus as getBuyWithCryptoStatus$1 } from 'thirdweb/pay';
import { resolvePromisedValue } from 'thirdweb/utils';

/**
 * @internal
 * @param contractWrapper - The contract wrapper to check
 * @param abi - The abi to check
 * @returns
 */
function matchesPrebuiltAbi(contractWrapper, abi) {
  return hasMatchingAbi(AbiSchema.parse(contractWrapper.abi || []), [abi]);
}

function toUnits(amount, decimals) {
  return utils.parseUnits(AmountSchema.parse(amount), decimals);
}

function toDisplayValue(amount, decimals) {
  return utils.formatUnits(amount, decimals);
}

/**
 *
 * @internal
 * @param provider - The provider to use
 * @param storage - The storage to use
 * @param create2Factory - The create2 factory to use
 */
async function computeNativeTokenAddress(provider, storage, create2Factory, clientId, secretKey) {
  if (!create2Factory || create2Factory === "") {
    create2Factory = await getCreate2FactoryAddress(provider);
  }
  return (await computeDeploymentInfo("infra", provider, storage, create2Factory, {
    contractName: "WETH9"
  }, clientId, secretKey)).transaction.predictedAddress;
}

/**
 * Deploy a contract at a deterministic address, using Create2 method
 * Address depends on the Create2 factory address.
 *
 * @internal
 *
 * @param signer - The signer to use
 * @param bytecode - The bytecode to deploy
 * @param encodedArgs - The encoded constructor args to use
 * @param create2FactoryAddress - The create2 factory address to use
 */
async function deployContractDeterministicRaw(signer, bytecode, encodedArgs, create2FactoryAddress, options, predictedAddress) {
  let gasLimit = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 7000000;
  // Check if the implementation contract is already deployed
  invariant(signer.provider, "Provider required");
  const contractDeployed = predictedAddress ? await isContractDeployed(predictedAddress, signer.provider) : false;
  if (!contractDeployed) {
    console.debug(`deploying contract via create2 factory at: ${predictedAddress}`);
    const initBytecodeWithSalt = getInitBytecodeWithSalt(bytecode, encodedArgs);
    const tx = {
      to: create2FactoryAddress,
      data: initBytecodeWithSalt
    };
    try {
      await signer.estimateGas(tx);
    } catch (e) {
      console.debug("error estimating gas while deploying prebuilt: ", e);
      tx.gasLimit = BigNumber.from(gasLimit);
    }
    await (await signer.sendTransaction(tx)).wait();
  }
}

/**
 * @internal
 */
function getCachedAbiForContract(address) {
  if (address in GENERATED_ABI) {
    return GENERATED_ABI[address];
  }
  return undefined;
}

let ProposalState = /*#__PURE__*/function (ProposalState) {
  ProposalState[ProposalState["Pending"] = 0] = "Pending";
  ProposalState[ProposalState["Active"] = 1] = "Active";
  ProposalState[ProposalState["Canceled"] = 2] = "Canceled";
  ProposalState[ProposalState["Defeated"] = 3] = "Defeated";
  ProposalState[ProposalState["Succeeded"] = 4] = "Succeeded";
  ProposalState[ProposalState["Queued"] = 5] = "Queued";
  ProposalState[ProposalState["Expired"] = 6] = "Expired";
  ProposalState[ProposalState["Executed"] = 7] = "Executed";
  return ProposalState;
}({});

const PropertiesInput = /* @__PURE__ */(() => z.object({}).catchall(z.union([BigNumberTransformSchema, z.unknown()])))();

/**
 * @internal
 */
const OptionalPropertiesInput = /* @__PURE__ */(() => z.union([z.array(PropertiesInput), PropertiesInput]).optional())();

/**
 * @internal
 */
const EditionMetadataOutputSchema = /* @__PURE__ */(() => z.object({
  supply: BigNumberSchema,
  metadata: CommonNFTOutput
}))();

/**
 * @internal
 */
const EditionMetadataWithOwnerOutputSchema = /* @__PURE__ */(() => EditionMetadataOutputSchema.extend({
  owner: z.string(),
  quantityOwned: BigNumberSchema
}))();

/**
 * @internal
 */
const EditionMetadataInputSchema = /* @__PURE__ */(() => z.object({
  supply: BigNumberishSchema,
  metadata: CommonNFTInput
}))();

/**
 * @internal
 */
const EditionMetadataInputOrUriSchema = /* @__PURE__ */(() => z.object({
  supply: BigNumberishSchema,
  metadata: NFTInputOrUriSchema
}))();

/**
 * @public
 */

/**
 * @public
 */

/**
 * @internal
 */
const TokenMintInputSchema = /* @__PURE__ */(() => z.object({
  toAddress: AddressOrEnsSchema,
  amount: AmountSchema
}))();

/**
 * @public
 */

/**
 * The parameters for [`getBuyWithCryptoHistory`](https://portal.thirdweb.com/references/typescript/v4/getBuyWithCryptoHistory) function
 * It takes the wallet history address and optional cursor and page size. for paginated results.
 */

/**
 * Gets the History of purchases for a given wallet address
 * @param params - Object of type [`BuyWithCryptoHistoryParams`](https://portal.thirdweb.com/references/typescript/v4/BuyWithCryptoHistoryParams)
 * @example
 *
 * ```ts
//  * import { BuyWithCryptoHistoryData } from "@thirdweb-dev/sdk";
 *
 * const walletAddress = "0x...";
 * const params = {
 *  clientId: "YOUR_CLIENT_ID",
 *  walletAddress,
 * };
 *
 * // grabs the history of purchase transactions for the wallet address
 * const status = await getBuyWithCryptoHistory(params)
 * ```
 * @returns Object of type [`BuyWithCryptoHistoryData`](https://portal.thirdweb.com/references/typescript/v5/BuyWithCryptoHistoryData)
 */
async function getBuyWithCryptoHistory(params) {
  let client;
  if (params.secretKey) {
    client = createThirdwebClient({
      secretKey: params.secretKey
    });
  }
  if (params.clientId) {
    client = createThirdwebClient({
      clientId: params.clientId
    });
  }
  if (!client) {
    throw new Error("You must provide either a `clientId` or a `secretKey` to get a quote");
  }
  return getBuyWithCryptoHistory$1({
    ...params,
    client: client
  });
}

/**
 * The parameters for [`getBuyWithCryptoQuote`](https://portal.thirdweb.com/references/typescript/v4/getBuyWithCryptoQuote) function
 * It includes information about which tokens to swap, the amount of tokens to swap, slippage, etc.
 */

/**
 * Get a quote of type [`BuyWithCryptoQuote`](https://portal.thirdweb.com/references/typescript/v5/BuyWithCryptoQuote) to buy any given token with crypto.
 * This quote contains the information about the swap such as token amounts, processing fees, estimated time etc.
 *
 * Once you have the quote, you can use `prepareTransaction` and prepare the transaction for submission.
 * @param params - object of type [`GetBuyWithCryptoQuoteParams`](https://portal.thirdweb.com/references/typescript/v5/GetBuyWithCryptoQuoteParams)
 * @returns Object of type [`BuyWithCryptoQuote`](https://portal.thirdweb.com/references/typescript/v5/BuyWithCryptoQuote) which contains the information about the quote such as processing fees, estimated time, converted token amounts, etc.
 * @example
 *
 * ```ts
 * import { getBuyWithCryptoQuote } from "@thirdweb-dev/sdk";
 *
 * const quote = await getBuyWithCryptoQuote({
 *  clientId: "...",
 *  fromAddress: "0x...", // wallet address
 *  fromChainId: 137, // chain id of the source token
 *  fromTokenAddress: "0x...", // token address of the source token
 *  fromAmount: "10", // amount of source token to swap
 *  // optionally, you can use `toAmount` instead if you only want a certain amount of destination token
 *  toChainId: 10, // chain id of the destination token
 *  toTokenAddress: "0x...", // token address of the destination token
 *  toAddress: "0x...", // optional: send the tokens to a different address
 *  maxSlippageBPS: 50, // optional: max 0.5% slippage
 * });
 * ```
 */
async function getBuyWithCryptoQuote(params) {
  let client;
  if (params.secretKey) {
    client = createThirdwebClient({
      secretKey: params.secretKey
    });
  }
  if (params.clientId) {
    client = createThirdwebClient({
      clientId: params.clientId
    });
  }
  if (!client) {
    throw new Error("You must provide either a `clientId` or a `secretKey` to get a quote");
  }
  const data = await getBuyWithCryptoQuote$1({
    ...params,
    client
  });
  const sendTxn = prepareTransaction(data.transactionRequest);
  const approvalTxn = data.approval ? prepareTransaction(data.approval) : undefined;
  const [sendTxnTo, sendTxnData, sendTxnGasPrice, sendTxnGasLimit, sendTxnNonce, sendTxnValue, approvalTxnTo, approvalTxnData, approvalTxnGasLimit, approvalTxnGasPrice, approvalTxnNonce, approvalTxnValue] = await Promise.all([resolvePromisedValue(sendTxn.to), resolvePromisedValue(sendTxn.data), resolvePromisedValue(sendTxn.gasPrice), resolvePromisedValue(sendTxn.gas), resolvePromisedValue(sendTxn.nonce), resolvePromisedValue(sendTxn.value), resolvePromisedValue(approvalTxn?.to), resolvePromisedValue(approvalTxn?.data), resolvePromisedValue(approvalTxn?.gas), resolvePromisedValue(approvalTxn?.gasPrice), resolvePromisedValue(approvalTxn?.nonce), resolvePromisedValue(approvalTxn?.value)]);
  const swapRoute = {
    transactionRequest: {
      to: sendTxnTo,
      data: sendTxnData,
      gasPrice: sendTxnGasPrice,
      gasLimit: sendTxnGasLimit,
      nonce: sendTxnNonce,
      value: sendTxnValue,
      chainId: sendTxn.chain.id
    },
    approval: approvalTxn ? {
      to: approvalTxnTo,
      data: approvalTxnData,
      gasLimit: approvalTxnGasLimit,
      gasPrice: approvalTxnGasPrice,
      nonce: approvalTxnNonce,
      value: approvalTxnValue,
      chainId: approvalTxn.chain.id
    } : undefined,
    swapDetails: data.swapDetails,
    paymentTokens: data.paymentTokens,
    processingFees: data.processingFees,
    client
  };
  return swapRoute;
}

/**
 * Gets the status of a buy with crypto transaction
 * @param buyWithCryptoTransaction - Object of type [`BuyWithCryptoTransaction`](https://portal.thirdweb.com/references/typescript/v5/BuyWithCryptoTransaction)
 * @example
 *
 * ```ts
 * import { getBuyWithCryptoStatus, getBuyWithCryptoQuote } @thirdweb-dev/sdk";
 *
 * // get a quote between two tokens
 * const quote = await getBuyWithCryptoQuote(quoteParams);
 * // if approval is required, send the approval transaction
 * if (quote.approval) {
 *   const response = await signer.sendTransaction(quote.approval);
 * }
 * // send the quoted transaction
 * const transactionResult = await signer.sendTransaction(
 *   quote.transactionRequest,
 * );
 * // keep polling the status of the quoted transaction until it * returns a success or failure status
 * const status = await getBuyWithCryptoStatus({
 *   clientId: "YOUR_CLIENT_ID",
 *   transactionHash: transactionResult.hash,
 * });
 * ```
 * @returns Object of type [`BuyWithCryptoStatus`](https://portal.thirdweb.com/references/typescript/v4/BuyWithCryptoStatus)
 */
async function getBuyWithCryptoStatus(buyWithCryptoTransaction) {
  return getBuyWithCryptoStatus$1({
    ...buyWithCryptoTransaction,
    client: createThirdwebClient({
      clientId: buyWithCryptoTransaction.clientId
    })
  });
}

export { EditionMetadataOutputSchema as E, OptionalPropertiesInput as O, ProposalState as P, TokenMintInputSchema as T, toDisplayValue as a, getBuyWithCryptoHistory as b, getBuyWithCryptoQuote as c, getBuyWithCryptoStatus as d, computeNativeTokenAddress as e, deployContractDeterministicRaw as f, getCachedAbiForContract as g, EditionMetadataWithOwnerOutputSchema as h, EditionMetadataInputSchema as i, EditionMetadataInputOrUriSchema as j, matchesPrebuiltAbi as m, toUnits as t };
