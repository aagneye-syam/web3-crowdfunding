'use strict';

var ethers = require('ethers');
var zod = require('zod');
var chains = require('@thirdweb-dev/chains');
var crypto = require('@thirdweb-dev/crypto');
var invariant = require('tiny-invariant');
var BN = require('bn.js');
var bs58 = require('bs58');
var IBurnableERC20Abi = require('@thirdweb-dev/contracts-js/dist/abis/IBurnableERC20.json');
var IDrop = require('@thirdweb-dev/contracts-js/dist/abis/IDrop.json');
var DropERC20_V2Abi = require('@thirdweb-dev/contracts-js/dist/abis/IDropERC20_V2.json');
var IDropSinglePhase = require('@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase.json');
var IDropSinglePhaseV1 = require('@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase_V1.json');
var ERC20Abi = require('@thirdweb-dev/contracts-js/dist/abis/IERC20.json');
var IERC20PermitAbi = require('@thirdweb-dev/contracts-js/dist/abis/IERC20Permit.json');
var IMintableERC20Abi = require('@thirdweb-dev/contracts-js/dist/abis/IMintableERC20.json');
var MulticallAbi = require('@thirdweb-dev/contracts-js/dist/abis/IMulticall.json');
var ISignatureMintERC20Abi = require('@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC20.json');
var IERC20MetadataAbi = require('@thirdweb-dev/contracts-js/dist/abis/IERC20Metadata.json');
var IBurnableERC721Abi = require('@thirdweb-dev/contracts-js/dist/abis/IBurnableERC721.json');
var IClaimableERC721 = require('@thirdweb-dev/contracts-js/dist/abis/IClaimableERC721.json');
var DelayedRevealAbi = require('@thirdweb-dev/contracts-js/dist/abis/IDelayedReveal.json');
var DropERC721_V3Abi = require('@thirdweb-dev/contracts-js/dist/abis/IDropERC721_V3.json');
var Erc721Abi = require('@thirdweb-dev/contracts-js/dist/abis/IERC721.json');
var Erc721EnumerableAbi = require('@thirdweb-dev/contracts-js/dist/abis/IERC721Enumerable.json');
var Erc721AQueryableAbi = require('@thirdweb-dev/contracts-js/dist/abis/IERC721AQueryableUpgradeable.json');
var Erc721SupplyAbi = require('@thirdweb-dev/contracts-js/dist/abis/IERC721Supply.json');
var ILazyMintAbi = require('@thirdweb-dev/contracts-js/dist/abis/ILazyMint.json');
var IMintableERC721Abi = require('@thirdweb-dev/contracts-js/dist/abis/IMintableERC721.json');
var SignatureMintERC721Abi = require('@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC721.json');
var SignatureMintERC721_V1Abi = require('@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC721_V1.json');
var TieredDropAbi = require('@thirdweb-dev/contracts-js/dist/abis/LazyMintWithTier_V1.json');
var SharedMetadataAbi = require('@thirdweb-dev/contracts-js/dist/abis/SharedMetadata.json');
var zora_IDropERC721 = require('@thirdweb-dev/contracts-js/dist/abis/zora_IERC721Drop.json');
var ILoyaltyCardAbi = require('@thirdweb-dev/contracts-js/dist/abis/ILoyaltyCard.json');
var INFTMetadataAbi = require('@thirdweb-dev/contracts-js/dist/abis/INFTMetadata.json');
var IERC721MetadataAbi = require('@thirdweb-dev/contracts-js/dist/abis/IERC721Metadata.json');
var IBurnableERC1155Abi = require('@thirdweb-dev/contracts-js/dist/abis/IBurnableERC1155.json');
var IClaimableERC1155 = require('@thirdweb-dev/contracts-js/dist/abis/IClaimableERC1155.json');
var IDropMultiPhase1155 = require('@thirdweb-dev/contracts-js/dist/abis/IDrop1155.json');
var DropERC1155_V2Abi = require('@thirdweb-dev/contracts-js/dist/abis/IDropERC1155_V2.json');
var IDropSinglePhase1155 = require('@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase1155.json');
var IDropSinglePhase1155_V1 = require('@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase1155_V1.json');
var Erc1155Abi = require('@thirdweb-dev/contracts-js/dist/abis/IERC1155.json');
var Erc1155MetadataAbi = require('@thirdweb-dev/contracts-js/dist/abis/IERC1155Metadata.json');
var Erc1155SupplyAbi = require('@thirdweb-dev/contracts-js/dist/abis/IERC1155Supply.json');
var Erc1155EnumerableAbi = require('@thirdweb-dev/contracts-js/dist/abis/IERC1155Enumerable.json');
var IMintableERC1155Abi = require('@thirdweb-dev/contracts-js/dist/abis/IMintableERC1155.json');
var ISignatureMintERC1155Abi = require('@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC1155.json');
var IERC2771ContextAbi = require('@thirdweb-dev/contracts-js/dist/abis/IERC2771Context.json');
var IAppURI = require('@thirdweb-dev/contracts-js/dist/abis/IAppURI.json');
var IContractMetadataAbi = require('@thirdweb-dev/contracts-js/dist/abis/IContractMetadata.json');
var IDirectListingsAbi = require('@thirdweb-dev/contracts-js/dist/abis/IDirectListings.json');
var IEnglishAuctionsAbi = require('@thirdweb-dev/contracts-js/dist/abis/IEnglishAuctions.json');
var IOffersAbi = require('@thirdweb-dev/contracts-js/dist/abis/IOffers.json');
var IPackVRFAbi = require('@thirdweb-dev/contracts-js/dist/abis/IPackVRFDirect.json');
var IPermissionsAbi = require('@thirdweb-dev/contracts-js/dist/abis/IPermissions.json');
var IPermissionsEnumerableAbi = require('@thirdweb-dev/contracts-js/dist/abis/IPermissionsEnumerable.json');
var IThirdwebPlatformFeeAbi = require('@thirdweb-dev/contracts-js/dist/abis/IPlatformFee.json');
var IThirdwebPrimarySaleAbi = require('@thirdweb-dev/contracts-js/dist/abis/IPrimarySale.json');
var IThirdwebRoyaltyAbi = require('@thirdweb-dev/contracts-js/dist/abis/IRoyalty.json');
var IOwnableAbi = require('@thirdweb-dev/contracts-js/dist/abis/Ownable.json');
var IAirdropERC20 = require('@thirdweb-dev/contracts-js/dist/abis/IAirdropERC20.json');
var IAirdropERC721 = require('@thirdweb-dev/contracts-js/dist/abis/IAirdropERC721.json');
var IAirdropERC1155 = require('@thirdweb-dev/contracts-js/dist/abis/IAirdropERC1155.json');
var IAccountFactoryCore = require('@thirdweb-dev/contracts-js/dist/abis/IAccountFactoryCore.json');
var IAccountPermissions = require('@thirdweb-dev/contracts-js/dist/abis/IAccountPermissions.json');
var IAccountPermissionsV1 = require('@thirdweb-dev/contracts-js/dist/abis/IAccountPermissions_V1.json');
var IAccount = require('@thirdweb-dev/contracts-js/dist/abis/IAccount.json');
var utils = require('ethers/lib/utils');
var EventEmitter = require('eventemitter3');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var invariant__default = /*#__PURE__*/_interopDefault(invariant);
var BN__default = /*#__PURE__*/_interopDefault(BN);
var bs58__default = /*#__PURE__*/_interopDefault(bs58);
var IBurnableERC20Abi__default = /*#__PURE__*/_interopDefault(IBurnableERC20Abi);
var IDrop__default = /*#__PURE__*/_interopDefault(IDrop);
var DropERC20_V2Abi__default = /*#__PURE__*/_interopDefault(DropERC20_V2Abi);
var IDropSinglePhase__default = /*#__PURE__*/_interopDefault(IDropSinglePhase);
var IDropSinglePhaseV1__default = /*#__PURE__*/_interopDefault(IDropSinglePhaseV1);
var ERC20Abi__default = /*#__PURE__*/_interopDefault(ERC20Abi);
var IERC20PermitAbi__default = /*#__PURE__*/_interopDefault(IERC20PermitAbi);
var IMintableERC20Abi__default = /*#__PURE__*/_interopDefault(IMintableERC20Abi);
var MulticallAbi__default = /*#__PURE__*/_interopDefault(MulticallAbi);
var ISignatureMintERC20Abi__default = /*#__PURE__*/_interopDefault(ISignatureMintERC20Abi);
var IERC20MetadataAbi__default = /*#__PURE__*/_interopDefault(IERC20MetadataAbi);
var IBurnableERC721Abi__default = /*#__PURE__*/_interopDefault(IBurnableERC721Abi);
var IClaimableERC721__default = /*#__PURE__*/_interopDefault(IClaimableERC721);
var DelayedRevealAbi__default = /*#__PURE__*/_interopDefault(DelayedRevealAbi);
var DropERC721_V3Abi__default = /*#__PURE__*/_interopDefault(DropERC721_V3Abi);
var Erc721Abi__default = /*#__PURE__*/_interopDefault(Erc721Abi);
var Erc721EnumerableAbi__default = /*#__PURE__*/_interopDefault(Erc721EnumerableAbi);
var Erc721AQueryableAbi__default = /*#__PURE__*/_interopDefault(Erc721AQueryableAbi);
var Erc721SupplyAbi__default = /*#__PURE__*/_interopDefault(Erc721SupplyAbi);
var ILazyMintAbi__default = /*#__PURE__*/_interopDefault(ILazyMintAbi);
var IMintableERC721Abi__default = /*#__PURE__*/_interopDefault(IMintableERC721Abi);
var SignatureMintERC721Abi__default = /*#__PURE__*/_interopDefault(SignatureMintERC721Abi);
var SignatureMintERC721_V1Abi__default = /*#__PURE__*/_interopDefault(SignatureMintERC721_V1Abi);
var TieredDropAbi__default = /*#__PURE__*/_interopDefault(TieredDropAbi);
var SharedMetadataAbi__default = /*#__PURE__*/_interopDefault(SharedMetadataAbi);
var zora_IDropERC721__default = /*#__PURE__*/_interopDefault(zora_IDropERC721);
var ILoyaltyCardAbi__default = /*#__PURE__*/_interopDefault(ILoyaltyCardAbi);
var INFTMetadataAbi__default = /*#__PURE__*/_interopDefault(INFTMetadataAbi);
var IERC721MetadataAbi__default = /*#__PURE__*/_interopDefault(IERC721MetadataAbi);
var IBurnableERC1155Abi__default = /*#__PURE__*/_interopDefault(IBurnableERC1155Abi);
var IClaimableERC1155__default = /*#__PURE__*/_interopDefault(IClaimableERC1155);
var IDropMultiPhase1155__default = /*#__PURE__*/_interopDefault(IDropMultiPhase1155);
var DropERC1155_V2Abi__default = /*#__PURE__*/_interopDefault(DropERC1155_V2Abi);
var IDropSinglePhase1155__default = /*#__PURE__*/_interopDefault(IDropSinglePhase1155);
var IDropSinglePhase1155_V1__default = /*#__PURE__*/_interopDefault(IDropSinglePhase1155_V1);
var Erc1155Abi__default = /*#__PURE__*/_interopDefault(Erc1155Abi);
var Erc1155MetadataAbi__default = /*#__PURE__*/_interopDefault(Erc1155MetadataAbi);
var Erc1155SupplyAbi__default = /*#__PURE__*/_interopDefault(Erc1155SupplyAbi);
var Erc1155EnumerableAbi__default = /*#__PURE__*/_interopDefault(Erc1155EnumerableAbi);
var IMintableERC1155Abi__default = /*#__PURE__*/_interopDefault(IMintableERC1155Abi);
var ISignatureMintERC1155Abi__default = /*#__PURE__*/_interopDefault(ISignatureMintERC1155Abi);
var IERC2771ContextAbi__default = /*#__PURE__*/_interopDefault(IERC2771ContextAbi);
var IAppURI__default = /*#__PURE__*/_interopDefault(IAppURI);
var IContractMetadataAbi__default = /*#__PURE__*/_interopDefault(IContractMetadataAbi);
var IDirectListingsAbi__default = /*#__PURE__*/_interopDefault(IDirectListingsAbi);
var IEnglishAuctionsAbi__default = /*#__PURE__*/_interopDefault(IEnglishAuctionsAbi);
var IOffersAbi__default = /*#__PURE__*/_interopDefault(IOffersAbi);
var IPackVRFAbi__default = /*#__PURE__*/_interopDefault(IPackVRFAbi);
var IPermissionsAbi__default = /*#__PURE__*/_interopDefault(IPermissionsAbi);
var IPermissionsEnumerableAbi__default = /*#__PURE__*/_interopDefault(IPermissionsEnumerableAbi);
var IThirdwebPlatformFeeAbi__default = /*#__PURE__*/_interopDefault(IThirdwebPlatformFeeAbi);
var IThirdwebPrimarySaleAbi__default = /*#__PURE__*/_interopDefault(IThirdwebPrimarySaleAbi);
var IThirdwebRoyaltyAbi__default = /*#__PURE__*/_interopDefault(IThirdwebRoyaltyAbi);
var IOwnableAbi__default = /*#__PURE__*/_interopDefault(IOwnableAbi);
var IAirdropERC20__default = /*#__PURE__*/_interopDefault(IAirdropERC20);
var IAirdropERC721__default = /*#__PURE__*/_interopDefault(IAirdropERC721);
var IAirdropERC1155__default = /*#__PURE__*/_interopDefault(IAirdropERC1155);
var IAccountFactoryCore__default = /*#__PURE__*/_interopDefault(IAccountFactoryCore);
var IAccountPermissions__default = /*#__PURE__*/_interopDefault(IAccountPermissions);
var IAccountPermissionsV1__default = /*#__PURE__*/_interopDefault(IAccountPermissionsV1);
var IAccount__default = /*#__PURE__*/_interopDefault(IAccount);
var EventEmitter__default = /*#__PURE__*/_interopDefault(EventEmitter);

function getProcessEnv(key) {
  let defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
  if (typeof process !== "undefined") {
    if (process.env[key]) {
      return process.env[key];
    }
  }
  return defaultValue;
}

const ContractPublisher_address = "0xf5b896Ddb5146D5dA77efF4efBb3Eae36E300808"; // Polygon only

/**
 * @internal
 */
function getContractPublisherAddress() {
  return getProcessEnv("contractPublisherAddress", ContractPublisher_address);
}

/**
 * util function to check for signer, ripped out of ethers Signer.isProvider
 *
 * @param value - possible signer
 * @returns boolean if value is a signer
 * @internal
 */
function isSigner(value) {
  return !!(value && value._isSigner);
}

/**
 * util function to check for provider, ripped out of ethers providers.Provider.isProvider
 *
 * @param value - possible provider
 * @returns boolean if value is a provider
 * @internal
 */
function isProvider(value) {
  return !!(value && value._isProvider);
}

const DEFAULT_BATCH_TIME_LIMIT_MS = 10;
const DEFAULT_BATCH_SIZE_LIMIT = 200;
const DEFAULT_BATCH_OPTIONS = {
  timeLimitMs: DEFAULT_BATCH_TIME_LIMIT_MS,
  sizeLimit: DEFAULT_BATCH_SIZE_LIMIT
};
/**
 * mostly copied from ethers.js directly but make it a StaticJsonRpcProvider
 * @internal
 */
class StaticJsonRpcBatchProvider extends ethers.providers.StaticJsonRpcProvider {
  constructor(url, network) {
    let batchOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_BATCH_OPTIONS;
    super(url, network);
    this._timeLimitMs = batchOptions.timeLimitMs || DEFAULT_BATCH_TIME_LIMIT_MS;
    this._sizeLimit = batchOptions.sizeLimit || DEFAULT_BATCH_SIZE_LIMIT;
    this._pendingBatchAggregator = null;
    this._pendingBatch = null;
  }
  sendCurrentBatch(request) {
    // if we still have a timeout clear that first
    if (this._pendingBatchAggregator) {
      clearTimeout(this._pendingBatchAggregator);
    }
    // Get the current batch and clear it, so new requests
    // go into the next batch
    const batch = this._pendingBatch || [];
    this._pendingBatch = null;
    this._pendingBatchAggregator = null;

    // Get the request as an array of requests
    const request_ = batch.map(inflight => inflight.request);
    this.emit("debug", {
      action: "requestBatch",
      request: ethers.utils.deepCopy(request),
      provider: this
    });
    return ethers.utils.fetchJson(this.connection, JSON.stringify(request_)).then(result => {
      this.emit("debug", {
        action: "response",
        request: request_,
        response: result,
        provider: this
      });

      // For each result, feed it to the correct Promise, depending
      // on whether it was a success or error
      batch.forEach((inflightRequest_, index) => {
        const payload = result[index];

        // there may *not* be a payload for a given request (typically RPC error level)
        if (payload) {
          // if there is a payload, check for an error
          if (payload.error) {
            const error = new Error(payload.error.message);
            error.code = payload.error.code;
            error.data = payload.error.data;
            inflightRequest_.reject(error);
          } else {
            // if there's no error resolve the request
            inflightRequest_.resolve(payload.result);
          }
        } else {
          // if there is no payload, reject the request
          inflightRequest_.reject(new Error("No response for request"));
        }
      });
    }, error => {
      this.emit("debug", {
        action: "response",
        error: error,
        request: request_,
        provider: this
      });

      // If there was an error, reject all the requests
      batch.forEach(inflightRequest_ => {
        inflightRequest_.reject(error);
      });
    });
  }
  send(method, params) {
    const request = {
      method: method,
      params: params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    if (this._pendingBatch === null) {
      this._pendingBatch = [];
    }
    const inflightRequest = {
      request,
      resolve: null,
      reject: null
    };
    const promise = new Promise((resolve, reject) => {
      inflightRequest.resolve = resolve;
      inflightRequest.reject = reject;
    });
    this._pendingBatch.push(inflightRequest);

    // if we would go *over* the size limit of the batch with this request, send the batch now
    if (this._pendingBatch.length === this._sizeLimit) {
      this.sendCurrentBatch(request);
    }
    if (!this._pendingBatchAggregator) {
      // Schedule batch for next event loop + short duration
      this._pendingBatchAggregator = setTimeout(() => {
        this.sendCurrentBatch(request);
      }, this._timeLimitMs);
    }
    return promise;
  }
}

const ChainInfoInputSchema = /* @__PURE__ */(() => zod.z.object({
  rpc: zod.z.array(zod.z.string().url()),
  chainId: zod.z.number(),
  nativeCurrency: zod.z.object({
    name: zod.z.string(),
    symbol: zod.z.string(),
    decimals: zod.z.number()
  }),
  slug: zod.z.string()
}))();

/**
 * @public
 */
const SDKOptionsSchema = /* @__PURE__ */(() => zod.z.object({
  // @ts-expect-error - zod doesn't know anything about readonly
  supportedChains: zod.z.array(ChainInfoInputSchema).default(chains.defaultChains),
  clientId: zod.z.string().optional(),
  secretKey: zod.z.string().optional(),
  readonlySettings: zod.z.object({
    rpcUrl: zod.z.string().url(),
    chainId: zod.z.number().optional()
  }).optional(),
  gasSettings: zod.z.object({
    maxPriceInGwei: zod.z.number().min(1, "gas price cannot be less than 1").default(300),
    speed: zod.z.enum(["standard", "fast", "fastest"]).default("fastest")
  }).default({
    maxPriceInGwei: 300,
    speed: "fastest"
  }),
  gasless: zod.z.union([zod.z.object({
    openzeppelin: zod.z.object({
      relayerUrl: zod.z.string().url(),
      relayerForwarderAddress: zod.z.string().optional(),
      useEOAForwarder: zod.z.boolean().default(false),
      domainName: zod.z.string().default("GSNv2 Forwarder"),
      domainVersion: zod.z.string().default("0.0.1"),
      domainSeparatorVersion: zod.z.string().default("1")
    }),
    experimentalChainlessSupport: zod.z.boolean().default(false)
  }), zod.z.object({
    biconomy: zod.z.object({
      apiId: zod.z.string(),
      apiKey: zod.z.string(),
      deadlineSeconds: zod.z.number().min(1, "deadlineSeconds cannot be les than 1").default(3600)
    })
  }), zod.z.object({
    engine: zod.z.object({
      relayerUrl: zod.z.string().url().transform(url => url.replace(/\/$/, "")),
      relayerForwarderAddress: zod.z.string().optional(),
      domainName: zod.z.string().default("GSNv2 Forwarder"),
      domainVersion: zod.z.string().default("0.0.1"),
      domainSeparatorVersion: zod.z.string().default("1")
    }),
    experimentalChainlessSupport: zod.z.boolean().default(false)
  })]).optional(),
  gatewayUrls: zod.z.array(zod.z.string()).optional(),
  rpcBatchSettings: zod.z.object({
    sizeLimit: zod.z.number().default(200),
    timeLimit: zod.z.number().default(10)
  }).optional()
}).default({
  gasSettings: {
    maxPriceInGwei: 300,
    speed: "fastest"
  }
}))();

/**
 * @public
 * All these configuration options are optional with sane defaults:
 * @example
 * ```javascript
 * {
 *   readonlySettings: {
 *     rpcUrl, // force read calls to go through your own RPC url
 *     chainId, // reduce RPC calls by sepcifying your chain ID
 *   },
 *   gasSettings: {
 *     maxPriceInGwei, // Maximum gas price for transactions (default 300 gwei)
 *     speed, // the tx speed setting: 'standard'|'fast|'fastest' (default: 'fastest')
 *   },
 *   gasless: {
 *     // By specifying a gasless configuration - all transactions will get forwarded to enable gasless transactions
 *     openzeppelin: {
 *       relayerUrl, // your OZ Defender relayer URL
 *       relayerForwarderAddress, // the OZ defender relayer address (defaults to the standard one)
 *     },
 *     biconomy: {
 *       apiId, // your Biconomy API Id
 *       apiKey, // your Biconomy API Key
 *       deadlineSeconds, // your Biconomy timeout preference
 *     },
 *   },
 * }
 * ```
 */

/**
 * @internal
 */

/**
 * @public
 */

var pkg = {
	name: "@thirdweb-dev/sdk",
	version: "4.0.85",
	description: "The main thirdweb SDK.",
	repository: "https://github.com/thirdweb-dev/js/tree/main/legacy_packages/sdk",
	license: "Apache-2.0",
	main: "dist/thirdweb-dev-sdk.cjs.js",
	module: "dist/thirdweb-dev-sdk.esm.js",
	browser: {
		"./dist/thirdweb-dev-sdk.esm.js": "./dist/thirdweb-dev-sdk.browser.esm.js"
	},
	exports: {
		".": {
			module: {
				browser: "./dist/thirdweb-dev-sdk.browser.esm.js",
				"default": "./dist/thirdweb-dev-sdk.esm.js"
			},
			"default": "./dist/thirdweb-dev-sdk.cjs.js"
		},
		"./evm": {
			module: {
				browser: "./evm/dist/thirdweb-dev-sdk-evm.browser.esm.js",
				"default": "./evm/dist/thirdweb-dev-sdk-evm.esm.js"
			},
			"default": "./evm/dist/thirdweb-dev-sdk-evm.cjs.js"
		},
		"./evm/zksync": {
			module: {
				browser: "./evm/zksync/dist/thirdweb-dev-sdk-evm-zksync.browser.esm.js",
				"default": "./evm/zksync/dist/thirdweb-dev-sdk-evm-zksync.esm.js"
			},
			"default": "./evm/zksync/dist/thirdweb-dev-sdk-evm-zksync.cjs.js"
		},
		"./evm/functions": {
			module: {
				browser: "./evm/functions/dist/thirdweb-dev-sdk-evm-functions.browser.esm.js",
				"default": "./evm/functions/dist/thirdweb-dev-sdk-evm-functions.esm.js"
			},
			"default": "./evm/functions/dist/thirdweb-dev-sdk-evm-functions.cjs.js"
		},
		"./package.json": "./package.json"
	},
	files: [
		"dist/",
		"evm/",
		"server/"
	],
	preconstruct: {
		entrypoints: [
			"index.ts",
			"evm/index.ts",
			"evm/functions/index.ts",
			"evm/zksync/index.ts"
		],
		exports: {
			envConditions: [
				"browser"
			]
		}
	},
	sideEffects: false,
	scripts: {
		format: "prettier --write 'src/**/*'",
		lint: "eslint src/",
		fix: "eslint src/ --fix",
		clean: "rm -rf dist/",
		"generate-docs": "mkdir -p etc && pnpm generate-docs:evm && pnpm generate-snippets",
		"generate-docs:evm": "api-extractor run --local --config ./config/api-extractor-evm.json && api-documenter markdown -i ./temp -o ./docs/evm && rm -rf ./temp-evm && mv ./temp ./temp-evm",
		"generate-snippets": "node ./scripts/generate-snippets.mjs && node ./scripts/generate-feature-snippets-evm.mjs",
		build: "tsc && preconstruct build",
		"test:all": "SWC_NODE_PROJECT=./tsconfig.test.json nyc --reporter lcovonly --report-dir ./coverage/evm mocha --config './test/evm/.mocharc.json' --timeout 180000 --parallel './test/evm/**/*.test.ts'",
		test: "make test-evm",
		"test:single": "SWC_NODE_PROJECT=./tsconfig.test.json mocha --config './test/evm/.mocharc.json' --timeout 90000",
		push: "yalc push",
		typedoc: "node scripts/typedoc.mjs"
	},
	devDependencies: {
		"@aws-sdk/client-secrets-manager": "^3.549.0",
		"@ethersproject/abstract-provider": "^5.7.0",
		"@microsoft/api-documenter": "^7.24.5",
		"@microsoft/api-extractor": "^7.43.0",
		"@microsoft/tsdoc": "^0.14.2",
		"@nomiclabs/hardhat-ethers": "^2.2.3",
		"@preconstruct/cli": "2.7.0",
		"@swc-node/register": "^1.9.0",
		"@swc/core": "^1.4.12",
		"@thirdweb-dev/tsconfig": "^0.1.7",
		"@types/bn.js": "^5.1.5",
		"@types/chai": "^4.3.14",
		"@types/deep-equal-in-any-order": "^1.0.3",
		"@types/mocha": "^10.0.6",
		"@types/node": "20.12.7",
		"@types/uuid": "^9.0.8",
		chai: "^4.4.1",
		"deep-equal-in-any-order": "^1.1.20",
		"dotenv-mono": "^1.3.14",
		eslint: "8.57.0",
		"eslint-config-thirdweb": "^0.1.9",
		"eslint-plugin-better-tree-shaking": "0.0.4",
		"eslint-plugin-import": "^2.29.1",
		"eslint-plugin-inclusive-language": "^2.2.1",
		"eslint-plugin-prettier": "^5.1.3",
		"eslint-plugin-tsdoc": "^0.2.17",
		ethers: "^5.7.2",
		"ethers-aws-kms-signer": "^1.3.2",
		hardhat: "^2.22.2",
		mocha: "10.4.0",
		nyc: "^15.1.0",
		rimraf: "5.0.5",
		"typedoc-gen": "^1.0.2",
		typescript: "5.4.4",
		"zksync-ethers": "^5.7.0"
	},
	peerDependencies: {
		"@aws-sdk/client-secrets-manager": "^3.215.0",
		ethers: "^5",
		"ethers-aws-kms-signer": "^1.3.2",
		"zksync-ethers": "^5.6.0"
	},
	peerDependenciesMeta: {
		"@aws-sdk/client-secrets-manager": {
			optional: true
		},
		"ethers-aws-kms-signer": {
			optional: true
		},
		"zksync-ethers": {
			optional: true
		}
	},
	dependencies: {
		"@eth-optimism/sdk": "3.3.0",
		"@thirdweb-dev/chains": "0.1.111",
		"@thirdweb-dev/contracts-js": "1.3.23",
		"@thirdweb-dev/crypto": "0.2.6",
		"@thirdweb-dev/generated-abis": "0.0.2",
		"@thirdweb-dev/merkletree": "0.2.6",
		"@thirdweb-dev/storage": "2.0.15",
		abitype: "1.0.0",
		"bn.js": "5.2.1",
		bs58: "^5.0.0",
		buffer: "^6.0.3",
		eventemitter3: "^5.0.1",
		"fast-deep-equal": "^3.1.3",
		thirdweb: "5.22.1",
		"tiny-invariant": "^1.3.3",
		tweetnacl: "^1.0.3",
		uuid: "^9.0.1",
		yaml: "^2.4.1",
		zod: "^3.22.4"
	},
	bugs: {
		url: "https://github.com/thirdweb-dev/js/issues"
	},
	author: "thirdweb eng <eng@thirdweb.com>",
	engines: {
		node: ">=18"
	}
};

/**
 * @internal
 *
 * The code below comes from the package https://github.com/DamonOehlman/detect-browser
 */
const operatingSystemRules = [["iOS", /iP(hone|od|ad)/], ["Android OS", /Android/], ["BlackBerry OS", /BlackBerry|BB10/], ["Windows Mobile", /IEMobile/], ["Amazon OS", /Kindle/], ["Windows 3.11", /Win16/], ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/], ["Windows 98", /(Windows 98)|(Win98)/], ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/], ["Windows XP", /(Windows NT 5.1)|(Windows XP)/], ["Windows Server 2003", /(Windows NT 5.2)/], ["Windows Vista", /(Windows NT 6.0)/], ["Windows 7", /(Windows NT 6.1)/], ["Windows 8", /(Windows NT 6.2)/], ["Windows 8.1", /(Windows NT 6.3)/], ["Windows 10", /(Windows NT 10.0)/], ["Windows ME", /Windows ME/], ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/], ["Open BSD", /OpenBSD/], ["Sun OS", /SunOS/], ["Chrome OS", /CrOS/], ["Linux", /(Linux)|(X11)/], ["Mac OS", /(Mac_PowerPC)|(Macintosh)/], ["QNX", /QNX/], ["BeOS", /BeOS/], ["OS/2", /OS\/2/]];
function detectOS(ua) {
  for (let ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
    const result = operatingSystemRules[ii];
    if (!result) {
      continue;
    }
    const [os, regex] = result;
    const match = regex.exec(ua);
    if (match) {
      return os;
    }
  }
  return null;
}

function getOperatingSystem() {
  if (typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return "";
  } else if (typeof window !== "undefined") {
    const userAgent = navigator.userAgent;
    return detectOS(userAgent) || "";
  } else {
    return process.platform;
  }
}

function setAnalyticsHeaders(headers) {
  const globals = getAnalyticsGlobals();
  headers["x-sdk-version"] = globals.x_sdk_version;
  headers["x-sdk-name"] = globals.x_sdk_name;
  headers["x-sdk-platform"] = globals.x_sdk_platform;
  headers["x-sdk-os"] = globals.x_sdk_os;
}
function getAnalyticsHeaders() {
  const globals = getAnalyticsGlobals();
  return {
    "x-sdk-version": globals.x_sdk_version,
    "x-sdk-os": globals.x_sdk_os,
    "x-sdk-name": globals.x_sdk_name,
    "x-sdk-platform": globals.x_sdk_platform,
    ...(globals.app_bundle_id ? {
      "x-bundle-id": globals.app_bundle_id
    } : {})
  };
}
function getAnalyticsGlobals() {
  if (typeof globalThis === "undefined") {
    return {
      x_sdk_name: pkg.name,
      x_sdk_platform: getPlatform(),
      x_sdk_version: pkg.version,
      x_sdk_os: getOperatingSystem(),
      app_bundle_id: undefined
    };
  }
  if (globalThis.X_SDK_NAME === undefined) {
    globalThis.X_SDK_NAME = pkg.name;
    globalThis.X_SDK_PLATFORM = getPlatform();
    globalThis.X_SDK_VERSION = pkg.version;
    globalThis.X_SDK_OS = getOperatingSystem();
    globalThis.APP_BUNDLE_ID = undefined;
  }
  return {
    x_sdk_name: globalThis.X_SDK_NAME,
    x_sdk_platform: globalThis.X_SDK_PLATFORM,
    x_sdk_version: globalThis.X_SDK_VERSION,
    x_sdk_os: globalThis.X_SDK_OS,
    app_bundle_id: globalThis.APP_BUNDLE_ID || "" // if react, this will be empty
  };
}
function getPlatform() {
  return typeof navigator !== "undefined" && navigator.product === "ReactNative" ? "mobile" : typeof window !== "undefined" ? "browser" : "node";
}

/**
 * @internal
 */
function buildDefaultMap(options) {
  return options.supportedChains.reduce((previousValue, currentValue) => {
    // don't overwrite existing chains!
    if (!previousValue[currentValue.chainId]) {
      previousValue[currentValue.chainId] = currentValue;
    }
    return previousValue;
  }, {});
}

/**
 * Get an ethers provider for the specified network
 *
 * @internal
 */
function getChainProvider(network, sdkOptions) {
  // If we have an RPC URL, use that for the provider
  if (typeof network === "string" && isRpcUrl(network)) {
    return getProviderFromRpcUrl(network, sdkOptions);
  }

  // Add the chain to the supportedChains
  const options = SDKOptionsSchema.parse(sdkOptions);
  if (isChainConfig(network)) {
    options.supportedChains = [
    // @ts-expect-error - we know this is a chain and it will work to build the map
    network, ...options.supportedChains.filter(c => c.chainId === network.chainId)];
  }

  // Build a map of chainId -> ChainInfo based on the supportedChains
  const rpcMap = buildDefaultMap(options);
  let rpcUrl = "";
  let chainId;
  try {
    // Resolve the chain id from the network, which could be a chain, chain name, or chain id
    chainId = getChainIdFromNetwork(network, options);
    // Attempt to get the RPC url from the map based on the chainId
    rpcUrl = chains.getValidChainRPCs(rpcMap[chainId], options.clientId)[0];
  } catch (e) {
    // no-op
  }

  // if we still don't have an url fall back to just using the chainId or slug in the rpc and try that
  if (!rpcUrl) {
    rpcUrl = `https://${chainId || network}.rpc.thirdweb.com/${options.clientId || ""}`;
  }
  if (!rpcUrl) {
    throw new Error(`No rpc url found for chain ${network}. Please provide a valid rpc url via the 'supportedChains' property of the sdk options.`);
  }
  return getProviderFromRpcUrl(rpcUrl, sdkOptions, chainId);
}

/**
 * @internal
 */
function getChainIdFromNetwork(network, options) {
  if (isChainConfig(network)) {
    // If it's a chain just return the chain id
    return network.chainId;
  } else if (typeof network === "number") {
    // If it's a number (chainId) return it directly
    return network;
  } else {
    // If it's a string (chain name) return the chain id from the map
    const chainNameToId = options.supportedChains.reduce((acc, curr) => {
      acc[curr.slug] = curr.chainId;
      return acc;
    }, {});
    if (network in chainNameToId) {
      return chainNameToId[network];
    }
  }
  throw new Error(`Cannot resolve chainId from: ${network} - please pass the chainId instead and specify it in the 'supportedChains' property of the SDK options.`);
}

/**
 * @internal
 */
async function getChainIdOrName(network) {
  if (isChainConfig(network)) {
    // If it's a chain just return the chain id
    return network.chainId;
  } else if (typeof network === "number") {
    // If it's a number (chainId) return it directly
    return network;
  } else if (typeof network === "number") {
    // If it's a string (chain name) return the chain id from the map
    return network;
  } else if (isProvider(network)) {
    return network.getNetwork().then(n => n.chainId);
  } else if (isSigner(network)) {
    if (!network.provider) {
      throw new Error("Signer does not have a provider");
    }
    return network.provider.getNetwork().then(n => n.chainId);
  }
  throw new Error(`Cannot resolve chainId from: ${network}.`);
}

/**
 * Check whether a NetworkInput value is a Chain config (naively, without parsing)
 * @internal
 */
function isChainConfig(network) {
  return typeof network !== "string" && typeof network !== "number" && !isSigner(network) && !isProvider(network);
}

/**
 * Returns whether the specified url is a valid RPC url, as implemented by ethers.getDefaultProvier():
 * - https://github.com/ethers-io/ethers.js/blob/ec1b9583039a14a0e0fa15d0a2a6082a2f41cf5b/packages/providers/src.ts/index.ts#L55
 *
 * @param url - The url to check
 *
 * @internal
 */
function isRpcUrl(url) {
  const match = url.match(/^(ws|http)s?:/i);
  if (match) {
    switch (match[1].toLowerCase()) {
      case "http":
      case "https":
      case "ws":
      case "wss":
        return true;
    }
  }
  return false;
}
const RPC_PROVIDER_MAP = new Map();

/**
 * Get an ethers provider based on the specified RPC URL
 *
 * @param rpcUrl - The RPC URL
 * @param chainId - The optional chain ID
 * @returns The provider for the specified RPC URL
 *
 * @internal
 */
function getProviderFromRpcUrl(rpcUrl, sdkOptions, chainId) {
  try {
    const headers = {};
    // will be used to make sure we don't cache providers with different auth strategies
    let authStrategy = "none";
    if (isTwUrl(rpcUrl)) {
      // if we have a secret key passed in the SDK options we want to always use that
      if (sdkOptions?.secretKey) {
        // compute the clientId from the secret key
        // should only be used on Node.js in a backend/script context
        if (typeof window !== "undefined") {
          throw new Error("Cannot use secretKey in browser context");
        }
        const hashedSecretKey = crypto.sha256HexSync(sdkOptions.secretKey);
        const derivedClientId = hashedSecretKey.slice(0, 32);
        const utilizedRpcUrl = new URL(rpcUrl);
        // always set the clientId on the path to the derived client id
        utilizedRpcUrl.pathname = derivedClientId;
        // set the headers
        headers["x-client-id"] = derivedClientId;
        headers["x-secret-key"] = sdkOptions.secretKey;
        // set the final rpc url
        rpcUrl = utilizedRpcUrl.toString();
        authStrategy = "secretKey";
      }
      // if we do NOT have a secret key but we have a client id we want to use that
      else if (sdkOptions?.clientId) {
        const utilizedRpcUrl = new URL(rpcUrl);
        // always set the clientId on the path to the client id
        utilizedRpcUrl.pathname = sdkOptions.clientId;
        // set the headers
        headers["x-client-id"] = sdkOptions.clientId;
        // set the final rpc url
        rpcUrl = utilizedRpcUrl.toString();
        authStrategy = "clientId";
      }

      // if we *also* have a tw auth token on global context add it to the headers (in addition to anything else)
      if (typeof globalThis !== "undefined" && "TW_AUTH_TOKEN" in globalThis && typeof globalThis.TW_AUTH_TOKEN === "string") {
        headers["authorization"] = `Bearer ${globalThis.TW_AUTH_TOKEN}`;
        authStrategy = "twAuthToken";
      }
      if (typeof globalThis !== "undefined" && "TW_CLI_AUTH_TOKEN" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === "string") {
        headers["x-authorize-wallet"] = "true";
      }
      setAnalyticsHeaders(headers);
      const bundleId = typeof globalThis !== "undefined" && "APP_BUNDLE_ID" in globalThis ? globalThis.APP_BUNDLE_ID : undefined;
      if (!rpcUrl.includes("bundleId") && bundleId) {
        rpcUrl = rpcUrl + (bundleId ? `?bundleId=${bundleId}` : "");
      }
    }
    const match = rpcUrl.match(/^(ws|http)s?:/i);
    // Try the JSON batch provider if available
    if (match) {
      switch (match[1].toLowerCase()) {
        case "http":
        case "https":
          // Create a unique cache key for these params
          const seralizedOpts = `${rpcUrl}-${chainId || -1}-${authStrategy}`;

          // Check if we have a provider in our cache already
          const existingProvider = RPC_PROVIDER_MAP.get(seralizedOpts);
          if (existingProvider) {
            return existingProvider;
          }

          // TODO: remove below `skipFetchSetup` logic when ethers.js v6 support arrives
          let _skipFetchSetup = false;
          if (typeof globalThis !== "undefined" && "TW_SKIP_FETCH_SETUP" in globalThis && typeof globalThis.TW_SKIP_FETCH_SETUP === "boolean") {
            _skipFetchSetup = globalThis.TW_SKIP_FETCH_SETUP;
          }

          // Otherwise, create a new provider on the specific network
          const newProvider = chainId ?
          // If we know the chainId we should use the StaticJsonRpcBatchProvider
          new StaticJsonRpcBatchProvider({
            url: rpcUrl,
            headers,
            skipFetchSetup: _skipFetchSetup
          }, chainId, sdkOptions?.rpcBatchSettings) :
          // Otherwise fall back to the built in json rpc batch provider
          new ethers.providers.JsonRpcBatchProvider({
            url: rpcUrl,
            headers,
            skipFetchSetup: _skipFetchSetup
          });

          // Save the provider in our cache
          RPC_PROVIDER_MAP.set(seralizedOpts, newProvider);
          return newProvider;
        case "ws":
        case "wss":
          // Use the WebSocketProvider for ws:// URLs
          // TODO: handle auth for WS at some point
          return new ethers.providers.WebSocketProvider(rpcUrl, chainId);
      }
    }
  } catch (e) {
    // no-op
  }

  // Always fallback to the default provider if no other option worked
  return ethers.providers.getDefaultProvider(rpcUrl);
}

// TODO move to utils package
function isTwUrl(url) {
  return new URL(url).hostname.endsWith(".thirdweb.com");
}

/**
 * @internal
 */
function getSignerAndProvider(network, options) {
  let signer;
  let provider;
  if (isSigner(network)) {
    // Here, we have an ethers.Signer
    signer = network;
    if (network.provider) {
      provider = network.provider;
    }
  } else if (isProvider(network)) {
    // Here, we have an ethers.providers.Provider
    provider = network;
  } else {
    // Here, we must have a ChainOrRpcUrl, which is a chain name, chain id, rpc url, or chain config
    // All of which, getChainProvider can handle for us
    provider = getChainProvider(network, options);
  }
  if (options?.readonlySettings) {
    // If readonly settings are specified, then overwrite the provider
    provider = getProviderFromRpcUrl(options.readonlySettings.rpcUrl, options, options.readonlySettings.chainId);
  }

  // At this point, if we don't have a provider, don't default to a random chain
  // Instead, just throw an error
  if (!provider) {
    if (signer) {
      throw new Error("No provider passed to the SDK! Please make sure that your signer is connected to a provider!");
    }
    throw new Error("No provider found! Make sure to specify which network to connect to, or pass a signer or provider to the SDK!");
  }
  return [signer, provider];
}

// TODO: Respect SDK RPC configuration and don't pull straight from ethers
let provider;
const ENS_CACHE = new Map();

/**
 * @internal
 */
async function resolveEns(ens) {
  let depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  if (!provider) {
    // if we don't already have a provider then get one
    provider = getSignerAndProvider("ethereum")[1];
  }
  let ensPromise;
  if (ENS_CACHE.has(ens)) {
    ensPromise = ENS_CACHE.get(ens);
  } else {
    ensPromise = provider.resolveName(ens).then(address => {
      // If they don't have an ENS, only cache for 30s
      if (!address) {
        return {
          address: null,
          expirationTime: new Date(Date.now() + 1000 * 30)
        };
      }

      // Cache ENS for 1 hour
      return {
        address,
        expirationTime: new Date(Date.now() + 1000 * 60 * 5)
      };
    });
  }
  const resolvedPromise = await ensPromise;
  if (resolvedPromise.expirationTime < new Date()) {
    // delete the cache if it's expired
    ENS_CACHE.delete(ens);
    // then call ourselves again to refresh the cache, but don't block on the result
    if (depth === 0) {
      resolveEns(ens, depth + 1);
    }
  }
  return resolvedPromise.address;
}

// Only pass through to provider call if value ends with .eth or .cb.id
const EnsSchema = /* @__PURE__ */(() => zod.z.custom(ens => typeof ens === "string" && (ens.endsWith(".eth") || ens.endsWith(".cb.id"))).transform(async ens => resolveEns(ens)).refine(address => !!address && ethers.utils.isAddress(address), {
  message: "Provided value was not a valid ENS name"
}))();

const AddressSchema = /* @__PURE__ */(() => zod.z.custom(address => typeof address === "string" && ethers.utils.isAddress(address), out => {
  return {
    message: `${out} is not a valid address`
  };
}))();

// Important for address check to come before ENS so network request is only made when necessary
const AddressOrEnsSchema = /* @__PURE__ */(() => zod.z.union([AddressSchema, EnsSchema], {
  invalid_type_error: "Provided value was not a valid address or ENS name"
}))();

// Use this everywhere even though it's just string so we can optionally switch it out
// more easily if we want to later

async function resolveAddress(addressOrEns) {
  return AddressOrEnsSchema.parseAsync(addressOrEns);
}

/**
 * @internal
 */
const isBrowser$1 = () => typeof window !== "undefined";
/**
 * @internal
 */
const FileOrBufferUnionSchema = /* @__PURE__ */(() => isBrowser$1() ? zod.z.instanceof(File) :
// @fixme, this is a hack to make browser happy for now
zod.z.instanceof(Buffer))();

/**
 * @internal
 */
const FileOrBufferSchema = /* @__PURE__ */(() => zod.z.union([FileOrBufferUnionSchema, zod.z.object({
  data: zod.z.union([FileOrBufferUnionSchema, zod.z.string()]),
  name: zod.z.string()
})]))();

/**
 * @internal
 */
const FileOrBufferOrStringSchema = /* @__PURE__ */(() => zod.z.union([FileOrBufferSchema, zod.z.string()]))();
const MAX_BPS = 10000;
const BytesLikeSchema = /* @__PURE__ */(() => zod.z.union([zod.z.array(zod.z.number()), zod.z.string()]))();
const BigNumberTransformSchema$1 = /* @__PURE__ */(() => zod.z.union([zod.z.bigint(), zod.z.custom(data => {
  return ethers.BigNumber.isBigNumber(data);
}), zod.z.custom(data => {
  return BN__default["default"].isBN(data);
})]).transform(arg => {
  if (BN__default["default"].isBN(arg)) {
    return new BN__default["default"](arg).toString();
  }
  return ethers.BigNumber.from(arg).toString();
}))();
const BasisPointsSchema = /* @__PURE__ */(() => zod.z.number().max(MAX_BPS, "Cannot exceed 100%").min(0, "Cannot be below 0%"))();
const PercentSchema = /* @__PURE__ */(() => zod.z.number().max(100, "Cannot exceed 100%").min(0, "Cannot be below 0%"))();
const HexColor = /* @__PURE__ */(() => zod.z.union([zod.z.string().regex(/^([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/, "Invalid hex color"), zod.z.string().regex(/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/, "Invalid hex color").transform(val => val.replace("#", "")), zod.z.string().length(0)]))();
const AmountSchema = /* @__PURE__ */(() => zod.z.union([zod.z.string().regex(/^([0-9]+\.?[0-9]*|\.[0-9]+)$/, "Invalid amount"), zod.z.number().min(0, "Amount cannot be negative")]).transform(arg => typeof arg === "number" ? arg.toString() : arg))();

/**
 * @internal
 */

/**
 * @internal
 */
const QuantitySchema = /* @__PURE__ */(() => zod.z.union([AmountSchema, zod.z.literal("unlimited")]).default("unlimited"))();

const MAX_LENGTH = 256;
const NUMERIC_IDENTIFIER = "0|[1-9]\\d*";
const MAIN_VERSION_IDENTIFIER = `(${NUMERIC_IDENTIFIER})\\.(${NUMERIC_IDENTIFIER})\\.(${NUMERIC_IDENTIFIER})`;
const REGEX_MAIN_VERSION = new RegExp(MAIN_VERSION_IDENTIFIER);

/**
 * @internal
 */

/**
 * @internal
 * @param version - The version to convert to a Semver
 */
function toSemver(version) {
  if (version.length > MAX_LENGTH) {
    throw new Error(`version is longer than ${MAX_LENGTH} characters`);
  }
  const matches = version.trim().match(REGEX_MAIN_VERSION);
  if (!matches || matches?.length !== 4) {
    throw new Error(`${version} is not a valid semantic version. Should be in the format of major.minor.patch. Ex: 0.4.1`);
  }
  const major = Number(matches[1]);
  const minor = Number(matches[2]);
  const patch = Number(matches[3]);
  const versionString = [major, minor, patch].join(".");
  return {
    major,
    minor,
    patch,
    versionString
  };
}

/**
 * @internal
 * @param current - The current version
 * @param next - The next version
 */
function isIncrementalVersion(current, next) {
  const currentSemver = toSemver(current);
  const nextSemver = toSemver(next);
  if (nextSemver.major > currentSemver.major) {
    return true;
  }
  const eqMajor = nextSemver.major === currentSemver.major;
  if (eqMajor && nextSemver.minor > currentSemver.minor) {
    return true;
  }
  const eqMinor = nextSemver.minor === currentSemver.minor;
  return eqMajor && eqMinor && nextSemver.patch > currentSemver.patch;
}

/**
 * @internal
 */
function isDowngradeVersion(current, next) {
  const currentSemver = toSemver(current);
  const nextSemver = toSemver(next);
  if (nextSemver.major < currentSemver.major) {
    return true;
  }
  const eqMajor = nextSemver.major === currentSemver.major;
  if (eqMajor && nextSemver.minor < currentSemver.minor) {
    return true;
  }
  const eqMinor = nextSemver.minor === currentSemver.minor;
  return eqMajor && eqMinor && nextSemver.patch < currentSemver.patch;
}

const BigNumberSchema = /* @__PURE__ */(() => zod.z.union([zod.z.string(), zod.z.number(), zod.z.bigint(), zod.z.custom(data => {
  return ethers.BigNumber.isBigNumber(data);
})]).transform(arg => ethers.BigNumber.from(arg)))();
const BigNumberishSchema = /* @__PURE__ */(() => BigNumberSchema.transform(arg => arg.toString()))();
const BigNumberTransformSchema = /* @__PURE__ */(() => zod.z.union([zod.z.bigint(), zod.z.custom(data => {
  return ethers.BigNumber.isBigNumber(data);
})]).transform(arg => {
  return ethers.BigNumber.from(arg).toString();
}))();

/**
 * @internal
 */
const CommonContractSchema = /* @__PURE__ */(() => zod.z.object({
  name: zod.z.string(),
  description: zod.z.string().optional(),
  image: FileOrBufferOrStringSchema.optional(),
  external_link: zod.z.string().optional(),
  app_uri: zod.z.string().optional(),
  social_urls: zod.z.record(zod.z.string()).optional(),
  defaultAdmin: AddressOrEnsSchema.optional()
}).catchall(zod.z.unknown()))();
/**
 * @internal
 */
const CommonContractOutputSchema = /* @__PURE__ */(() => CommonContractSchema.extend({
  image: zod.z.string().optional()
}).catchall(zod.z.unknown()))();

/**
 * @internal
 */
const CommonRoyaltySchema = /* @__PURE__ */(() => zod.z.object({
  /**
   * The amount of royalty collected on all royalties represented as basis points.
   * The default is 0 (no royalties).
   *
   * 1 basis point = 0.01%
   *
   * For example: if this value is 100, then the royalty is 1% of the total sales.
   *
   * @internal
   * @remarks used by OpenSea "seller_fee_basis_points"
   */
  seller_fee_basis_points: BasisPointsSchema.default(0),
  /**
   * The address of the royalty recipient. All royalties will be sent
   * to this address.
   * @internal
   * @remarks used by OpenSea "fee_recipient"
   */
  fee_recipient: AddressOrEnsSchema.default(ethers.constants.AddressZero)
}))();

/**
 * @internal
 */
const CommonPrimarySaleSchema = /* @__PURE__ */(() => zod.z.object({
  /**
   * primary sale recipient address
   */
  primary_sale_recipient: AddressOrEnsSchema.default(ethers.constants.AddressZero)
}))();

/**
 * @internal
 */
const CommonPlatformFeeSchema = /* @__PURE__ */(() => zod.z.object({
  /**
   * platform fee basis points
   */
  platform_fee_basis_points: BasisPointsSchema.default(0),
  /**
   * platform fee recipient address
   */
  platform_fee_recipient: AddressOrEnsSchema.default(ethers.constants.AddressZero)
}))();

/**
 * @internal
 */
const CommonTrustedForwarderSchema = /* @__PURE__ */(() => zod.z.object({
  trusted_forwarders: zod.z.array(AddressOrEnsSchema).default([])
}))();

/**
 * @internal
 */
const CommonSymbolSchema = /* @__PURE__ */(() => zod.z.object({
  symbol: zod.z.string().default("")
}))();

/**
 * @internal
 */
const MerkleSchema = /* @__PURE__ */(() => zod.z.object({
  merkle: zod.z.record(zod.z.string()).default({})
}))();
const SnapshotEntryInput = /* @__PURE__ */(() => zod.z.object({
  address: AddressOrEnsSchema,
  maxClaimable: QuantitySchema.default(0),
  // defaults to 0
  price: QuantitySchema.optional(),
  // defaults to unlimited, but can be undefined in old snapshots
  currencyAddress: AddressOrEnsSchema.default(ethers.constants.AddressZero).optional() // defaults to AddressZero, but can be undefined for old snapshots
}))();
/**
 * @internal
 */
const SnapshotInputSchema = /* @__PURE__ */(() => zod.z.union([zod.z.array(zod.z.string()).transform(async strings => await Promise.all(strings.map(address => SnapshotEntryInput.parseAsync({
  address
})))), zod.z.array(SnapshotEntryInput)]))();
const SnapshotEntryWithProofSchema = /* @__PURE__ */(() => SnapshotEntryInput.extend({
  proof: zod.z.array(zod.z.string())
}))();

/**
 * @internal
 */
const SnapshotSchema = /* @__PURE__ */(() => zod.z.object({
  /**
   * The merkle root
   */
  merkleRoot: zod.z.string(),
  claims: zod.z.array(SnapshotEntryWithProofSchema)
}))();

/**
 * @internal
 */

/**
 * @internal
 */
const SnapshotInfoSchema = /* @__PURE__ */(() => zod.z.object({
  merkleRoot: zod.z.string(),
  snapshotUri: zod.z.string()
}))();

/**
 * @internal
 */
const BYOCContractMetadataSchema = /* @__PURE__ */(() => CommonContractSchema.catchall(zod.z.union([BigNumberTransformSchema, zod.z.unknown()])))();

/**
 * @internal
 */

/**
 * @internal
 */
const CustomContractInput = /* @__PURE__ */(() => BYOCContractMetadataSchema.merge(CommonRoyaltySchema.merge(MerkleSchema).merge(CommonSymbolSchema).partial()).catchall(zod.z.any()))();

/**
 * @internal
 */
const CustomContractOutput = /* @__PURE__ */(() => CommonContractOutputSchema.merge(CommonRoyaltySchema.merge(MerkleSchema).merge(CommonSymbolSchema).partial()).catchall(zod.z.any()))();

/**
 * @internal
 */
const CustomContractDeploy = /* @__PURE__ */(() => CustomContractInput.merge(CommonPlatformFeeSchema.merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema).partial()))();

/**
 * @internal
 */
const CustomContractSchema = {
  deploy: CustomContractDeploy,
  output: CustomContractOutput,
  input: CustomContractInput
};

/**
 * @internal
 */
const AbiTypeBaseSchema = /* @__PURE__ */(() => zod.z.object({
  type: zod.z.string(),
  name: zod.z.string().default("")
}).catchall(zod.z.any()))();

/**
 * @internal
 */
const AbiTypeSchema = /* @__PURE__ */(() => AbiTypeBaseSchema.extend({
  stateMutability: zod.z.string().optional(),
  components: zod.z.array(AbiTypeBaseSchema).optional()
}).catchall(zod.z.any()))();

/**
 * @internal
 */
const AbiObjectSchema = /* @__PURE__ */(() => zod.z.object({
  type: zod.z.string(),
  name: zod.z.string().default(""),
  inputs: zod.z.array(AbiTypeSchema).default([]),
  outputs: zod.z.array(AbiTypeSchema).default([])
}).catchall(zod.z.any()))();

/**
 * @internal
 */
const AbiSchema = /* @__PURE__ */(() => zod.z.array(AbiObjectSchema))();
// if we want to statically type this for external usage it has to *awlways* be the output type

// input type is only used internally
/**
 * @internal
 */

/**
 * @internal
 */
const CompilerTypeInput = /* @__PURE__ */(() => zod.z.union([zod.z.literal("solc"), zod.z.literal("zksolc")]))();
/**
 * @internal
 */
const PreDeployMetadata = /* @__PURE__ */(() => zod.z.object({
  name: zod.z.string(),
  metadataUri: zod.z.string(),
  bytecodeUri: zod.z.string(),
  analytics: zod.z.any().optional(),
  compilers: zod.z.record(CompilerTypeInput,
  // z.record(
  zod.z.array(zod.z.object({
    compilerVersion: zod.z.string().optional(),
    evmVersion: zod.z.string().optional(),
    metadataUri: zod.z.string(),
    bytecodeUri: zod.z.string()
  }))
  // ),
  ).optional()
}).catchall(zod.z.any()))();

/**
 * @internal
 */
const ChainIdToAddressSchema = /* @__PURE__ */(() => zod.z.record(zod.z.string(), zod.z.string()))();

/**
 * @internal
 */
const CustomFactoryInput = /* @__PURE__ */(() => zod.z.object({
  factoryFunction: zod.z.string(),
  params: zod.z.array(zod.z.object({
    name: zod.z.string(),
    type: zod.z.string()
  })).default([]),
  customFactoryAddresses: ChainIdToAddressSchema
}))();

/**
 * @internal
 */
const FactoryDeploymentSchema = /* @__PURE__ */(() => zod.z.object({
  implementationAddresses: ChainIdToAddressSchema,
  implementationInitializerFunction: zod.z.string().default("initialize"),
  customFactoryInput: CustomFactoryInput.optional(),
  factoryAddresses: ChainIdToAddressSchema.optional()
}))();

/**
 * @internal
 */
const DeployTypeInput = /* @__PURE__ */(() => zod.z.union([zod.z.literal("standard"), zod.z.literal("autoFactory"), zod.z.literal("customFactory")]))();

/**
 * @internal
 */
const RouterTypeInput = /* @__PURE__ */(() => zod.z.union([zod.z.literal("none"), zod.z.literal("plugin"), zod.z.literal("dynamic")]))();

/**
 * @internal
 */
const DeploymentNetworkInput = /* @__PURE__ */(() => zod.z.object({
  allNetworks: zod.z.boolean().optional(),
  networksEnabled: zod.z.array(zod.z.number()).default([])
}))();

/**
 * @internal
 */
const ExtraPublishMetadataSchemaInput = /* @__PURE__ */(() => zod.z.object({
  version: zod.z.string().refine(v => {
    try {
      toSemver(v);
      return true;
    } catch (e) {
      return false;
    }
  }, out => {
    return {
      message: `'${out}' is not a valid semantic version. Should be in the format of major.minor.patch. Ex: 0.4.1`
    };
  }),
  displayName: zod.z.string().optional(),
  description: zod.z.string().optional(),
  externalLinks: zod.z.array(zod.z.object({
    name: zod.z.string(),
    url: zod.z.string()
  })).optional(),
  readme: zod.z.string().optional(),
  license: zod.z.string().optional(),
  changelog: zod.z.string().optional(),
  tags: zod.z.array(zod.z.string()).optional(),
  audit: FileOrBufferOrStringSchema.nullable().optional(),
  logo: FileOrBufferOrStringSchema.nullable().optional(),
  isDeployableViaFactory: zod.z.boolean().optional(),
  isDeployableViaProxy: zod.z.boolean().optional(),
  factoryDeploymentData: FactoryDeploymentSchema.optional(),
  deployType: DeployTypeInput.optional(),
  routerType: RouterTypeInput.optional(),
  defaultExtensions: zod.z.array(zod.z.object({
    extensionName: zod.z.string(),
    extensionVersion: zod.z.string().default("latest"),
    publisherAddress: AddressOrEnsSchema
  })).optional(),
  networksForDeployment: DeploymentNetworkInput.optional(),
  constructorParams: zod.z.record(zod.z.string(), zod.z.object({
    displayName: zod.z.string().optional(),
    description: zod.z.string().optional(),
    defaultValue: zod.z.string().optional(),
    hidden: zod.z.boolean().optional()
  }).catchall(zod.z.any())).optional(),
  compositeAbi: AbiSchema.optional()
}).catchall(zod.z.any()))();

/**
 * @internal
 */
const ExtraPublishMetadataSchemaOutput = /* @__PURE__ */(() => ExtraPublishMetadataSchemaInput.extend({
  audit: zod.z.string().nullable().optional(),
  logo: zod.z.string().nullable().optional()
}))();
/**
 * @internal
 */
const FullPublishMetadataSchemaInput = /* @__PURE__ */(() => PreDeployMetadata.merge(ExtraPublishMetadataSchemaInput).extend({
  publisher: AddressOrEnsSchema.optional()
}))();

/**
 * @internal
 */
const FullPublishMetadataSchemaOutput = /* @__PURE__ */(() => PreDeployMetadata.merge(ExtraPublishMetadataSchemaOutput).extend({
  publisher: AddressOrEnsSchema.optional()
}))();
/**
 * @internal
 */
const ProfileSchemaInput = /* @__PURE__ */(() => zod.z.object({
  name: zod.z.string().optional(),
  bio: zod.z.string().optional(),
  avatar: FileOrBufferOrStringSchema.nullable().optional(),
  website: zod.z.string().optional(),
  twitter: zod.z.string().optional(),
  telegram: zod.z.string().optional(),
  facebook: zod.z.string().optional(),
  github: zod.z.string().optional(),
  medium: zod.z.string().optional(),
  linkedin: zod.z.string().optional(),
  reddit: zod.z.string().optional(),
  discord: zod.z.string().optional()
}))();
const ProfileSchemaOutput = /* @__PURE__ */(() => ProfileSchemaInput.extend({
  avatar: zod.z.string().nullable().optional()
}))();
/**
 * @internal
 */
const PublishedContractSchema = /* @__PURE__ */(() => zod.z.object({
  id: zod.z.string(),
  timestamp: BigNumberishSchema,
  metadataUri: zod.z.string()
}))();

/**
 * @internal
 * Follows https://docs.soliditylang.org/en/v0.8.15/natspec-format.html
 */
const ContractInfoSchema = /* @__PURE__ */(() => zod.z.object({
  title: zod.z.string().optional(),
  author: zod.z.string().optional(),
  details: zod.z.string().optional(),
  notice: zod.z.string().optional()
}))();

/**
 * @internal
 */
const CompilerMetadataFetchedSchema = /* @__PURE__ */(() => zod.z.object({
  name: zod.z.string(),
  abi: AbiSchema,
  metadata: zod.z.record(zod.z.string(), zod.z.any()),
  info: ContractInfoSchema,
  licenses: zod.z.array(zod.z.string().optional()).default([]).transform(v => {
    return v.filter(license => license !== undefined);
  }),
  isPartialAbi: zod.z.boolean().optional()
}))();

/**
 * @internal
 */
const PreDeployMetadataFetchedSchema = /* @__PURE__ */(() => PreDeployMetadata.merge(CompilerMetadataFetchedSchema).extend({
  bytecode: zod.z.string(),
  fetchedMetadataUri: zod.z.string(),
  fetchedBytecodeUri: zod.z.string()
}))();

/**
 * Fetch and parse the full metadata AFTER publishing a contract, with all the extra information (version, readme, etc)
 * @internal
 * @param publishMetadataUri - The publish metadata URI to fetch
 * @param storage - The storage to use
 */
async function fetchExtendedReleaseMetadata(publishMetadataUri, storage) {
  const meta = await (await storage.download(publishMetadataUri)).text();
  return FullPublishMetadataSchemaOutput.parse(JSON.parse(meta));
}

const CONTRACT_METADATA_TIMEOUT_SEC = 2;

/**
 * @internal
 * @param compilerMetadataUri - The compiler metadata URI to fetch
 * @param storage - The storage to use
 */
async function fetchContractMetadata(compilerMetadataUri, storage) {
  // short timeout to avoid hanging on unpinned contract metadata CIDs
  const metadata = await storage.downloadJSON(compilerMetadataUri, {
    timeoutInSeconds: CONTRACT_METADATA_TIMEOUT_SEC
  });
  if (!metadata || !metadata.output) {
    throw new Error(`Could not resolve metadata for contract at ${compilerMetadataUri}`);
  }
  return formatCompilerMetadata(metadata);
}

/**
 * @internal
 */
function formatCompilerMetadata(metadata) {
  const abi = AbiSchema.parse(metadata.output.abi);
  const compilationTarget = metadata.settings.compilationTarget;
  const targets = Object.keys(compilationTarget);
  const name = compilationTarget[targets[0]];
  const info = ContractInfoSchema.parse({
    title: metadata.output.devdoc.title,
    author: metadata.output.devdoc.author,
    details: metadata.output.devdoc.detail,
    notice: metadata.output.userdoc.notice
  });
  const licenses = [...new Set(Object.entries(metadata.sources).map(_ref => {
    let [, src] = _ref;
    return src.license;
  }))];
  return {
    name,
    abi,
    metadata,
    info,
    licenses,
    isPartialAbi: metadata.isPartialAbi
  };
}

/**
 * @internal
 * @param publishMetadataUri - The publish metadata URI to fetch
 * @param storage - The storage to use
 */
async function fetchRawPredeployMetadata(publishMetadataUri, storage) {
  return PreDeployMetadata.parse(JSON.parse(await (await storage.download(publishMetadataUri)).text()));
}

/**
 * Fetch the metadata coming from CLI, this is before deploying or releasing the contract.
 * @internal
 * @param publishMetadataUri - The publish metadata URI to fetch
 * @param storage - The storage to use
 */
async function fetchPreDeployMetadata(publishMetadataUri, storage, compilerOptions) {
  const rawMeta = await fetchRawPredeployMetadata(publishMetadataUri, storage);
  let bytecodeUri;
  let metadataUri;

  // TODO: Add an invariant, throw if no compilers in rawMeta in case compilerOptions are provided.
  // Keeping it this way until all contracts are republished with new metadata.
  if (compilerOptions && rawMeta.compilers) {
    let metadata;
    switch (compilerOptions.compilerType) {
      case "solc":
        {
          if (compilerOptions.compilerVersion) {
            metadata = rawMeta.compilers.solc?.find(m => m.compilerVersion === compilerOptions.compilerVersion && m.evmVersion === compilerOptions.evmVersion);
          } else if (rawMeta.compilers.solc) {
            const len = rawMeta.compilers.solc.length;
            metadata = rawMeta.compilers.solc[len - 1];
          }
          break;
        }
      case "zksolc":
        {
          if (compilerOptions.compilerVersion) {
            metadata = rawMeta.compilers.zksolc?.find(m => m.compilerVersion === compilerOptions.compilerVersion && m.evmVersion === compilerOptions.evmVersion);
          } else if (rawMeta.compilers.zksolc) {
            const len = rawMeta.compilers.zksolc.length;
            metadata = rawMeta.compilers.zksolc[len - 1];
          }
          break;
        }
    }
    invariant__default["default"](metadata, "Compiler or EVM version not found");
    bytecodeUri = metadata.bytecodeUri;
    metadataUri = metadata.metadataUri;
  } else {
    bytecodeUri = rawMeta.bytecodeUri;
    metadataUri = rawMeta.metadataUri;
  }
  const [deployBytecode, parsedMeta] = await Promise.all([storage.download(bytecodeUri), fetchContractMetadata(metadataUri, storage)]);
  return PreDeployMetadataFetchedSchema.parse({
    ...rawMeta,
    ...parsedMeta,
    bytecode: await deployBytecode.text(),
    fetchedMetadataUri: metadataUri,
    fetchedBytecodeUri: bytecodeUri
  });
}

/**
 * @internal
 */
const isBrowser = () => typeof window !== "undefined";

/**
 * @internal
 */
const isNode = () => !isBrowser();

/**
 * @internal
 */
function unique(a, fn) {
  if (a.length === 0 || a.length === 1) {
    return a;
  }
  if (!fn) {
    return a;
  }
  for (let i = 0; i < a.length; i++) {
    for (let j = i + 1; j < a.length; j++) {
      if (fn(a[i], a[j])) {
        a.splice(j, 1);
        j--;
      }
    }
  }
  return a;
}

/**
 * @internal
 */
function createLruCache(maxEntries) {
  let store = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Map();
  function put(key, value) {
    if (store.size >= maxEntries) {
      const keyToDelete = store.keys().next().value;
      store.delete(keyToDelete);
    }
    store.set(key, value);
  }
  function get(key) {
    const hasKey = store.has(key);
    if (!hasKey) {
      return undefined;
    }
    const entry = store.get(key);
    store.delete(key);
    store.set(key, entry);
    return entry;
  }
  function has(key) {
    return store.has(key);
  }
  return {
    put,
    get,
    has,
    maxEntries,
    store
  };
}

const deployMetadataCache = /* @__PURE__ */createLruCache(20);

/**
 * @internal
 */
async function fetchAndCacheDeployMetadata(publishMetadataUri, storage, compilerOptions) {
  const compiler = compilerOptions ? `${compilerOptions.compilerType}_${compilerOptions.compilerVersion || ""}_${compilerOptions.evmVersion || ""}
  ` : "default";
  const cacheKey = `${compiler}_${publishMetadataUri}`;
  const cached = deployMetadataCache.get(cacheKey);
  if (cached) {
    return cached;
  }
  const compilerMetadata = await fetchPreDeployMetadata(publishMetadataUri, storage, compilerOptions);
  let extendedMetadata;
  try {
    extendedMetadata = await fetchExtendedReleaseMetadata(publishMetadataUri, storage);
  } catch (e) {
    // not a factory deployment, ignore
  }
  const data = {
    compilerMetadata,
    extendedMetadata
  };
  deployMetadataCache.put(cacheKey, data);
  return data;
}

// @ts-expect-error - readonly vs not
let supportedChains = chains.defaultChains;

/**
 * @internal
 */
function setSupportedChains(chains$1) {
  if (chains$1 && chains$1.length > 0) {
    supportedChains = chains$1;
  } else {
    // @ts-expect-error - readonly vs not
    supportedChains = chains.defaultChains;
  }
}

/**
 * @internal
 */
function getSupportedChains() {
  return supportedChains;
}

const THIRDWEB_DEPLOYER = "0xdd99b75f095d0c4d5112aCe938e4e6ed962fb024";

/**
 * @internal
 */
async function fetchPublishedContractFromPolygon(publisherAddress, contractName) {
  let version = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "latest";
  let storage = arguments.length > 3 ? arguments[3] : undefined;
  let clientId = arguments.length > 4 ? arguments[4] : undefined;
  let secretKey = arguments.length > 5 ? arguments[5] : undefined;
  const polygonChain = getSupportedChains().find(c => c.chainId === 137);
  const chain = polygonChain || chains.Polygon;
  const publisher = await resolveAddress(publisherAddress);
  const ContractPublisherAbi = (await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@thirdweb-dev/contracts-js/dist/abis/ContractPublisher.json')); })).default;
  const contract = new ethers.Contract(getContractPublisherAddress(), ContractPublisherAbi, getChainProvider(chain, {
    clientId,
    secretKey
  }));
  let publishedContract;
  if (!version || version === "latest") {
    const model = await contract.getPublishedContract(publisher, contractName);
    publishedContract = PublishedContractSchema.parse({
      id: model.contractId,
      timestamp: model.publishTimestamp,
      metadataUri: model.publishMetadataUri
    });
  } else {
    const allVersions = (await contract.getPublishedContractVersions(publisher, contractName)).map(c => {
      return PublishedContractSchema.parse({
        id: c.contractId,
        timestamp: c.publishTimestamp,
        metadataUri: c.publishMetadataUri
      });
    });

    // get the metadata for each version
    const versionMetadata = (await Promise.all(allVersions.map(c => fetchAndCacheDeployMetadata(c.metadataUri, storage)))).map((item, index) => ({
      name: allVersions[index].id,
      publishedTimestamp: allVersions[index].timestamp,
      publishedMetadata: item
    }));

    // find the version that matches the version string
    const versionMatch = versionMetadata.find(metadata => metadata.publishedMetadata.extendedMetadata?.version === version);
    invariant__default["default"](versionMatch, "Contract version not found");
    // match the version back to the contract based on the published timestamp
    publishedContract = allVersions.find(c => c.timestamp === versionMatch.publishedTimestamp);
  }
  if (!publishedContract) {
    throw new Error(`No published contract found for ${contractName} at version by '${THIRDWEB_DEPLOYER}'`);
  }
  return publishedContract;
}

async function getPrebuiltInfo(address, provider) {
  try {
    const IThirdwebContractABI = (await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@thirdweb-dev/contracts-js/dist/abis/IThirdwebContract.json')); })).default;
    const contract = new ethers.Contract(address, IThirdwebContractABI, provider);
    const [_type, version] = await Promise.all([contract.contractType(), contract.contractVersion()]);
    const type = ethers.utils.toUtf8String(_type) // eslint-disable-next-line no-control-regex
    .replace(/\x00/g, "");
    return {
      type,
      version
    };
  } catch (e) {
    return undefined;
  }
}

/* eslint-disable eqeqeq */
/* eslint-disable better-tree-shaking/no-top-level-side-effects  */
let decoder;
try {
  decoder = new TextDecoder();
} catch (error) {}
let src;
let srcEnd;
let position = 0;
const LEGACY_RECORD_INLINE_ID = 105;
const RECORD_DEFINITIONS_ID = 0xdffe;
const RECORD_INLINE_ID = 0xdfff; // temporary first-come first-serve tag // proposed tag: 0x7265 // 're'
const BUNDLED_STRINGS_ID = 0xdff9;
const PACKED_REFERENCE_TAG_ID = 6;
const STOP_CODE = {};
let currentDecoder = {};
let currentStructures;
let srcString;
let srcStringStart = 0;
let srcStringEnd = 0;
let bundledStrings;
let referenceMap;
let currentExtensions = [];
let currentExtensionRanges = [];
let packedValues;
let dataView;
let restoreMapsAsObject;
let defaultOptions = {
  useRecords: false,
  mapsAsObjects: true
};
let sequentialMode = false;
class Decoder {
  constructor(options) {
    if (options) {
      if ((options.keyMap || options._keyMap) && !options.useRecords) {
        options.useRecords = false;
        options.mapsAsObjects = true;
      }
      if (options.useRecords === false && options.mapsAsObjects === undefined) {
        options.mapsAsObjects = true;
      }
      if (options.getStructures) {
        options.getShared = options.getStructures;
      }
      if (options.getShared && !options.structures) {
        (options.structures = []).uninitialized = true;
      } // this is what we use to denote an uninitialized structures
      if (options.keyMap) {
        this.mapKey = new Map();
        for (let [k, v] of Object.entries(options.keyMap)) {
          this.mapKey.set(v, k);
        }
      }
    }
    Object.assign(this, options);
  }
  decodeKey(key) {
    return this.keyMap ? this.mapKey.get(key) || key : key;
  }
  decode(source, end) {
    if (src) {
      // re-entrant execution, save the state and restore it after we do this decode
      return saveState(() => {
        clearSource();
        return this ? this.decode(source, end) : Decoder.prototype.decode.call(defaultOptions, source, end);
      });
    }
    srcEnd = end > -1 ? end : source.length;
    position = 0;
    srcStringEnd = 0;
    srcString = null;
    bundledStrings = null;
    src = source;
    // this provides cached access to the data view for a buffer if it is getting reused, which is a recommend
    // technique for getting data from a database where it can be copied into an existing buffer instead of creating
    // new ones
    try {
      dataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));
    } catch (error) {
      // if it doesn't have a buffer, maybe it is the wrong type of object
      src = null;
      if (source instanceof Uint8Array) {
        throw error;
      }
      throw new Error("Source must be a Uint8Array or Buffer but was a " + (source && typeof source === "object" ? source.constructor.name : typeof source));
    }
    if (this instanceof Decoder) {
      // eslint-disable-next-line @typescript-eslint/no-this-alias
      currentDecoder = this;
      packedValues = this.sharedValues && (this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) : this.sharedValues);
      if (this.structures) {
        currentStructures = this.structures;
        return checkedRead();
      } else if (!currentStructures || currentStructures.length > 0) {
        currentStructures = [];
      }
    } else {
      currentDecoder = defaultOptions;
      if (!currentStructures || currentStructures.length > 0) {
        currentStructures = [];
      }
      packedValues = null;
    }
    return checkedRead();
  }
}
function checkedRead() {
  try {
    let result = read();
    if (bundledStrings) {
      if (position >= bundledStrings.postBundlePosition) {
        let error = new Error("Unexpected bundle position");
        error.incomplete = true;
        throw error;
      }
      // bundled strings to skip past
      position = bundledStrings.postBundlePosition;
      bundledStrings = null;
    }
    if (position == srcEnd) {
      // finished reading this source, cleanup references
      currentStructures = null;
      src = null;
      if (referenceMap) {
        referenceMap = null;
      }
    } else if (position > srcEnd) {
      // over read
      let error = new Error("Unexpected end of CBOR data");
      error.incomplete = true;
      throw error;
    } else if (!sequentialMode) {
      throw new Error("Data read, but end of buffer not reached");
    }
    // else more to read, but we are reading sequentially, so don't clear source yet
    return result;
  } catch (error) {
    clearSource();
    if (error instanceof RangeError || error.message.startsWith("Unexpected end of buffer")) {
      error.incomplete = true;
    }
    throw error;
  }
}
function read() {
  let token = src[position++];
  let majorType = token >> 5;
  token = token & 0x1f;
  if (token > 0x17) {
    switch (token) {
      case 0x18:
        token = src[position++];
        break;
      case 0x19:
        if (majorType == 7) {
          return getFloat16();
        }
        token = dataView.getUint16(position);
        position += 2;
        break;
      case 0x1a:
        if (majorType == 7) {
          let value = dataView.getFloat32(position);
          if (currentDecoder.useFloat32 > 2) {
            // this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
            let multiplier = mult10[(src[position] & 0x7f) << 1 | src[position + 1] >> 7];
            position += 4;
            return (multiplier * value + (value > 0 ? 0.5 : -0.5) >> 0) / multiplier;
          }
          position += 4;
          return value;
        }
        token = dataView.getUint32(position);
        position += 4;
        break;
      case 0x1b:
        if (majorType == 7) {
          let value = dataView.getFloat64(position);
          position += 8;
          return value;
        }
        if (majorType > 1) {
          if (dataView.getUint32(position) > 0) {
            throw new Error("JavaScript does not support arrays, maps, or strings with length over 4294967295");
          }
          token = dataView.getUint32(position + 4);
        } else if (currentDecoder.int64AsNumber) {
          token = dataView.getUint32(position) * 0x100000000;
          token += dataView.getUint32(position + 4);
        } else {
          token = dataView.getBigUint64(position);
        }
        position += 8;
        break;
      case 0x1f:
        // indefinite length
        switch (majorType) {
          case 2: // byte string
          case 3:
            // text string
            throw new Error("Indefinite length not supported for byte or text strings");
          case 4:
            // array
            let array = [];
            let value,
              i = 0;
            while ((value = read()) != STOP_CODE) {
              array[i++] = value;
            }
            return majorType == 4 ? array : majorType == 3 ? array.join("") : Buffer.concat(array);
          case 5:
            // map
            let key;
            if (currentDecoder.mapsAsObjects) {
              let object = {};
              if (currentDecoder.keyMap) {
                while ((key = read()) != STOP_CODE) {
                  object[safeKey(currentDecoder.decodeKey(key))] = read();
                }
              } else {
                while ((key = read()) != STOP_CODE) {
                  object[safeKey(key)] = read();
                }
              }
              return object;
            } else {
              if (restoreMapsAsObject) {
                currentDecoder.mapsAsObjects = true;
                restoreMapsAsObject = false;
              }
              let map = new Map();
              if (currentDecoder.keyMap) {
                while ((key = read()) != STOP_CODE) {
                  map.set(currentDecoder.decodeKey(key), read());
                }
              } else {
                while ((key = read()) != STOP_CODE) {
                  map.set(key, read());
                }
              }
              return map;
            }
          case 7:
            return STOP_CODE;
          default:
            throw new Error("Invalid major type for indefinite length " + majorType);
        }
      default:
        throw new Error("Unknown token " + token);
    }
  }
  switch (majorType) {
    case 0:
      // positive int
      return token;
    case 1:
      // negative int
      return ~token;
    case 2:
      // buffer
      return readBin(token);
    case 3:
      // string
      if (srcStringEnd >= position) {
        return srcString.slice(position - srcStringStart, (position += token) - srcStringStart);
      }
      if (srcStringEnd == 0 && srcEnd < 140 && token < 32) {
        // for small blocks, avoiding the overhead of the extract call is helpful
        let string = token < 16 ? shortStringInJS(token) : longStringInJS(token);
        if (string != null) {
          return string;
        }
      }
      return readFixedString(token);
    case 4:
      // array
      let array = new Array(token);
      //if (currentDecoder.keyMap) for (let i = 0; i < token; i++) array[i] = currentDecoder.decodeKey(read())
      //else
      for (let i = 0; i < token; i++) {
        array[i] = read();
      }
      return array;
    case 5:
      // map
      if (currentDecoder.mapsAsObjects) {
        let object = {};
        if (currentDecoder.keyMap) {
          for (let i = 0; i < token; i++) {
            object[safeKey(currentDecoder.decodeKey(read()))] = read();
          }
        } else {
          for (let i = 0; i < token; i++) {
            object[safeKey(read())] = read();
          }
        }
        return object;
      } else {
        if (restoreMapsAsObject) {
          currentDecoder.mapsAsObjects = true;
          restoreMapsAsObject = false;
        }
        let map = new Map();
        if (currentDecoder.keyMap) {
          for (let i = 0; i < token; i++) {
            map.set(currentDecoder.decodeKey(read()), read());
          }
        } else {
          for (let i = 0; i < token; i++) {
            map.set(read(), read());
          }
        }
        return map;
      }
    case 6:
      // extension
      if (token >= BUNDLED_STRINGS_ID) {
        let structure = currentStructures[token & 0x1fff]; // check record structures first
        // At some point we may provide an option for dynamic tag assignment with a range like token >= 8 && (token < 16 || (token > 0x80 && token < 0xc0) || (token > 0x130 && token < 0x4000))
        if (structure) {
          if (!structure.read) {
            structure.read = createStructureReader(structure);
          }
          return structure.read();
        }
        if (token < 0x10000) {
          if (token == RECORD_INLINE_ID) {
            // we do a special check for this so that we can keep the currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)
            return recordDefinition(read());
          } else if (token == RECORD_DEFINITIONS_ID) {
            let length = readJustLength();
            let id = read();
            for (let i = 2; i < length; i++) {
              recordDefinition([id++, read()]);
            }
            return read();
          } else if (token == BUNDLED_STRINGS_ID) {
            return readBundleExt();
          }
          if (currentDecoder.getShared) {
            loadShared();
            structure = currentStructures[token & 0x1fff];
            if (structure) {
              if (!structure.read) {
                structure.read = createStructureReader(structure);
              }
              return structure.read();
            }
          }
        }
      }
      let extension = currentExtensions[token];
      if (extension) {
        if (extension.handlesRead) {
          return extension(read);
        } else {
          return extension(read());
        }
      } else {
        let input = read();
        for (let i = 0; i < currentExtensionRanges.length; i++) {
          let value = currentExtensionRanges[i](token, input);
          if (value !== undefined) {
            return value;
          }
        }
        return new Tag(input, token);
      }
    case 7:
      // fixed value
      switch (token) {
        case 0x14:
          return false;
        case 0x15:
          return true;
        case 0x16:
          return null;
        case 0x17:
          return;
        // undefined
        case 0x1f:
        default:
          let packedValue = (packedValues || getPackedValues())[token];
          if (packedValue !== undefined) {
            return packedValue;
          }
          throw new Error("Unknown token " + token);
      }
    default:
      // negative int
      if (isNaN(token)) {
        let error = new Error("Unexpected end of CBOR data");
        error.incomplete = true;
        throw error;
      }
      throw new Error("Unknown CBOR token " + token);
  }
}
const validName = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;
function createStructureReader(structure) {
  function readObject() {
    // get the array size from the header
    let length = src[position++];
    //let majorType = token >> 5
    length = length & 0x1f;
    if (length > 0x17) {
      switch (length) {
        case 0x18:
          length = src[position++];
          break;
        case 0x19:
          length = dataView.getUint16(position);
          position += 2;
          break;
        case 0x1a:
          length = dataView.getUint32(position);
          position += 4;
          break;
        default:
          throw new Error("Expected array header, but got " + src[position - 1]);
      }
    }
    // This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function
    let compiledReader = this.compiledReader; // first look to see if we have the fast compiled function
    while (compiledReader) {
      // we have a fast compiled object literal reader
      if (compiledReader.propertyCount === length) {
        return compiledReader(read);
      } // with the right length, so we use it
      compiledReader = compiledReader.next; // see if there is another reader with the right length
    }
    if (this.slowReads++ >= 3) {
      // create a fast compiled reader
      let array = this.length == length ? this : this.slice(0, length);
      compiledReader = currentDecoder.keyMap ? new Function("r", "return {" + array.map(k => currentDecoder.decodeKey(k)).map(k => validName.test(k) ? safeKey(k) + ":r()" : "[" + JSON.stringify(k) + "]:r()").join(",") + "}") : new Function("r", "return {" + array.map(key => validName.test(key) ? safeKey(key) + ":r()" : "[" + JSON.stringify(key) + "]:r()").join(",") + "}");
      if (this.compiledReader) {
        compiledReader.next = this.compiledReader;
      } // if there is an existing one, we store multiple readers as a linked list because it is usually pretty rare to have multiple readers (of different length) for the same structure
      compiledReader.propertyCount = length;
      this.compiledReader = compiledReader;
      return compiledReader(read);
    }
    let object = {};
    if (currentDecoder.keyMap) {
      for (let i = 0; i < length; i++) {
        object[safeKey(currentDecoder.decodeKey(this[i]))] = read();
      }
    } else {
      for (let i = 0; i < length; i++) {
        object[safeKey(this[i])] = read();
      }
    }
    return object;
  }
  structure.slowReads = 0;
  return readObject;
}
function safeKey(key) {
  return key === "__proto__" ? "__proto_" : key;
}
let readFixedString = readStringJS;
function readStringJS(length) {
  let result;
  if (length < 16) {
    if (result = shortStringInJS(length)) {
      return result;
    }
  }
  if (length > 64 && decoder) {
    return decoder.decode(src.subarray(position, position += length));
  }
  const end = position + length;
  const units = [];
  result = "";
  while (position < end) {
    const byte1 = src[position++];
    if ((byte1 & 0x80) === 0) {
      // 1 byte
      units.push(byte1);
    } else if ((byte1 & 0xe0) === 0xc0) {
      // 2 bytes
      const byte2 = src[position++] & 0x3f;
      units.push((byte1 & 0x1f) << 6 | byte2);
    } else if ((byte1 & 0xf0) === 0xe0) {
      // 3 bytes
      const byte2 = src[position++] & 0x3f;
      const byte3 = src[position++] & 0x3f;
      units.push((byte1 & 0x1f) << 12 | byte2 << 6 | byte3);
    } else if ((byte1 & 0xf8) === 0xf0) {
      // 4 bytes
      const byte2 = src[position++] & 0x3f;
      const byte3 = src[position++] & 0x3f;
      const byte4 = src[position++] & 0x3f;
      let unit = (byte1 & 0x07) << 0x12 | byte2 << 0x0c | byte3 << 0x06 | byte4;
      if (unit > 0xffff) {
        unit -= 0x10000;
        units.push(unit >>> 10 & 0x3ff | 0xd800);
        unit = 0xdc00 | unit & 0x3ff;
      }
      units.push(unit);
    } else {
      units.push(byte1);
    }
    if (units.length >= 0x1000) {
      result += fromCharCode.apply(String, units);
      units.length = 0;
    }
  }
  if (units.length > 0) {
    result += fromCharCode.apply(String, units);
  }
  return result;
}
let fromCharCode = String.fromCharCode;
function longStringInJS(length) {
  let start = position;
  let bytes = new Array(length);
  for (let i = 0; i < length; i++) {
    const byte = src[position++];
    if ((byte & 0x80) > 0) {
      position = start;
      return;
    }
    bytes[i] = byte;
  }
  return fromCharCode.apply(String, bytes);
}
function shortStringInJS(length) {
  if (length < 4) {
    if (length < 2) {
      if (length === 0) {
        return "";
      } else {
        let a = src[position++];
        if ((a & 0x80) > 1) {
          position -= 1;
          return;
        }
        return fromCharCode(a);
      }
    } else {
      let a = src[position++];
      let b = src[position++];
      if ((a & 0x80) > 0 || (b & 0x80) > 0) {
        position -= 2;
        return;
      }
      if (length < 3) {
        return fromCharCode(a, b);
      }
      let c = src[position++];
      if ((c & 0x80) > 0) {
        position -= 3;
        return;
      }
      return fromCharCode(a, b, c);
    }
  } else {
    let a = src[position++];
    let b = src[position++];
    let c = src[position++];
    let d = src[position++];
    if ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {
      position -= 4;
      return;
    }
    if (length < 6) {
      if (length === 4) {
        return fromCharCode(a, b, c, d);
      } else {
        let e = src[position++];
        if ((e & 0x80) > 0) {
          position -= 5;
          return;
        }
        return fromCharCode(a, b, c, d, e);
      }
    } else if (length < 8) {
      let e = src[position++];
      let f = src[position++];
      if ((e & 0x80) > 0 || (f & 0x80) > 0) {
        position -= 6;
        return;
      }
      if (length < 7) {
        return fromCharCode(a, b, c, d, e, f);
      }
      let g = src[position++];
      if ((g & 0x80) > 0) {
        position -= 7;
        return;
      }
      return fromCharCode(a, b, c, d, e, f, g);
    } else {
      let e = src[position++];
      let f = src[position++];
      let g = src[position++];
      let h = src[position++];
      if ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {
        position -= 8;
        return;
      }
      if (length < 10) {
        if (length === 8) {
          return fromCharCode(a, b, c, d, e, f, g, h);
        } else {
          let i = src[position++];
          if ((i & 0x80) > 0) {
            position -= 9;
            return;
          }
          return fromCharCode(a, b, c, d, e, f, g, h, i);
        }
      } else if (length < 12) {
        let i = src[position++];
        let j = src[position++];
        if ((i & 0x80) > 0 || (j & 0x80) > 0) {
          position -= 10;
          return;
        }
        if (length < 11) {
          return fromCharCode(a, b, c, d, e, f, g, h, i, j);
        }
        let k = src[position++];
        if ((k & 0x80) > 0) {
          position -= 11;
          return;
        }
        return fromCharCode(a, b, c, d, e, f, g, h, i, j, k);
      } else {
        let i = src[position++];
        let j = src[position++];
        let k = src[position++];
        let l = src[position++];
        if ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {
          position -= 12;
          return;
        }
        if (length < 14) {
          if (length === 12) {
            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);
          } else {
            let m = src[position++];
            if ((m & 0x80) > 0) {
              position -= 13;
              return;
            }
            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m);
          }
        } else {
          let m = src[position++];
          let n = src[position++];
          if ((m & 0x80) > 0 || (n & 0x80) > 0) {
            position -= 14;
            return;
          }
          if (length < 15) {
            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);
          }
          let o = src[position++];
          if ((o & 0x80) > 0) {
            position -= 15;
            return;
          }
          return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);
        }
      }
    }
  }
}
function readBin(length) {
  return currentDecoder.copyBuffers ?
  // specifically use the copying slice (not the node one)
  Uint8Array.prototype.slice.call(src, position, position += length) : src.subarray(position, position += length);
}
let f32Array = new Float32Array(1);
let u8Array = new Uint8Array(f32Array.buffer, 0, 4);
function getFloat16() {
  let byte0 = src[position++];
  let byte1 = src[position++];
  let exponent = (byte0 & 0x7f) >> 2;
  if (exponent === 0x1f) {
    // specials
    if (byte1 || byte0 & 3) {
      return NaN;
    }
    return byte0 & 0x80 ? -Infinity : Infinity;
  }
  if (exponent === 0) {
    // sub-normals
    // significand with 10 fractional bits and divided by 2^14
    let abs = ((byte0 & 3) << 8 | byte1) / (1 << 24);
    return byte0 & 0x80 ? -abs : abs;
  }
  u8Array[3] = byte0 & 0x80 |
  // sign bit
  (exponent >> 1) + 56; // 4 of 5 of the exponent bits, re-offset-ed
  u8Array[2] = (byte0 & 7) << 5 |
  // last exponent bit and first two mantissa bits
  byte1 >> 3; // next 5 bits of mantissa
  u8Array[1] = byte1 << 5; // last three bits of mantissa
  u8Array[0] = 0;
  return f32Array[0];
}
class Tag {
  constructor(value, tag) {
    this.value = value;
    this.tag = tag;
  }
}
currentExtensions[0] = dateString => {
  // string date extension
  return new Date(dateString);
};
currentExtensions[1] = epochSec => {
  // numeric date extension
  return new Date(Math.round(epochSec * 1000));
};
currentExtensions[2] = buffer => {
  // bigint extension
  let value = BigInt(0);
  for (let i = 0, l = buffer.byteLength; i < l; i++) {
    value = BigInt(buffer[i]) + value << BigInt(8);
  }
  return value;
};
currentExtensions[3] = buffer => {
  // negative bigint extension
  return BigInt(-1) - currentExtensions[2](buffer);
};
currentExtensions[4] = fraction => {
  // best to reparse to maintain accuracy
  return Number(fraction[1] + "e" + fraction[0]);
};
currentExtensions[5] = fraction => {
  // probably not sufficiently accurate
  return fraction[1] * Math.exp(fraction[0] * Math.log(2));
};

// the registration of the record definition extension
const recordDefinition = definition => {
  let id = definition[0] - 0xe000;
  let structure = definition[1];
  let existingStructure = currentStructures[id];
  if (existingStructure && existingStructure.isShared) {
    (currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure;
  }
  currentStructures[id] = structure;
  structure.read = createStructureReader(structure);
  let object = {};
  if (currentDecoder.keyMap) {
    for (let i = 2, l = definition.length; i < l; i++) {
      let key = currentDecoder.decodeKey(structure[i - 2]);
      object[safeKey(key)] = definition[i];
    }
  } else {
    for (let i = 2, l = definition.length; i < l; i++) {
      let key = structure[i - 2];
      object[safeKey(key)] = definition[i];
    }
  }
  return object;
};
currentExtensions[LEGACY_RECORD_INLINE_ID] = recordDefinition;
currentExtensions[14] = value => {
  if (bundledStrings) {
    return bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 += value);
  }
  return new Tag(value, 14);
};
currentExtensions[15] = value => {
  if (bundledStrings) {
    return bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value);
  }
  return new Tag(value, 15);
};
let glbl = {
  Error,
  RegExp
};
currentExtensions[27] = data => {
  // http://cbor.schmorp.de/generic-object
  return (glbl[data[0]] || Error)(data[1], data[2]);
};
const packedTable = _read => {
  if (src[position++] != 0x84) {
    throw new Error("Packed values structure must be followed by a 4 element array");
  }
  let newPackedValues = _read(); // packed values
  packedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues;
  packedValues.prefixes = _read();
  packedValues.suffixes = _read();
  return _read(); // read the rump
};
packedTable.handlesRead = true;
currentExtensions[51] = packedTable;
currentExtensions[PACKED_REFERENCE_TAG_ID] = data => {
  // packed reference
  if (!packedValues) {
    if (currentDecoder.getShared) {
      loadShared();
    } else {
      return new Tag(data, PACKED_REFERENCE_TAG_ID);
    }
  }
  if (typeof data === "number") {
    return packedValues[16 + (data >= 0 ? 2 * data : -2 * data - 1)];
  }
  throw new Error("No support for non-integer packed references yet");
};
currentExtensions[25] = id => {
  return stringRefs[id];
};
currentExtensions[256] = _read => {
  stringRefs = [];
  try {
    return _read();
  } finally {
    stringRefs = null;
  }
};
currentExtensions[256].handlesRead = true;
currentExtensions[28] = _read => {
  // shareable http://cbor.schmorp.de/value-sharing (for structured clones)
  if (!referenceMap) {
    referenceMap = new Map();
    referenceMap.id = 0;
  }
  let id = referenceMap.id++;
  let token = src[position];
  let target;
  // TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read
  // ahead past references to record structure definitions
  if (token >> 5 == 4) {
    target = [];
  } else {
    target = {};
  }
  let refEntry = {
    target
  }; // a placeholder object
  referenceMap.set(id, refEntry);
  let targetProperties = _read(); // read the next value as the target object to id
  if (refEntry.used) {
    // there is a cycle, so we have to assign properties to original target
    return Object.assign(target, targetProperties);
  }
  refEntry.target = targetProperties; // the placeholder wasn't used, replace with the deserialized one
  return targetProperties; // no cycle, can just use the returned read object
};
currentExtensions[28].handlesRead = true;
currentExtensions[29] = id => {
  // sharedref http://cbor.schmorp.de/value-sharing (for structured clones)
  let refEntry = referenceMap.get(id);
  refEntry.used = true;
  return refEntry.target;
};
currentExtensions[258] = array => new Set(array); // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md
(currentExtensions[259] = _read => {
  // https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec
  // for decoding as a standard Map
  if (currentDecoder.mapsAsObjects) {
    currentDecoder.mapsAsObjects = false;
    restoreMapsAsObject = true;
  }
  return _read();
}).handlesRead = true;
function combine(a, b) {
  if (typeof a === "string") {
    return a + b;
  }
  if (a instanceof Array) {
    return a.concat(b);
  }
  return Object.assign({}, a, b);
}
function getPackedValues() {
  if (!packedValues) {
    if (currentDecoder.getShared) {
      loadShared();
    } else {
      throw new Error("No packed values available");
    }
  }
  return packedValues;
}
const SHARED_DATA_TAG_ID = 0x53687264; // ascii 'Shrd'
currentExtensionRanges.push((tag, input) => {
  if (tag >= 225 && tag <= 255) {
    return combine(getPackedValues().prefixes[tag - 224], input);
  }
  if (tag >= 28704 && tag <= 32767) {
    return combine(getPackedValues().prefixes[tag - 28672], input);
  }
  if (tag >= 1879052288 && tag <= 2147483647) {
    return combine(getPackedValues().prefixes[tag - 1879048192], input);
  }
  if (tag >= 216 && tag <= 223) {
    return combine(input, getPackedValues().suffixes[tag - 216]);
  }
  if (tag >= 27647 && tag <= 28671) {
    return combine(input, getPackedValues().suffixes[tag - 27639]);
  }
  if (tag >= 1811940352 && tag <= 1879048191) {
    return combine(input, getPackedValues().suffixes[tag - 1811939328]);
  }
  if (tag == SHARED_DATA_TAG_ID) {
    // we do a special check for this so that we can keep the currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)
    return {
      packedValues: packedValues,
      structures: currentStructures.slice(0),
      version: input
    };
  }
  if (tag == 55799) {
    // self-descriptive CBOR tag, just return input value
    return input;
  }
});
const isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1;
const typedArrays = [Uint8Array];
const typedArrayTags = [64];
for (let i = 0; i < typedArrays.length; i++) {
  registerTypedArray(typedArrays[i], typedArrayTags[i]);
}
function registerTypedArray(TypedArray, tag) {
  let dvMethod = "get" + TypedArray.name.slice(0, -5);
  if (typeof TypedArray !== "function") {
    TypedArray = null;
  }
  let bytesPerElement = TypedArray.BYTES_PER_ELEMENT;
  for (let littleEndian = 0; littleEndian < 2; littleEndian++) {
    if (!littleEndian && bytesPerElement == 1) {
      continue;
    }
    let sizeShift = bytesPerElement == 2 ? 1 : bytesPerElement == 4 ? 2 : 3;
    currentExtensions[littleEndian ? tag : tag - 4] = bytesPerElement == 1 || littleEndian == isLittleEndianMachine ? buffer => {
      if (!TypedArray) {
        throw new Error("Could not find typed array for code " + tag);
      }
      // we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned
      return new TypedArray(Uint8Array.prototype.slice.call(buffer, 0).buffer);
    } : buffer => {
      if (!TypedArray) {
        throw new Error("Could not find typed array for code " + tag);
      }
      let dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      let elements = buffer.length >> sizeShift;
      let ta = new TypedArray(elements);
      let method = dv[dvMethod];
      for (let i = 0; i < elements; i++) {
        ta[i] = method.call(dv, i << sizeShift, littleEndian);
      }
      return ta;
    };
  }
}
function readBundleExt() {
  let length = readJustLength();
  let bundlePosition = position + read();
  for (let i = 2; i < length; i++) {
    // skip past bundles that were already read
    let bundleLength = readJustLength(); // this will increment position, so must add to position afterwards
    position += bundleLength;
  }
  let dataPosition = position;
  position = bundlePosition;
  bundledStrings = [readStringJS(readJustLength()), readStringJS(readJustLength())];
  bundledStrings.position0 = 0;
  bundledStrings.position1 = 0;
  bundledStrings.postBundlePosition = position;
  position = dataPosition;
  return read();
}
function readJustLength() {
  let token = src[position++] & 0x1f;
  if (token > 0x17) {
    switch (token) {
      case 0x18:
        token = src[position++];
        break;
      case 0x19:
        token = dataView.getUint16(position);
        position += 2;
        break;
      case 0x1a:
        token = dataView.getUint32(position);
        position += 4;
        break;
    }
  }
  return token;
}
function loadShared() {
  if (currentDecoder.getShared) {
    let sharedData = saveState(() => {
      // save the state in case getShared modifies our buffer
      src = null;
      return currentDecoder.getShared();
    }) || {};
    let updatedStructures = sharedData.structures || [];
    currentDecoder.sharedVersion = sharedData.version;
    packedValues = currentDecoder.sharedValues = sharedData.packedValues;
    if (currentStructures === true) {
      currentDecoder.structures = currentStructures = updatedStructures;
    } else {
      currentStructures.splice.apply(currentStructures, [0, updatedStructures.length].concat(updatedStructures));
    }
  }
}
function saveState(callback) {
  let savedSrcEnd = srcEnd;
  let savedPosition = position;
  let savedSrcStringStart = srcStringStart;
  let savedSrcStringEnd = srcStringEnd;
  let savedSrcString = srcString;
  let savedReferenceMap = referenceMap;
  let savedBundledStrings = bundledStrings;

  // TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)
  let savedSrc = new Uint8Array(src.slice(0, srcEnd)); // we copy the data in case it changes while external data is processed
  let savedStructures = currentStructures;
  let savedDecoder = currentDecoder;
  let savedSequentialMode = sequentialMode;
  let value = callback();
  srcEnd = savedSrcEnd;
  position = savedPosition;
  srcStringStart = savedSrcStringStart;
  srcStringEnd = savedSrcStringEnd;
  srcString = savedSrcString;
  referenceMap = savedReferenceMap;
  bundledStrings = savedBundledStrings;
  src = savedSrc;
  sequentialMode = savedSequentialMode;
  currentStructures = savedStructures;
  currentDecoder = savedDecoder;
  dataView = new DataView(src.buffer, src.byteOffset, src.byteLength);
  return value;
}
function clearSource() {
  src = null;
  referenceMap = null;
  currentStructures = null;
}
const mult10 = new Array(147); // this is a table matching binary exponents to the multiplier to determine significant digit rounding
for (let i = 0; i < 256; i++) {
  mult10[i] = Number("1e" + Math.floor(45.15 - i * 0.30103));
}
const defaultDecoder = new Decoder({
  useRecords: false
});
const decode = defaultDecoder.decode;

/**
 * @internal
 * @param hex - The hex string to convert to bytes
 */
function hexToBytes(hex) {
  hex = hex.toString(16);
  if (!hex.startsWith("0x")) {
    hex = `0x${hex}`;
  }
  if (!isHexStrict(hex)) {
    throw new Error(`Given value "${hex}" is not a valid hex string.`);
  }
  hex = hex.replace(/^0x/i, "");
  const bytes = [];
  for (let c = 0; c < hex.length; c += 2) {
    bytes.push(parseInt(hex.slice(c, c + 2), 16));
  }
  return bytes;
}

/**
 * @internal
 * @param hex - The hex string to check
 */
function isHexStrict(hex) {
  return (typeof hex === "string" || typeof hex === "number") && /^(-)?0x[0-9a-f]*$/i.test(hex.toString());
}

/**
 * @internal
 * @param bytecode - The bytecode to extract the IPFS hash from
 */
function extractIPFSHashFromBytecode(bytecode) {
  const numericBytecode = hexToBytes(bytecode);
  const cborLength = numericBytecode[numericBytecode.length - 2] * 0x100 + numericBytecode[numericBytecode.length - 1];
  const bytecodeBuffer = Uint8Array.from(numericBytecode.slice(numericBytecode.length - 2 - cborLength, -2));
  const cborData = decode(bytecodeBuffer);
  if ("ipfs" in cborData && cborData["ipfs"]) {
    try {
      return `ipfs://${bs58__default["default"].encode(cborData["ipfs"])}`;
    } catch (e) {
      console.warn("feature-detection ipfs cbor failed", e);
    }
  }
  return undefined;
}

/**
 * @internal
 * @param bytecode - The bytecode to check
 */
function extractMinimalProxyImplementationAddress(bytecode) {
  // EIP-1167 clone minimal proxy - https://eips.ethereum.org/EIPS/eip-1167
  if (bytecode.startsWith("0x363d3d373d3d3d363d73")) {
    const implementationAddress = bytecode.slice(22, 62);
    return `0x${implementationAddress}`;
  }

  // Minimal Proxy with receive() from 0xSplits - https://github.com/0xSplits/splits-contracts/blob/c7b741926ec9746182d0d1e2c4c2046102e5d337/contracts/libraries/Clones.sol
  if (bytecode.startsWith("0x36603057343d5230")) {
    // +40 = size of addr
    const implementationAddress = bytecode.slice(122, 122 + 40);
    return `0x${implementationAddress}`;
  }

  // 0age's minimal proxy - https://medium.com/coinmonks/the-more-minimal-proxy-5756ae08ee48
  if (bytecode.startsWith("0x3d3d3d3d363d3d37363d73")) {
    // +40 = size of addr
    const implementationAddress = bytecode.slice(24, 24 + 40);
    return `0x${implementationAddress}`;
  }

  // vyper's minimal proxy (uniswap v1) - https://etherscan.io/address/0x09cabec1ead1c0ba254b09efb3ee13841712be14#code
  if (bytecode.startsWith("0x366000600037611000600036600073")) {
    const implementationAddress = bytecode.slice(32, 32 + 40);
    return `0x${implementationAddress}`;
  }
  if (bytecode.startsWith("0x36600080376020600036600073")) {
    const implementationAddress = bytecode.slice(28, 28 + 40);
    return `0x${implementationAddress}`;
  }

  // EIP-7511 minimal proxy with PUSH0 opcode - https://eips.ethereum.org/EIPS/eip-7511
  if (bytecode.startsWith("0x365f5f375f5f365f73")) {
    const implementationAddress = bytecode.slice(20, 60);
    return `0x${implementationAddress}`;
  }
  return undefined;
}

/**
 * @internal
 * @param address - the contract address
 * @param provider - RPC provider
 */
async function resolveContractUriFromAddress(address, provider) {
  const {
    bytecode
  } = await resolveImplementation(address, provider);
  return extractIPFSHashFromBytecode(bytecode);
}

/**
 * @internal
 */
async function resolveContractUriAndBytecode(address, provider) {
  const {
    bytecode
  } = await resolveImplementation(address, provider);
  return {
    uri: extractIPFSHashFromBytecode(bytecode),
    bytecode
  };
}

/**
 * Resolve the implementation address of a proxy contract and its bytecode
 * @param address - the contract address
 * @param provider - RPC provider
 * @returns The implementation address and its bytecode
 */
async function resolveImplementation(address, provider) {
  const [bytecode, beacon] = await Promise.all([fetchBytecode(address, provider), getBeaconFromStorageSlot(address, provider)]);

  // check minimal proxy first synchronously
  const minimalProxyImplementationAddress = extractMinimalProxyImplementationAddress(bytecode);
  if (minimalProxyImplementationAddress) {
    return {
      address: minimalProxyImplementationAddress,
      bytecode: await fetchBytecode(minimalProxyImplementationAddress, provider)
    };
  }

  // check other proxy types
  if (beacon && beacon !== ethers.constants.AddressZero) {
    // In case of a BeaconProxy, it is setup as BeaconProxy --> Beacon --> Implementation
    // Hence we replace the proxy address with Beacon address, and continue further resolving below
    address = beacon;
  }
  const impl = await Promise.all([getImplementationFromStorageSlot(address, provider), getImplementationFromContractCall(address, provider)]);
  for (const implementationAddress of impl) {
    if (implementationAddress && ethers.utils.isAddress(implementationAddress) && implementationAddress !== ethers.constants.AddressZero) {
      try {
        const implBytecode = await fetchBytecode(implementationAddress, provider);
        return {
          address: implementationAddress,
          bytecode: implBytecode
        };
      } catch (e) {
        if (e instanceof Error) {
          // Ignore if fetchBytecode throws the error below, implying that bytecode is 0x.
          // In that case we don't want to throw, and just return the original contract address and bytecode.
          if (!e.message.includes(`Contract at ${implementationAddress} does not exist on chain`)) {
            throw e;
          }
        }
      }
    }
  }
  return {
    address,
    bytecode
  };
}
async function fetchBytecode(address, provider) {
  try {
    const bytecode = await provider.getCode(address);
    if (bytecode === "0x") {
      const chain = await provider.getNetwork();
      throw new Error(`Contract at ${address} does not exist on chain '${chain.name}' (chainId: ${chain.chainId})`);
    }
    return bytecode;
  } catch (e) {
    throw new Error(`Failed to get bytecode for address ${address}: ${e}`);
  }
}
async function getImplementationFromStorageSlot(address, provider) {
  try {
    const proxyStorage = await provider.getStorageAt(address, ethers.BigNumber.from("0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc"));
    return `0x${proxyStorage.slice(-40)}`;
  } catch (e) {
    return undefined;
  }
}
async function getBeaconFromStorageSlot(address, provider) {
  /**
   * The storage slot of the Beacon as defined in EIP-1967
   * See https://eips.ethereum.org/EIPS/eip-1967#beacon-contract-address
   *
   * bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1))
   */

  try {
    const proxyStorage = await provider.getStorageAt(address, ethers.BigNumber.from("0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50"));
    return `0x${proxyStorage.slice(-40)}`;
  } catch (e) {
    return undefined;
  }
}
async function getImplementationFromContractCall(address, provider) {
  try {
    const proxy = new ethers.Contract(address, UPGRADEABLE_PROXY_ABI, provider);
    return await proxy.implementation();
  } catch (e) {
    return undefined;
  }
}
const UPGRADEABLE_PROXY_ABI = [{
  type: "function",
  name: "implementation",
  inputs: [],
  outputs: [{
    type: "address",
    name: "",
    internalType: "address"
  }],
  stateMutability: "view"
}];

const MultichainRegistry_address = "0xcdAD8FA86e18538aC207872E8ff3536501431B73"; // Polygon only

/**
 * @internal
 */
function getMultichainRegistryAddress() {
  return getProcessEnv("multiChainRegistryAddress", MultichainRegistry_address);
}

/**
 * @internal
 */
function joinABIs(abis, abiWithConstructor) {
  const parsedABIs = abis.map(abi => AbiSchema.parse(abi)).flat();
  const filteredABIs = parsedABIs.filter(item => item.type !== "constructor");
  if (abiWithConstructor) {
    filteredABIs.push(...AbiSchema.parse(abiWithConstructor));
  }
  const finalABIs = unique(filteredABIs, (a, b) => {
    return a.name === b.name && a.type === b.type && a.inputs.length === b.inputs.length;
  });
  return AbiSchema.parse(finalABIs);
}

const FEATURE_TOKEN_CLAIM_CONDITIONS_V1 = {
  name: "ERC20ClaimConditionsV1",
  namespace: "token.drop.claim",
  docLinks: {
    sdk: "sdk.erc20dclaimable",
    contracts: "erc20claimconditions"
  },
  abis: [ERC20Abi__default["default"], IDropSinglePhaseV1__default["default"]],
  features: {}
};
const FEATURE_TOKEN_CLAIM_CONDITIONS_V2 = {
  name: "ERC20ClaimConditionsV2",
  namespace: "token.drop.claim",
  docLinks: {
    sdk: "sdk.erc20dclaimable",
    contracts: "erc20claimconditions"
  },
  abis: [ERC20Abi__default["default"], IDropSinglePhase__default["default"]],
  features: {}
};
const FEATURE_TOKEN_CLAIM_PHASES_V2 = {
  name: "ERC20ClaimPhasesV2",
  namespace: "token.drop.claim",
  docLinks: {
    sdk: "sdk.erc20dclaimable",
    contracts: "erc20claimphases"
  },
  abis: [ERC20Abi__default["default"], IDrop__default["default"]],
  features: {}
};
const FEATURE_TOKEN_CLAIM_PHASES_V1 = {
  name: "ERC20ClaimPhasesV1",
  namespace: "token.drop.claim",
  docLinks: {
    sdk: "sdk.erc20dclaimable",
    contracts: "erc20claimphases"
  },
  abis: [DropERC20_V2Abi__default["default"]],
  features: {}
};
const FEATURE_TOKEN_BURNABLE = {
  name: "ERC20Burnable",
  namespace: "token.burn",
  docLinks: {
    sdk: "sdk.erc20burnable",
    contracts: "erc20burnable"
  },
  abis: [ERC20Abi__default["default"], IBurnableERC20Abi__default["default"]],
  features: {}
};
const FEATURE_TOKEN_SIGNATURE_MINTABLE = {
  name: "ERC20SignatureMintable",
  namespace: "token.signature",
  docLinks: {
    sdk: "sdk.erc20signaturemintable",
    contracts: "erc20signaturemint"
  },
  abis: [ERC20Abi__default["default"], ISignatureMintERC20Abi__default["default"]],
  features: {}
};
const FEATURE_TOKEN_BATCH_MINTABLE = {
  name: "ERC20BatchMintable",
  namespace: "token.mint.batch",
  docLinks: {
    sdk: "sdk.erc20batchmintable",
    contracts: "erc20batchmintable"
  },
  abis: [ERC20Abi__default["default"], IMintableERC20Abi__default["default"], MulticallAbi__default["default"]],
  features: {}
};
const FEATURE_TOKEN_MINTABLE = {
  name: "ERC20Mintable",
  namespace: "token.mint",
  docLinks: {
    sdk: "sdk.erc20mintable",
    contracts: "erc20mintable"
  },
  abis: [ERC20Abi__default["default"], IMintableERC20Abi__default["default"]],
  features: {
    [FEATURE_TOKEN_BATCH_MINTABLE.name]: FEATURE_TOKEN_BATCH_MINTABLE
  }
};
const FEATURE_TOKEN_PERMIT = {
  name: "ERC20Permit",
  namespace: "token.permit",
  docLinks: {
    sdk: "sdk.erc20permit",
    contracts: "erc20permit"
  },
  abis: [ERC20Abi__default["default"], IERC20PermitAbi__default["default"]],
  features: {}
};
const FEATURE_TOKEN = {
  name: "ERC20",
  namespace: "token",
  docLinks: {
    sdk: "sdk.erc20",
    contracts: "erc20"
  },
  abis: [ERC20Abi__default["default"], IERC20MetadataAbi__default["default"]],
  features: {
    [FEATURE_TOKEN_BURNABLE.name]: FEATURE_TOKEN_BURNABLE,
    [FEATURE_TOKEN_MINTABLE.name]: FEATURE_TOKEN_MINTABLE,
    [FEATURE_TOKEN_CLAIM_CONDITIONS_V1.name]: FEATURE_TOKEN_CLAIM_CONDITIONS_V1,
    [FEATURE_TOKEN_CLAIM_CONDITIONS_V2.name]: FEATURE_TOKEN_CLAIM_CONDITIONS_V2,
    [FEATURE_TOKEN_CLAIM_PHASES_V1.name]: FEATURE_TOKEN_CLAIM_PHASES_V1,
    [FEATURE_TOKEN_CLAIM_PHASES_V2.name]: FEATURE_TOKEN_CLAIM_PHASES_V2,
    [FEATURE_TOKEN_SIGNATURE_MINTABLE.name]: FEATURE_TOKEN_SIGNATURE_MINTABLE,
    [FEATURE_TOKEN_PERMIT.name]: FEATURE_TOKEN_PERMIT
  }
};

const FEATURE_NFT_BURNABLE = {
  name: "ERC721Burnable",
  namespace: "nft.burn",
  docLinks: {
    sdk: "sdk.erc721burnable",
    contracts: "erc721burnable"
  },
  abis: [Erc721Abi__default["default"], IBurnableERC721Abi__default["default"]],
  features: {}
};
const FEATURE_NFT_REVEALABLE = {
  name: "ERC721Revealable",
  namespace: "nft.drop.revealer",
  docLinks: {
    sdk: "sdk.delayedreveal",
    contracts: "erc721revealable"
  },
  abis: [Erc721Abi__default["default"], ILazyMintAbi__default["default"], DelayedRevealAbi__default["default"]],
  features: {}
};
const FEATURE_NFT_TIERED_DROP = {
  name: "ERC721TieredDrop",
  namespace: "nft.tieredDrop",
  docLinks: {
    sdk: "sdk.erc721tiereddrop",
    //TODO
    contracts: ""
  },
  abis: [Erc721Abi__default["default"], TieredDropAbi__default["default"]],
  features: {}
};
const FEATURE_NFT_CLAIM_CONDITIONS_V1 = {
  name: "ERC721ClaimConditionsV1",
  namespace: "nft.drop.claim",
  docLinks: {
    sdk: "sdk.erc721claimable",
    contracts: "erc721claimconditions"
  },
  abis: [Erc721Abi__default["default"], IDropSinglePhaseV1__default["default"]],
  features: {}
};
const FEATURE_NFT_CLAIM_CONDITIONS_V2 = {
  name: "ERC721ClaimConditionsV2",
  namespace: "nft.drop.claim",
  docLinks: {
    sdk: "sdk.erc721claimable",
    contracts: "erc721claimconditions"
  },
  abis: [Erc721Abi__default["default"], IDropSinglePhase__default["default"]],
  features: {}
};
const FEATURE_NFT_CLAIM_PHASES_V1 = {
  name: "ERC721ClaimPhasesV1",
  namespace: "nft.drop.claim",
  docLinks: {
    sdk: "sdk.erc721claimable",
    contracts: "erc721claimphases"
  },
  abis: [DropERC721_V3Abi__default["default"]],
  features: {}
};
const FEATURE_NFT_CLAIM_PHASES_V2 = {
  name: "ERC721ClaimPhasesV2",
  namespace: "nft.drop.claim",
  docLinks: {
    sdk: "sdk.erc721claimable",
    contracts: "erc721claimphases"
  },
  abis: [Erc721Abi__default["default"], IDrop__default["default"]],
  features: {}
};
const FEATURE_NFT_CLAIM_CUSTOM = {
  name: "ERC721ClaimCustom",
  namespace: "nft.drop.claim",
  docLinks: {
    sdk: "sdk.erc721claimable",
    contracts: "erc721claimcustom"
  },
  abis: [Erc721Abi__default["default"], IClaimableERC721__default["default"]],
  features: {}
};
const FEATURE_NFT_CLAIM_ZORA = {
  name: "ERC721ClaimZora",
  namespace: "nft.drop.claim",
  docLinks: {
    sdk: "sdk.erc721claimable",
    contracts: "erc721claimzora"
  },
  abis: [Erc721Abi__default["default"], zora_IDropERC721__default["default"]],
  features: {}
};
const FEATURE_NFT_LAZY_MINTABLE = {
  name: "ERC721LazyMintable",
  namespace: "nft.drop",
  docLinks: {
    sdk: "sdk.erc721lazymintable",
    contracts: "lazymint"
  },
  abis: [Erc721Abi__default["default"], ILazyMintAbi__default["default"]],
  features: {
    [FEATURE_NFT_REVEALABLE.name]: FEATURE_NFT_REVEALABLE
  }
};
const FEATURE_NFT_BATCH_MINTABLE = {
  name: "ERC721BatchMintable",
  namespace: "nft.mint.batch",
  docLinks: {
    sdk: "sdk.erc721batchmintable",
    contracts: "erc721batchmintable"
  },
  abis: [Erc721Abi__default["default"], IMintableERC721Abi__default["default"], MulticallAbi__default["default"]],
  features: {}
};
const FEATURE_NFT_MINTABLE = {
  name: "ERC721Mintable",
  namespace: "nft.mint",
  docLinks: {
    sdk: "sdk.erc721mintable",
    contracts: "erc721mintable"
  },
  abis: [Erc721Abi__default["default"], IMintableERC721Abi__default["default"]],
  features: {
    [FEATURE_NFT_BATCH_MINTABLE.name]: FEATURE_NFT_BATCH_MINTABLE
  }
};
const FEATURE_NFT_SIGNATURE_MINTABLE_V2 = {
  name: "ERC721SignatureMintV2",
  namespace: "nft.signature",
  docLinks: {
    sdk: "sdk.erc721signaturemint",
    contracts: "erc721signaturemint"
  },
  abis: [Erc721Abi__default["default"], SignatureMintERC721Abi__default["default"]],
  features: {}
};
const FEATURE_NFT_SIGNATURE_MINTABLE_V1 = {
  name: "ERC721SignatureMintV1",
  namespace: "nft.signature",
  docLinks: {
    sdk: "sdk.erc721signaturemint",
    contracts: "erc721signaturemint"
  },
  abis: [SignatureMintERC721_V1Abi__default["default"]],
  features: {}
};
const FEATURE_NFT_ENUMERABLE = {
  name: "ERC721Enumerable",
  namespace: "nft.query.owned",
  docLinks: {
    sdk: "sdk.erc721enumerable",
    contracts: "erc721enumerable"
  },
  abis: [Erc721Abi__default["default"], Erc721EnumerableAbi__default["default"]],
  features: {}
};
const FEATURE_NFT_QUERYABLE = {
  name: "ERC721AQueryable",
  namespace: "nft.query.owned",
  docLinks: {
    sdk: "",
    contracts: ""
  },
  abis: [Erc721AQueryableAbi__default["default"]],
  features: {}
};
const FEATURE_NFT_SUPPLY = {
  name: "ERC721Supply",
  namespace: "nft.query",
  docLinks: {
    sdk: "sdk.erc721supply",
    contracts: "erc721supply"
  },
  abis: [Erc721Abi__default["default"], Erc721SupplyAbi__default["default"]],
  features: {
    [FEATURE_NFT_ENUMERABLE.name]: FEATURE_NFT_ENUMERABLE,
    [FEATURE_NFT_QUERYABLE.name]: FEATURE_NFT_QUERYABLE
  }
};
const FEATURE_NFT_SHARED_METADATA = {
  name: "ERC721SharedMetadata",
  namespace: "nft.sharedmetadata",
  docLinks: {
    sdk: "sdk.sharedmetadata",
    contracts: "SharedMetadata"
  },
  abis: [Erc721Abi__default["default"], SharedMetadataAbi__default["default"]],
  features: {}
};
const FEATURE_NFT_LOYALTY_CARD = {
  name: "ERC721LoyaltyCard",
  namespace: "nft.loyaltyCard",
  docLinks: {
    // TODO
    sdk: "",
    contracts: ""
  },
  abis: [ILoyaltyCardAbi__default["default"]],
  features: {}
};
const FEATURE_NFT_UPDATABLE_METADATA = {
  name: "ERC721UpdatableMetadata",
  namespace: "nft.metadata",
  docLinks: {
    // TODO
    sdk: "",
    contracts: ""
  },
  abis: [Erc721Abi__default["default"], INFTMetadataAbi__default["default"]],
  features: {}
};
const FEATURE_NFT = {
  name: "ERC721",
  namespace: "nft",
  docLinks: {
    sdk: "sdk.erc721",
    contracts: "erc721"
  },
  abis: [Erc721Abi__default["default"], IERC721MetadataAbi__default["default"]],
  features: {
    [FEATURE_NFT_BURNABLE.name]: FEATURE_NFT_BURNABLE,
    [FEATURE_NFT_SUPPLY.name]: FEATURE_NFT_SUPPLY,
    [FEATURE_NFT_MINTABLE.name]: FEATURE_NFT_MINTABLE,
    [FEATURE_NFT_LAZY_MINTABLE.name]: FEATURE_NFT_LAZY_MINTABLE,
    [FEATURE_NFT_SIGNATURE_MINTABLE_V1.name]: FEATURE_NFT_SIGNATURE_MINTABLE_V1,
    [FEATURE_NFT_SIGNATURE_MINTABLE_V2.name]: FEATURE_NFT_SIGNATURE_MINTABLE_V2,
    [FEATURE_NFT_TIERED_DROP.name]: FEATURE_NFT_TIERED_DROP,
    [FEATURE_NFT_CLAIM_CUSTOM.name]: FEATURE_NFT_CLAIM_CUSTOM,
    [FEATURE_NFT_CLAIM_ZORA.name]: FEATURE_NFT_CLAIM_ZORA,
    [FEATURE_NFT_CLAIM_CONDITIONS_V1.name]: FEATURE_NFT_CLAIM_CONDITIONS_V1,
    [FEATURE_NFT_CLAIM_CONDITIONS_V2.name]: FEATURE_NFT_CLAIM_CONDITIONS_V2,
    [FEATURE_NFT_CLAIM_PHASES_V1.name]: FEATURE_NFT_CLAIM_PHASES_V1,
    [FEATURE_NFT_CLAIM_PHASES_V2.name]: FEATURE_NFT_CLAIM_PHASES_V2,
    [FEATURE_NFT_SHARED_METADATA.name]: FEATURE_NFT_SHARED_METADATA,
    [FEATURE_NFT_LOYALTY_CARD.name]: FEATURE_NFT_LOYALTY_CARD,
    [FEATURE_NFT_UPDATABLE_METADATA.name]: FEATURE_NFT_UPDATABLE_METADATA
  }
};

// TODO could be part of IERC1155Metadata even though its not in the spec
const NAME_SYMBOL_ABI = [{
  inputs: [],
  name: "name",
  outputs: [{
    internalType: "string",
    name: "",
    type: "string"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "symbol",
  outputs: [{
    internalType: "string",
    name: "",
    type: "string"
  }],
  stateMutability: "view",
  type: "function"
}];
const FEATURE_EDITION_BURNABLE = {
  name: "ERC1155Burnable",
  namespace: "edition.burn",
  docLinks: {
    sdk: "sdk.erc1155burnable",
    contracts: "erc1155burnable"
  },
  abis: [Erc1155Abi__default["default"], IBurnableERC1155Abi__default["default"]],
  features: {}
};
const FEATURE_EDITION_CLAIM_CONDITIONS_V1 = {
  name: "ERC1155ClaimConditionsV1",
  namespace: "edition.drop.claim",
  docLinks: {
    sdk: "sdk.erc1155claimable",
    contracts: "erc1155dropsinglephase"
  },
  abis: [Erc1155Abi__default["default"], IDropSinglePhase1155_V1__default["default"]],
  features: {}
};
const FEATURE_EDITION_CLAIM_CONDITIONS_V2 = {
  name: "ERC1155ClaimConditionsV2",
  namespace: "edition.drop.claim",
  docLinks: {
    sdk: "sdk.erc1155claimable",
    contracts: "erc1155claimconditions"
  },
  abis: [Erc1155Abi__default["default"], IDropSinglePhase1155__default["default"]],
  features: {}
};
const FEATURE_EDITION_CLAIM_PHASES_V2 = {
  name: "ERC1155ClaimPhasesV2",
  namespace: "edition.drop.claim",
  docLinks: {
    sdk: "sdk.erc1155claimable",
    contracts: "erc1155claimphases"
  },
  abis: [Erc1155Abi__default["default"], IDropMultiPhase1155__default["default"]],
  features: {}
};
const FEATURE_EDITION_CLAIM_PHASES_V1 = {
  name: "ERC1155ClaimPhasesV1",
  namespace: "edition.drop.claim",
  docLinks: {
    sdk: "sdk.erc1155claimable",
    contracts: "erc1155claimphases"
  },
  abis: [DropERC1155_V2Abi__default["default"]],
  features: {}
};
const FEATURE_EDITION_CLAIM_CUSTOM = {
  name: "ERC1155ClaimCustom",
  namespace: "edition.drop.claim",
  docLinks: {
    sdk: "sdk.erc1155claimable",
    contracts: "erc1155claimcustom"
  },
  abis: [Erc1155Abi__default["default"], IClaimableERC1155__default["default"]],
  features: {}
};
const FEATURE_EDITION_REVEALABLE = {
  name: "ERC1155Revealable",
  namespace: "edition.drop.revealer",
  docLinks: {
    sdk: "sdk.drop.delayedreveal",
    contracts: "erc1155revealable"
  },
  abis: [Erc1155Abi__default["default"], ILazyMintAbi__default["default"], DelayedRevealAbi__default["default"]],
  features: {}
};
const FEATURE_EDITION_LAZY_MINTABLE_V2 = {
  name: "ERC1155LazyMintableV2",
  namespace: "edition.drop",
  docLinks: {
    sdk: "sdk.erc1155droppable",
    contracts: "lazymint"
  },
  abis: [Erc1155Abi__default["default"], ILazyMintAbi__default["default"]],
  features: {
    [FEATURE_EDITION_REVEALABLE.name]: FEATURE_EDITION_REVEALABLE
  }
};
const FEATURE_EDITION_LAZY_MINTABLE_V1 = {
  name: "ERC1155LazyMintableV1",
  namespace: "edition.drop",
  docLinks: {
    sdk: "sdk.erc1155droppable",
    contracts: "lazymint"
  },
  abis: [DropERC1155_V2Abi__default["default"]],
  features: {
    [FEATURE_EDITION_CLAIM_PHASES_V1.name]: FEATURE_EDITION_CLAIM_PHASES_V1
  }
};
const FEATURE_EDITION_SIGNATURE_MINTABLE = {
  name: "ERC1155SignatureMintable",
  namespace: "edition.signature",
  docLinks: {
    sdk: "sdk.erc1155signaturemintable",
    contracts: "erc1155signaturemint"
  },
  abis: [Erc1155Abi__default["default"], ISignatureMintERC1155Abi__default["default"]],
  features: {}
};
const FEATURE_EDITION_BATCH_MINTABLE = {
  name: "ERC1155BatchMintable",
  namespace: "edition.mint.batch",
  docLinks: {
    sdk: "sdk.erc1155batchmintable",
    contracts: "erc1155batchmintable"
  },
  abis: [Erc1155Abi__default["default"], IMintableERC1155Abi__default["default"], MulticallAbi__default["default"]],
  features: {}
};
const FEATURE_EDITION_MINTABLE = {
  name: "ERC1155Mintable",
  namespace: "edition.mint",
  docLinks: {
    sdk: "sdk.erc1155mintable",
    contracts: "erc1155mintable"
  },
  abis: [Erc1155Abi__default["default"], IMintableERC1155Abi__default["default"]],
  features: {
    [FEATURE_EDITION_BATCH_MINTABLE.name]: FEATURE_EDITION_BATCH_MINTABLE
  }
};
const FEATURE_EDITION_ENUMERABLE = {
  name: "ERC1155Enumerable",
  namespace: "edition.query",
  docLinks: {
    sdk: "sdk.erc1155",
    contracts: "erc1155enumerable"
  },
  abis: [Erc1155Abi__default["default"], Erc1155EnumerableAbi__default["default"]],
  features: {}
};
const FEATURE_EDITION_UPDATABLE_METADATA = {
  name: "ERC1155UpdatableMetadata",
  namespace: "edition.metadata",
  docLinks: {
    // TODO
    sdk: "",
    contracts: ""
  },
  abis: [Erc1155Abi__default["default"], INFTMetadataAbi__default["default"]],
  features: {}
};
const FEATURE_EDITION_SUPPLY = {
  name: "ERC1155Supply",
  namespace: "edition.supply",
  docLinks: {
    sdk: "",
    contracts: ""
  },
  abis: [Erc1155Abi__default["default"], Erc1155SupplyAbi__default["default"]],
  features: {}
};
const FEATURE_EDITION = {
  name: "ERC1155",
  namespace: "edition",
  docLinks: {
    sdk: "sdk.erc1155enumerable",
    contracts: "erc1155"
  },
  abis: [Erc1155Abi__default["default"], Erc1155MetadataAbi__default["default"], NAME_SYMBOL_ABI],
  features: {
    [FEATURE_EDITION_SUPPLY.name]: FEATURE_EDITION_SUPPLY,
    [FEATURE_EDITION_BURNABLE.name]: FEATURE_EDITION_BURNABLE,
    [FEATURE_EDITION_ENUMERABLE.name]: FEATURE_EDITION_ENUMERABLE,
    [FEATURE_EDITION_MINTABLE.name]: FEATURE_EDITION_MINTABLE,
    [FEATURE_EDITION_LAZY_MINTABLE_V1.name]: FEATURE_EDITION_LAZY_MINTABLE_V1,
    [FEATURE_EDITION_LAZY_MINTABLE_V2.name]: FEATURE_EDITION_LAZY_MINTABLE_V2,
    [FEATURE_EDITION_REVEALABLE.name]: FEATURE_EDITION_REVEALABLE,
    [FEATURE_EDITION_SIGNATURE_MINTABLE.name]: FEATURE_EDITION_SIGNATURE_MINTABLE,
    [FEATURE_EDITION_CLAIM_CUSTOM.name]: FEATURE_EDITION_CLAIM_CUSTOM,
    [FEATURE_EDITION_CLAIM_CONDITIONS_V1.name]: FEATURE_EDITION_CLAIM_CONDITIONS_V1,
    [FEATURE_EDITION_CLAIM_CONDITIONS_V2.name]: FEATURE_EDITION_CLAIM_CONDITIONS_V2,
    [FEATURE_EDITION_CLAIM_PHASES_V2.name]: FEATURE_EDITION_CLAIM_PHASES_V2,
    [FEATURE_EDITION_UPDATABLE_METADATA.name]: FEATURE_EDITION_UPDATABLE_METADATA
  }
};

const fallbackAbi = [{
  stateMutability: "payable",
  type: "fallback"
}];
const getAllPluginsAbi = [{
  inputs: [],
  name: "getAllPlugins",
  outputs: [{
    components: [{
      internalType: "bytes4",
      name: "functionSelector",
      type: "bytes4"
    }, {
      internalType: "string",
      name: "functionSignature",
      type: "string"
    }, {
      internalType: "address",
      name: "pluginAddress",
      type: "address"
    }],
    internalType: "struct IPluginMap.Plugin[]",
    name: "registered",
    type: "tuple[]"
  }],
  stateMutability: "view",
  type: "function"
}];
const getAllExtensionsAbi = [{
  inputs: [],
  name: "getAllExtensions",
  outputs: [{
    components: [{
      components: [{
        internalType: "string",
        name: "name",
        type: "string"
      }, {
        internalType: "string",
        name: "metadataURI",
        type: "string"
      }, {
        internalType: "address",
        name: "implementation",
        type: "address"
      }],
      internalType: "struct IExtension.ExtensionMetadata",
      name: "metadata",
      type: "tuple"
    }, {
      components: [{
        internalType: "bytes4",
        name: "functionSelector",
        type: "bytes4"
      }, {
        internalType: "string",
        name: "functionSignature",
        type: "string"
      }],
      internalType: "struct IExtension.ExtensionFunction[]",
      name: "functions",
      type: "tuple[]"
    }],
    internalType: "struct IExtension.Extension[]",
    name: "allExtensions",
    type: "tuple[]"
  }],
  stateMutability: "view",
  type: "function"
}];
const FEATURE_ROYALTY = {
  name: "Royalty",
  namespace: "royalty",
  docLinks: {
    sdk: "sdk.contractroyalty",
    contracts: "royalty"
  },
  abis: [IThirdwebRoyaltyAbi__default["default"]],
  features: {}
};
const FEATURE_PRIMARY_SALE = {
  name: "PrimarySale",
  namespace: "sales",
  docLinks: {
    sdk: "sdk.contractprimarysale",
    contracts: "primarysale"
  },
  abis: [IThirdwebPrimarySaleAbi__default["default"]],
  features: {}
};
const FEATURE_PLATFORM_FEE = {
  name: "PlatformFee",
  namespace: "platformFees",
  docLinks: {
    sdk: "sdk.platformfee",
    contracts: "platformfee"
  },
  abis: [IThirdwebPlatformFeeAbi__default["default"]],
  features: {}
};
const FEATURE_PERMISSIONS_ENUMERABLE = {
  name: "PermissionsEnumerable",
  namespace: "roles",
  docLinks: {
    sdk: "sdk.contractroles",
    contracts: "permissionsenumerable"
  },
  abis: [IPermissionsEnumerableAbi__default["default"]],
  features: {}
};
const FEATURE_PERMISSIONS = {
  name: "Permissions",
  namespace: "roles",
  docLinks: {
    sdk: "sdk.contractroles",
    contracts: "permissions"
  },
  abis: [IPermissionsAbi__default["default"]],
  features: {
    [FEATURE_PERMISSIONS_ENUMERABLE.name]: FEATURE_PERMISSIONS_ENUMERABLE
  }
};
const FEATURE_METADATA = {
  name: "ContractMetadata",
  namespace: "metadata",
  docLinks: {
    sdk: "sdk.contractmetadata",
    contracts: "contractmetadata"
  },
  abis: [IContractMetadataAbi__default["default"]],
  features: {}
};
const FEATURE_APPURI = {
  name: "AppURI",
  namespace: "appURI",
  docLinks: {
    sdk: "sdk.appURI",
    //TODO
    contracts: ""
  },
  abis: [IAppURI__default["default"]],
  features: {}
};
const FEATURE_OWNER = {
  name: "Ownable",
  namespace: "owner",
  docLinks: {
    sdk: "sdk.owner",
    contracts: "ownable"
  },
  abis: [IOwnableAbi__default["default"]],
  features: {}
};
const FEATURE_GASLESS = {
  name: "Gasless",
  namespace: "gasless",
  docLinks: {
    sdk: "sdk.gaslesstransaction",
    // TODO add the correct name for this once it's added to portal
    contracts: "IERC2771Context"
  },
  abis: [IERC2771ContextAbi__default["default"]],
  features: {}
};
const FEATURE_PACK_VRF = {
  name: "PackVRF",
  namespace: "pack.vrf",
  docLinks: {
    sdk: "sdk.packvrf",
    //TODO
    contracts: "IPackVRF"
  },
  abis: [IPackVRFAbi__default["default"]],
  features: {}
};
const FEATURE_PLUGIN_ROUTER = {
  name: "PluginRouter",
  namespace: "plugin.router",
  docLinks: {
    sdk: "sdk.pluginrouter",
    //TODO
    contracts: "PluginRouter"
  },
  abis: [getAllPluginsAbi],
  features: {}
};
const FEATURE_DYNAMIC_CONTRACT = {
  name: "DynamicContract",
  namespace: "dynamic.contract",
  docLinks: {
    sdk: "",
    //TODO
    contracts: "IExtensionsManager"
  },
  abis: [getAllExtensionsAbi],
  features: {}
};
const FEATURE_DIRECT_LISTINGS = {
  name: "DirectListings",
  namespace: "direct.listings",
  docLinks: {
    // TODO
    sdk: "",
    contracts: "IDirectListings"
  },
  abis: [IDirectListingsAbi__default["default"]],
  features: {}
};
const FEATURE_ENGLISH_AUCTIONS = {
  name: "EnglishAuctions",
  namespace: "english.auctions",
  docLinks: {
    // TODO
    sdk: "",
    contracts: "IEnglishAuctions"
  },
  abis: [IEnglishAuctionsAbi__default["default"]],
  features: {}
};
const FEATURE_OFFERS = {
  name: "Offers",
  namespace: "offers",
  docLinks: {
    // TODO
    sdk: "",
    contracts: "IOffers"
  },
  abis: [IOffersAbi__default["default"]],
  features: {}
};
const FEATURE_ACCOUNT_FACTORY = {
  name: "AccountFactory",
  namespace: "accountFactory",
  docLinks: {
    // TODO
    sdk: "sdk.accountFactory",
    contracts: "IAccountFactory"
  },
  abis: [IAccountFactoryCore__default["default"]],
  features: {}
};
const FEATURE_ACCOUNT_PERMISSIONS_V1 = {
  name: "AccountPermissionsV1",
  namespace: "accountPermissions",
  docLinks: {
    // TODO
    sdk: "sdk.account",
    contracts: "IAccountPermissions"
  },
  abis: [IAccountPermissionsV1__default["default"]],
  features: {}
};
const FEATURE_ACCOUNT_PERMISSIONS = {
  name: "AccountPermissions",
  namespace: "accountPermissions",
  docLinks: {
    // TODO
    sdk: "sdk.account",
    contracts: "IAccountPermissions"
  },
  abis: [IAccountPermissions__default["default"]],
  features: {}
};
const FEATURE_ACCOUNT = {
  name: "Account",
  namespace: "account",
  docLinks: {
    // TODO
    sdk: "sdk.account",
    contracts: "IAccount"
  },
  abis: [IAccount__default["default"]],
  features: {
    [FEATURE_ACCOUNT_PERMISSIONS.name]: FEATURE_ACCOUNT_PERMISSIONS,
    [FEATURE_ACCOUNT_PERMISSIONS_V1.name]: FEATURE_ACCOUNT_PERMISSIONS_V1
  }
};
const FEATURE_AIRDROP_ERC20 = {
  name: "AirdropERC20",
  namespace: "airdrop20",
  docLinks: {
    // TODO
    sdk: "",
    contracts: "IAirdropERC20"
  },
  abis: [IAirdropERC20__default["default"]],
  features: {}
};
const FEATURE_AIRDROP_ERC721 = {
  name: "AirdropERC721",
  namespace: "airdrop721",
  docLinks: {
    // TODO
    sdk: "",
    contracts: "IAirdropERC721"
  },
  abis: [IAirdropERC721__default["default"]],
  features: {}
};
const FEATURE_AIRDROP_ERC1155 = {
  name: "AirdropERC1155",
  namespace: "airdrop1155",
  docLinks: {
    // TODO
    sdk: "",
    contracts: "IAirdropERC1155"
  },
  abis: [IAirdropERC1155__default["default"]],
  features: {}
};
const FEATURE_FALLBACK = {
  name: "Fallback",
  namespace: "fallback",
  docLinks: {
    sdk: "",
    contracts: ""
  },
  abis: [fallbackAbi],
  features: {}
};

/**
 * @internal
 */

/**
 * @internal
 */

/**
 * @internal
 */

/**
 * @internal
 */
const SUPPORTED_FEATURES = {
  [FEATURE_TOKEN.name]: FEATURE_TOKEN,
  [FEATURE_NFT.name]: FEATURE_NFT,
  [FEATURE_EDITION.name]: FEATURE_EDITION,
  [FEATURE_ROYALTY.name]: FEATURE_ROYALTY,
  [FEATURE_PLATFORM_FEE.name]: FEATURE_PLATFORM_FEE,
  [FEATURE_PRIMARY_SALE.name]: FEATURE_PRIMARY_SALE,
  [FEATURE_PERMISSIONS.name]: FEATURE_PERMISSIONS,
  [FEATURE_METADATA.name]: FEATURE_METADATA,
  [FEATURE_APPURI.name]: FEATURE_APPURI,
  [FEATURE_OWNER.name]: FEATURE_OWNER,
  [FEATURE_GASLESS.name]: FEATURE_GASLESS,
  [FEATURE_PACK_VRF.name]: FEATURE_PACK_VRF,
  [FEATURE_PLUGIN_ROUTER.name]: FEATURE_PLUGIN_ROUTER,
  [FEATURE_DYNAMIC_CONTRACT.name]: FEATURE_DYNAMIC_CONTRACT,
  [FEATURE_DIRECT_LISTINGS.name]: FEATURE_DIRECT_LISTINGS,
  [FEATURE_ENGLISH_AUCTIONS.name]: FEATURE_ENGLISH_AUCTIONS,
  [FEATURE_OFFERS.name]: FEATURE_OFFERS,
  [FEATURE_AIRDROP_ERC20.name]: FEATURE_AIRDROP_ERC20,
  [FEATURE_AIRDROP_ERC721.name]: FEATURE_AIRDROP_ERC721,
  [FEATURE_AIRDROP_ERC1155.name]: FEATURE_AIRDROP_ERC1155,
  [FEATURE_ACCOUNT_FACTORY.name]: FEATURE_ACCOUNT_FACTORY,
  [FEATURE_ACCOUNT.name]: FEATURE_ACCOUNT,
  [FEATURE_NFT_LOYALTY_CARD.name]: FEATURE_NFT_LOYALTY_CARD,
  [FEATURE_NFT_UPDATABLE_METADATA.name]: FEATURE_NFT_UPDATABLE_METADATA,
  [FEATURE_FALLBACK.name]: FEATURE_FALLBACK
};

/**
 * @internal
 */
function toJSType(contractType) {
  let isReturnType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  let withName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  let jsType = contractType.type;
  let isArray = false;
  if (jsType.endsWith("[]")) {
    isArray = true;
    jsType = jsType.slice(0, -2);
  }
  if (jsType.startsWith("bytes")) {
    jsType = "BytesLike";
  }
  if (jsType.startsWith("uint") || jsType.startsWith("int")) {
    jsType = isReturnType ? "BigNumber" : "BigNumberish";
  }
  if (jsType.startsWith("bool")) {
    jsType = "boolean";
  }
  if (jsType === "address") {
    jsType = "string";
  }
  if (jsType === "tuple") {
    if (contractType.components) {
      jsType = `{ ${contractType.components.map(a => toJSType(a, false, true)).join(", ")} }`;
    }
  }
  if (isArray) {
    jsType += "[]";
  }
  if (withName) {
    jsType = `${contractType.name}: ${jsType}`;
  }
  return jsType;
}

/**
 * @internal
 * @param name - The name of the function to extract the comment from
 * @param metadata - The metadata to extract the comment from
 * @param type - The type of the function to extract the comment from
 */
function extractCommentFromMetadata(name, metadata, type) {
  return metadata?.output?.userdoc?.[type]?.[Object.keys(metadata?.output?.userdoc[type] || {}).find(fn => fn.includes(name || "unknown")) || ""]?.notice || metadata?.output?.devdoc?.[type]?.[Object.keys(metadata?.output?.devdoc[type] || {}).find(fn => fn.includes(name || "unknown")) || ""]?.details;
}

/**
 * @internal
 * @param abi - The abi to extract functions from
 * @param metadata - The metadata to extract comments from
 */
function extractFunctionsFromAbi(abi, metadata) {
  const functions = (abi || []).filter(el => el.type === "function");
  const parsed = [];
  for (const f of functions) {
    const doc = extractCommentFromMetadata(f.name, metadata, "methods");
    const args = f.inputs?.map(i => `${i.name || "key"}: ${toJSType(i)}`)?.join(", ") || "";
    const fargs = args ? `, [${args}]` : "";
    const out = f.outputs?.map(o => toJSType(o, true))?.join(", ");
    const promise = out ? `: Promise<${out}>` : `: Promise<TransactionResult>`;
    const signature = `contract.call("${f.name}"${fargs})${promise}`;
    parsed.push({
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore we know AbiTypeBaseSchema.name is not going to be undefined since we're doing `.default("")`
      inputs: f.inputs || [],
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore we know the AbiTypeBaseSchema.name is not going to be undefined since we're doing `.default("")`
      outputs: f.outputs || [],
      name: f.name || "unknown",
      signature,
      stateMutability: f.stateMutability || "",
      comment: doc
    });
  }
  return parsed;
}

/**
 * @internal
 * @param contractAbi - The abi to check
 * @param featureAbis - The feature abi to check
 * @returns
 */
function hasMatchingAbi(contractAbi, featureAbis) {
  const contractFn = extractFunctionsFromAbi(contractAbi);
  const interfaceFn = featureAbis.flatMap(i => extractFunctionsFromAbi(i));
  // match every function and their arguments
  const intersection = contractFn.filter(fn => {
    const match = interfaceFn.find(iFn => iFn.name === fn.name && iFn.inputs.length === fn.inputs.length && iFn.inputs.every((i, index) => {
      if (i.type === "tuple" || i.type === "tuple[]") {
        // check that all properties in the tuple are the same type
        return i.type === fn.inputs[index].type && i.components?.every((c, cIndex) => {
          return c.type === fn.inputs[index].components?.[cIndex]?.type;
        });
      }
      return i.type === fn.inputs[index].type;
    }));
    return match !== undefined;
  });
  return intersection.length === interfaceFn.length;
}

/**
 * @internal
 */
function matchesAbiFromBytecode(contractBytecode, featureAbis) {
  const interfaces = featureAbis.map(abi => new utils.Interface(abi));
  const selectors = interfaces.flatMap(i => {
    return Object.values(i.functions).map(fn => Number(i.getSighash(fn)).toString(16));
  });
  const uniqueSelectors = [...new Set(selectors)];
  // checks that all unique selectors are found in the bytecode
  return uniqueSelectors.every(selector => contractBytecode.includes(selector));
}

const lruCache = /* @__PURE__ */createLruCache(10);

/**
 * Processes ALL supported features and sets whether the passed in abi supports each individual feature
 * @internal
 * @param abi - The abi to detect features in
 * @param features - The features to detect
 * @returns The nested struct of all features and whether they're detected in the abi
 */
function detectFeatures(abi) {
  let features = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SUPPORTED_FEATURES;
  const cacheKey = JSON.stringify(abi);
  if (lruCache.has(cacheKey)) {
    return lruCache.get(cacheKey);
  }
  const results = detectFeaturesInternal(abi, features);
  lruCache.put(cacheKey, results);
  return results;
}
function detectFeaturesInternal(abi, features) {
  const results = {};
  for (const featureKey in features) {
    const feature = features[featureKey];
    const enabled = matchesAbiInterface(abi, feature);
    const childResults = detectFeaturesInternal(abi, feature.features);
    results[featureKey] = {
      ...feature,
      features: childResults,
      enabled
    };
  }
  return results;
}

/**
 * @internal
 */
function detectFeaturesFromBytecode(bytecode) {
  let features = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SUPPORTED_FEATURES;
  const results = {};
  for (const featureKey in features) {
    const feature = features[featureKey];
    const enabled = matchesAbiFromBytecode(bytecode, feature.abis);
    const childResults = detectFeaturesFromBytecode(bytecode, feature.features);
    results[featureKey] = {
      ...feature,
      features: childResults,
      enabled
    };
  }
  return results;
}

/**
 * @internal
 * @param abi - The abi to check
 * @param feature - The feature to check
 */
function matchesAbiInterface(abi, feature) {
  // returns true if all the functions in `interfaceToMatch` are found in `contract` (removing any duplicates)
  return hasMatchingAbi(abi, feature.abis);
}

/**
 * @internal
 */
function extractFeatures(input, enabledExtensions) {
  if (!input) {
    return;
  }
  for (const extensionKey in input) {
    const extension = input[extensionKey];
    // if extension is enabled, then add it to enabledFeatures
    if (extension.enabled) {
      enabledExtensions.push(extension);
    }
    // recurse
    extractFeatures(extension.features, enabledExtensions);
  }
}

/**
 * Return all the detected features in the abi
 * @param abi - parsed array of abi entries
 * @returns Array of all detected extensions with full information on each feature
 * @internal
 * @deprecated use getAllDetectedExtensions instead
 */
function getAllDetectedFeatures(abi) {
  const features = [];
  extractFeatures(detectFeatures(abi), features);
  return features;
}

/**
 * @internal
 */
function getAllDetectedExtensionsFromBytecode(bytecode) {
  const features = [];
  extractFeatures(detectFeaturesFromBytecode(bytecode), features);
  return features;
}

/**
 * @internal
 */
function constructAbiFromBytecode(bytecode) {
  let extensions = getAllDetectedExtensionsFromBytecode(bytecode);
  // special deduping for ERC721 and ERC20
  if (extensions.find(f => f.name === "ERC721")) {
    extensions = extensions.filter(f => f.name !== "ERC20");
  }
  const abi = joinABIs(extensions.map(f => joinABIs(f.abis)));
  return abi;
}

/**
 * Return all the detected extensions in the abi
 * @param abi - parsed array of abi entries
 * @returns Array of all detected extensions with full information on each feature
 * @public
 */
function getAllDetectedExtensions(abi) {
  return getAllDetectedFeatures(abi).map(f => ({
    ...f,
    extensions: f.features
  }));
}

const CONTRACT_RESOLVER_BASE_URL = "https://contract.thirdweb.com/metadata";

// Internal static cache
const metadataCache = /* @__PURE__ */createLruCache(20);
let multichainRegistry = undefined;
function getCacheKey(address, chainId) {
  return `${address}-${chainId}`;
}
function putInCache(address, chainId, metadata) {
  metadataCache.put(getCacheKey(address, chainId), metadata);
}

/**
 * @internal
 */
function getContractMetadataFromCache(address, chainId) {
  return metadataCache.get(getCacheKey(address, chainId));
}

/**
 * @internal
 * @param address - The address to fetch the metadata for
 * @param provider - The provider to use
 * @param storage - The storage to use
 */
async function fetchContractMetadataFromAddress(address, provider, storage) {
  let sdkOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  const chainId = (await provider.getNetwork()).chainId; // TODO resolve from sdk network
  const cached = getContractMetadataFromCache(address, chainId);
  if (cached) {
    return cached;
  }
  let metadata;

  // try to resolve from DNS first
  const isLocalChain = chainId === 31337 || chainId === 1337;
  if (!isLocalChain) {
    try {
      const response = await fetch(`${CONTRACT_RESOLVER_BASE_URL}/${chainId}/${address}`, {
        headers: {
          ...getAnalyticsHeaders()
        }
      });
      if (response.ok) {
        const resolvedData = await response.json();
        metadata = formatCompilerMetadata(resolvedData);
      }
    } catch (e) {
      // fallback to IPFS
    }
  }
  if (!metadata) {
    metadata = await fetchContractMetadataFromBytecode(address, chainId, provider, storage, sdkOptions);
  }
  if (!metadata) {
    throw new Error(`Could not resolve contract. Try importing it by visiting: https://thirdweb.com/${chainId}/${address}`);
  }
  if (!metadata.isPartialAbi) {
    putInCache(address, chainId, metadata);
  } else {
    console.warn(`Contract metadata could only be partially resolved, some contract functions might be unavailable. Try importing the contract by visiting: https://thirdweb.com/${chainId}/${address}`);
  }
  return metadata;
}

/**
 * @internal
 */
async function fetchContractMetadataFromBytecode(address, chainId, provider, storage) {
  let sdkOptions = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
  let metadata;
  // we can't race here, because the contract URI might resolve first with a non pinned URI
  const [ipfsData, registryData] = await Promise.all([resolveContractUriAndBytecode(address, provider).catch(() => undefined), getMetadataUriFromMultichainRegistry(address, chainId, sdkOptions).then(uri => {
    if (!uri) {
      return undefined;
    }
    return {
      uri,
      bytecode: ""
    };
  }).catch(() => undefined)]);
  const bytecode = ipfsData?.bytecode;
  const metadataUri = registryData?.uri || ipfsData?.uri;
  if (!metadataUri && !bytecode) {
    throw new Error(`Could not fetch bytecode for contract at ${address} on chain ${chainId}, double check that the address and chainId are correct.`);
  }
  try {
    metadata = await fetchContractMetadata(metadataUri, storage);
  } catch (e) {
    // Don't warn here, its common to not have IPFS metadata for a contract, fallback to bytecode
  }
  if (!metadata && bytecode) {
    const abi = constructAbiFromBytecode(bytecode);
    if (abi && abi.length > 0) {
      // return partial ABI
      metadata = {
        name: "Unimported Contract",
        abi: abi,
        metadata: {},
        info: {},
        licenses: [],
        isPartialAbi: true
      };
      // return without caching
      return metadata;
    }
  }
  return metadata;
}
async function getMetadataUriFromMultichainRegistry(address, chainId, sdkOptions) {
  const TWRegistryABI = (await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@thirdweb-dev/contracts-js/dist/abis/TWMultichainRegistryLogic.json')); })).default;
  if (!multichainRegistry) {
    const polygonChain = sdkOptions?.supportedChains?.find(c => c.chainId === 137);
    const chain = polygonChain || chains.Polygon;
    multichainRegistry = new ethers.Contract(getMultichainRegistryAddress(), TWRegistryABI, getChainProvider(chain, sdkOptions));
  }
  const importedUri = await multichainRegistry.getMetadataUri(chainId, address);
  return importedUri;
}

/**
 * @internal
 * @param address - The address to fetch the metadata for
 * @param provider - The provider to use
 * @param storage - The storage to use
 * @returns
 */
async function fetchAbiFromAddress(address, provider, storage) {
  try {
    const metadata = await fetchContractMetadataFromAddress(address, provider, storage);
    if (metadata && metadata.abi) {
      return metadata.abi;
    }
  } catch (e) {
    // ignore and return undefined
    // will fallback to embedded ABIs for prebuilts
  }
  return undefined;
}

async function getCompositeABIfromRelease(publishMetadataUri, storage) {
  const {
    extendedMetadata
  } = await fetchAndCacheDeployMetadata(publishMetadataUri, storage);
  const compositeAbi = extendedMetadata?.compositeAbi || [];
  return compositeAbi;
}

const ERROR_SUBSTRINGS = ["eip-155", "eip155", "protected", "invalid chain id for signer", "chain id none", "chain_id mismatch", "recovered sender mismatch", "transaction hash mismatch", "chainid no support", "chainid (0)", "chainid(0)"];
const ERROR_SUBSTRINGS_COMPOSITE = [["account", "not found"], ["wrong", "chainid"]];
const CUSTOM_GAS_BINS = [1, 1 * 10 ** 9, 100 * 10 ** 9, 500 * 10 ** 9, 1000 * 10 ** 9, 2500 * 10 ** 9, 5000 * 10 ** 9, 7500 * 10 ** 9, 10_000 * 10 ** 9, 25_000 * 10 ** 9, 50_000 * 10 ** 9, 75_000 * 10 ** 9, 100_000 * 10 ** 9, 250_000 * 10 ** 9, 500_000 * 10 ** 9, 750_000 * 10 ** 9, 1_000_000 * 10 ** 9];

/* eslint-disable no-useless-computed-key */
const CUSTOM_GAS_FOR_CHAIN = {
  [5001]: {
    name: "Mantle Testnet",
    gasPrice: 1
  },
  [71402]: {
    name: "Godwoken Mainnet",
    gasPrice: 40000 * 10 ** 9
  },
  [1351057110]: {
    name: "Chaos (SKALE Testnet)",
    gasPrice: 100000
  },
  [361]: {
    name: "Theta Mainnet",
    gasPrice: 4000 * 10 ** 9
  },
  [365]: {
    name: "Theta Testnet",
    gasPrice: 4000 * 10 ** 9
  },
  [7700]: {
    name: "Canto",
    gasPrice: 1000 * 10 ** 9
  },
  [7701]: {
    name: "Canto Testnet",
    gasPrice: 1000 * 10 ** 9
  },
  [338]: {
    name: "Cronos Testnet",
    gasPrice: 2000 * 10 ** 9
  },
  [47]: {
    name: "Xpla Testnet",
    gasPrice: 850 * 10 ** 9
  },
  [37]: {
    name: "Xpla Mainnet",
    gasPrice: 5100 * 10 ** 9
  },
  [199]: {
    name: "BitTorrent Chain",
    gasPrice: 300000 * 10 ** 9
  },
  [88882]: {
    name: "Spicy Chain",
    gasPrice: 2500 * 10 ** 9,
    gasLimit: 200000
  },
  [88888]: {
    name: "Chiliz Chain",
    gasPrice: 2500 * 10 ** 9,
    gasLimit: 200000
  }
};
function matchError(error) {
  const hasError = ERROR_SUBSTRINGS.some(substring => error.includes(substring));
  // can early exit if we find a match
  if (hasError) {
    return true;
  }
  const hasCompositeError = ERROR_SUBSTRINGS_COMPOSITE.some(arr => {
    return arr.some(substring => error.includes(substring));
  });
  return hasCompositeError;
}

/**
 * @internal
 */
const CREATE2_FACTORY_BYTECODE = "0x604580600e600039806000f350fe7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf3";
/**
 * @internal
 */
const SIGNATURE = {
  v: 27,
  r: "0x2222222222222222222222222222222222222222222222222222222222222222",
  s: "0x2222222222222222222222222222222222222222222222222222222222222222"
};
const COMMON_FACTORY = "0x4e59b44847b379578588920cA78FbF26c0B4956C"; // for pre-eip-155 supporting chains

/**
 * @internal
 */
const GAS_LIMIT_FOR_DEPLOYER = 5000000;
/**
 * @internal
 */
const DEPLOYER_BYTECODE = "0x60806040526040516107f33803806107f383398101604081905261002291610359565b805160005b818110156100c157828181518110610041576100416104c9565b6020026020010151600001516001600160a01b03163b600014156100af576100ad838281518110610074576100746104c9565b602002602001015160200151848381518110610092576100926104c9565b6020026020010151604001516100c960201b6100091760201c565b505b806100b9816104df565b915050610027565b505050610557565b606061011183836040518060400160405280601e81526020017f416464726573733a206c6f772d6c6576656c2063616c6c206661696c6564000081525061011860201b60201c565b9392505050565b6060610127848460008561012f565b949350505050565b6060824710156101955760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b60648201526084015b60405180910390fd5b6001600160a01b0385163b6101ec5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000604482015260640161018c565b600080866001600160a01b031685876040516102089190610508565b60006040518083038185875af1925050503d8060008114610245576040519150601f19603f3d011682016040523d82523d6000602084013e61024a565b606091505b50909250905061025b828286610266565b979650505050505050565b60608315610275575081610111565b8251156102855782518084602001fd5b8160405162461bcd60e51b815260040161018c9190610524565b634e487b7160e01b600052604160045260246000fd5b604051606081016001600160401b03811182821017156102d7576102d761029f565b60405290565b604051601f8201601f191681016001600160401b03811182821017156103055761030561029f565b604052919050565b80516001600160a01b038116811461032457600080fd5b919050565b60005b8381101561034457818101518382015260200161032c565b83811115610353576000848401525b50505050565b6000602080838503121561036c57600080fd5b82516001600160401b038082111561038357600080fd5b818501915085601f83011261039757600080fd5b8151818111156103a9576103a961029f565b8060051b6103b88582016102dd565b91825283810185019185810190898411156103d257600080fd5b86860192505b838310156104bc578251858111156103f05760008081fd5b86016060601f19828d0381018213156104095760008081fd5b6104116102b5565b61041c8b850161030d565b8152604061042b81860161030d565b828d01529284015192898411156104425760008081fd5b83850194508e603f86011261045957600093508384fd5b8b85015193508984111561046f5761046f61029f565b61047f8c84601f870116016102dd565b92508383528e818587010111156104965760008081fd5b6104a5848d8501838801610329565b8101919091528452505091860191908601906103d8565b9998505050505050505050565b634e487b7160e01b600052603260045260246000fd5b600060001982141561050157634e487b7160e01b600052601160045260246000fd5b5060010190565b6000825161051a818460208701610329565b9190910192915050565b6020815260008251806020840152610543816040850160208701610329565b601f01601f19169190910160400192915050565b61028d806105666000396000f3fe6080604052600080fd5b606061004b83836040518060400160405280601e81526020017f416464726573733a206c6f772d6c6576656c2063616c6c206661696c65640000815250610052565b9392505050565b60606100618484600085610069565b949350505050565b6060824710156100cf5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b60648201526084015b60405180910390fd5b6001600160a01b0385163b6101265760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016100c6565b600080866001600160a01b031685876040516101429190610208565b60006040518083038185875af1925050503d806000811461017f576040519150601f19603f3d011682016040523d82523d6000602084013e610184565b606091505b509150915061019482828661019f565b979650505050505050565b606083156101ae57508161004b565b8251156101be5782518084602001fd5b8160405162461bcd60e51b81526004016100c69190610224565b60005b838110156101f35781810151838201526020016101db565b83811115610202576000848401525b50505050565b6000825161021a8184602087016101d8565b9190910192915050565b60208152600082518060208401526102438160408501602087016101d8565b601f01601f1916919091016040019291505056fea26469706673582212200b524eb8ceaafe6c603273ee859fddbc2d6f1b7860c3d853dcf6f129f9d9371364736f6c634300080c0033";
/**
 * @internal
 */
const DEPLOYER_ABI = [{
  inputs: [{
    components: [{
      internalType: "address",
      name: "predictedAddress",
      type: "address"
    }, {
      internalType: "address",
      name: "to",
      type: "address"
    }, {
      internalType: "bytes",
      name: "data",
      type: "bytes"
    }],
    internalType: "struct IDeployer.Transaction[]",
    name: "transactions",
    type: "tuple[]"
  }],
  stateMutability: "payable",
  type: "constructor"
}];

/**
 * Check if a contract exists at the given address
 * @deploy
 * @public
 * @param address - The address to check
 * @param provider - The provider to use
 */
async function isContractDeployed(address, provider) {
  const code = await provider.getCode(address);
  return code !== "0x" && code !== "0x0";
}

/**
 * Check if a chain enforces EIP-155 transactions
 * Ref: https://eips.ethereum.org/EIPS/eip-155
 *
 * @internal
 * @param provider - The provider to use
 */
async function isEIP155Enforced(provider) {
  try {
    // TODO: Find a better way to check this.

    // Send a random transaction of legacy type (pre-eip-155).
    // It will fail. Parse the error message to check whether eip-155 is enforced.
    await provider.sendTransaction("0xf8a58085174876e800830186a08080b853604580600e600039806000f350fe7fffffffffffffffafffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf31ba02222222222222222222222222222222222222222222222222222222222222222a02222222222222222222222222222222222222222222222222222222222222222");
  } catch (e) {
    const errorMsg = e.toString().toLowerCase();
    const errorJson = JSON.stringify(e).toLowerCase();
    if (matchError(errorMsg) || matchError(errorJson)) {
      return true;
    }
    return false;
  }
  return false;
}

/**
 * Generate a transaction to be sent with a keyless signer.
 * @deploy
 * @public
 * @param transaction - Unsigned transaction object
 * @param signature - Signature bytes
 */
function getKeylessTxn(transaction, signature) {
  // 1. Create serialized txn string
  const digest = ethers.utils.arrayify(ethers.utils.keccak256(ethers.utils.serializeTransaction(transaction)));

  // 2. Determine signer address from custom signature + txn
  const signer = ethers.utils.recoverAddress(digest, signature);

  // 3. Create the signed serialized txn string.
  // To be sent directly to the chain using a provider.
  const signedSerializedTx = ethers.utils.serializeTransaction(transaction, signature);
  return {
    signer: signer,
    transaction: signedSerializedTx
  };
}

/**
 *
 * @internal
 * @param transaction - Unsigned transaction object
 * @param signature - Signature bytes
 */
function getCreate2FactoryDeploymentInfo(chainId, gasOptions) {
  const signature = ethers.utils.joinSignature(SIGNATURE);

  // 100000 is default deployment gas limit and 100 gwei is default gas price for create2 factory deployment
  // (See: https://github.com/Arachnid/deterministic-deployment-proxy?tab=readme-ov-file#deployment-gas-limit)
  const gasPrice = gasOptions.gasPrice ? gasOptions.gasPrice : 100 * 10 ** 9;
  const gasLimit = gasOptions.gasLimit ? gasOptions.gasLimit : 100000;
  const deploymentTransaction = getKeylessTxn({
    gasPrice,
    gasLimit,
    nonce: 0,
    data: CREATE2_FACTORY_BYTECODE,
    chainId: chainId
  }, signature);
  const create2FactoryAddress = ethers.utils.getContractAddress({
    from: deploymentTransaction.signer,
    nonce: 0
  });
  return {
    ...deploymentTransaction,
    deployment: create2FactoryAddress,
    valueToSend: ethers.BigNumber.from(gasPrice).mul(gasLimit)
  };
}

/**
 * Get the CREATE2 Factory address for a network
 * Source code of the factory:
 * https://github.com/Arachnid/deterministic-deployment-proxy/blob/master/source/deterministic-deployment-proxy.yul
 *
 * @internal
 * @param provider - The provider to use
 */
async function getCreate2FactoryAddress(provider) {
  const deploymentInfo = await computeCreate2FactoryTransaction(provider);
  return deploymentInfo.deployment;
}

/**
 * @internal
 */
async function computeCreate2FactoryTransaction(provider) {
  const networkId = (await provider.getNetwork()).chainId;

  // special handling for chains with hardcoded gasPrice and gasLimit
  if (CUSTOM_GAS_FOR_CHAIN[networkId]) {
    const enforceEip155 = await isEIP155Enforced(provider);
    const chainId = enforceEip155 ? networkId : 0;
    const gasPrice = CUSTOM_GAS_FOR_CHAIN[networkId]?.gasPrice;
    const gasLimit = CUSTOM_GAS_FOR_CHAIN[networkId]?.gasLimit;
    const deploymentInfo = getCreate2FactoryDeploymentInfo(chainId, {
      gasPrice: gasPrice ? ethers.BigNumber.from(gasPrice) : undefined,
      gasLimit: gasLimit ? ethers.BigNumber.from(gasLimit) : undefined
    });
    if (await isContractDeployed(deploymentInfo.deployment, provider)) {
      deploymentInfo.transaction = "";
    }
    return deploymentInfo;
  }

  // default flow
  const allBinsInfo = [...CUSTOM_GAS_BINS.map(b =>
  // to generate EIP-155 transaction
  getCreate2FactoryDeploymentInfo(networkId, {
    gasPrice: ethers.BigNumber.from(b)
  })),
  // to generate pre-EIP-155 transaction, hence chainId 0
  ...CUSTOM_GAS_BINS.map(b => getCreate2FactoryDeploymentInfo(0, {
    gasPrice: ethers.BigNumber.from(b)
  }))];
  const allFactories = await Promise.all(allBinsInfo.map(b => isContractDeployed(b.deployment, provider)));
  const indexOfCommonFactory = allBinsInfo.findIndex(b => b.deployment === COMMON_FACTORY);
  if (indexOfCommonFactory && allFactories[indexOfCommonFactory]) {
    return {
      ...allBinsInfo[indexOfCommonFactory],
      transaction: ""
    };
  }
  const indexOfExistingDeployment = allFactories.findIndex(b => b);
  if (indexOfExistingDeployment && allBinsInfo[indexOfExistingDeployment]) {
    return {
      ...allBinsInfo[indexOfExistingDeployment],
      transaction: ""
    };
  }
  const [enforceEip155, gasPriceFetched] = await Promise.all([isEIP155Enforced(provider), provider.getGasPrice()]);
  const chainId = enforceEip155 ? networkId : 0;
  const bin = _getNearestGasPriceBin(gasPriceFetched);
  return getCreate2FactoryDeploymentInfo(chainId, {
    gasPrice: bin
  });
}
function _getNearestGasPriceBin(gasPrice) {
  const bin = CUSTOM_GAS_BINS.find(e => ethers.BigNumber.from(e).gte(gasPrice));
  return bin ? ethers.BigNumber.from(bin) : gasPrice;
}

const bytecode = "0x60606040526040805190810160405280600d81526020017f57726170706564204574686572000000000000000000000000000000000000008152506000908051906020019061004f9291906100c8565b506040805190810160405280600481526020017f57455448000000000000000000000000000000000000000000000000000000008152506001908051906020019061009b9291906100c8565b506012600260006101000a81548160ff021916908360ff16021790555034156100c357600080fd5b61016d565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061010957805160ff1916838001178555610137565b82800160010185558215610137579182015b8281111561013657825182559160200191906001019061011b565b5b5090506101449190610148565b5090565b61016a91905b8082111561016657600081600090555060010161014e565b5090565b90565b610c348061017c6000396000f3006060604052600436106100af576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806306fdde03146100b9578063095ea7b31461014757806318160ddd146101a157806323b872dd146101ca5780632e1a7d4d14610243578063313ce5671461026657806370a082311461029557806395d89b41146102e2578063a9059cbb14610370578063d0e30db0146103ca578063dd62ed3e146103d4575b6100b7610440565b005b34156100c457600080fd5b6100cc6104dd565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561010c5780820151818401526020810190506100f1565b50505050905090810190601f1680156101395780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561015257600080fd5b610187600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803590602001909190505061057b565b604051808215151515815260200191505060405180910390f35b34156101ac57600080fd5b6101b461066d565b6040518082815260200191505060405180910390f35b34156101d557600080fd5b610229600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803590602001909190505061068c565b604051808215151515815260200191505060405180910390f35b341561024e57600080fd5b61026460048080359060200190919050506109d9565b005b341561027157600080fd5b610279610b05565b604051808260ff1660ff16815260200191505060405180910390f35b34156102a057600080fd5b6102cc600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610b18565b6040518082815260200191505060405180910390f35b34156102ed57600080fd5b6102f5610b30565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561033557808201518184015260208101905061031a565b50505050905090810190601f1680156103625780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561037b57600080fd5b6103b0600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091908035906020019091905050610bce565b604051808215151515815260200191505060405180910390f35b6103d2610440565b005b34156103df57600080fd5b61042a600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610be3565b6040518082815260200191505060405180910390f35b34600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055503373ffffffffffffffffffffffffffffffffffffffff167fe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c346040518082815260200191505060405180910390a2565b60008054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156105735780601f1061054857610100808354040283529160200191610573565b820191906000526020600020905b81548152906001019060200180831161055657829003601f168201915b505050505081565b600081600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925846040518082815260200191505060405180910390a36001905092915050565b60003073ffffffffffffffffffffffffffffffffffffffff1631905090565b600081600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054101515156106dc57600080fd5b3373ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff16141580156107b457507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205414155b156108cf5781600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541015151561084457600080fd5b81600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825403925050819055505b81600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254039250508190555081600360008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a3600190509392505050565b80600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205410151515610a2757600080fd5b80600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825403925050819055503373ffffffffffffffffffffffffffffffffffffffff166108fc829081150290604051600060405180830381858888f193505050501515610ab457600080fd5b3373ffffffffffffffffffffffffffffffffffffffff167f7fcf532c15f0a6db0bd6d0e038bea71d30d808c7d98cb3bf7268a95bf5081b65826040518082815260200191505060405180910390a250565b600260009054906101000a900460ff1681565b60036020528060005260406000206000915090505481565b60018054600181600116156101000203166002900480601f016020809104026020016040519081016040528092919081815260200182805460018160011615610100020316600290048015610bc65780601f10610b9b57610100808354040283529160200191610bc6565b820191906000526020600020905b815481529060010190602001808311610ba957829003601f168201915b505050505081565b6000610bdb33848461068c565b905092915050565b60046020528160005260406000206020528060005260406000206000915091505054815600a165627a7a72305820deb4c2ccab3c2fdca32ab3f46728389c2fe2c165d5fafa07661e4e004f6c344a0029";

/**
 * Generate salt for deployment with Create2
 * Note: Salt component is generated by appending `tw` (thirdweb) to the bytecode
 *
 * @internal
 * @param bytecode - Creation bytecode of the contract to deploy
 */
function getSaltHash(bytecode) {
  const bytecodePrefixed = bytecode.startsWith("0x") ? bytecode : `0x${bytecode}`;
  const bytecodeHash = ethers.utils.id(bytecodePrefixed);
  const salt = `tw.${bytecodeHash}`;
  const saltHash = ethers.utils.id(salt);
  return saltHash;
}

/**
 *
 * Construct init-bytecode, packed with salthash.
 * This hex data is intended to be sent to the CREATE2 factory address
 *
 * @internal
 * @param bytecode - Creation bytecode of the contract to deploy
 * @param encodedArgs - Abi-encoded constructor params
 */
function getInitBytecodeWithSalt(bytecode, encodedArgs, salt) {
  const bytecodePrefixed = bytecode.startsWith("0x") ? bytecode : `0x${bytecode}`;
  const saltHash = salt ? ethers.utils.id(salt) : getSaltHash(bytecodePrefixed);
  const initBytecodeWithSalt = ethers.utils.solidityPack(["bytes32", "bytes", "bytes"], [saltHash, bytecodePrefixed, encodedArgs]);
  return initBytecodeWithSalt;
}

/**
 * Pre-compute a contract's deployment address for a CREATE2 deployment.
 *
 * @internal
 * @param bytecode - Creation bytecode of the contract to deploy
 * @param encodedArgs - Abi-encoded constructor params
 * @param create2FactoryAddress - The create2 factory address to use
 */
function computeDeploymentAddress(bytecode, encodedArgs, create2FactoryAddress, salt) {
  const bytecodePrefixed = bytecode.startsWith("0x") ? bytecode : `0x${bytecode}`;
  const saltHash = salt ? ethers.utils.id(salt) : getSaltHash(bytecodePrefixed);

  // 1. create init bytecode hash with contract's bytecode and encoded args
  const initBytecode = ethers.utils.solidityPack(["bytes", "bytes"], [bytecodePrefixed, encodedArgs]);

  // 2. abi-encode pack the deployer address, salt, and bytecode hash
  const deployInfoPacked = ethers.utils.solidityPack(["bytes1", "address", "bytes32", "bytes32"], ["0xff", create2FactoryAddress, saltHash, ethers.utils.solidityKeccak256(["bytes"], [initBytecode])]);

  // 3. hash the packed deploy info
  const hashedDeployInfo = ethers.utils.solidityKeccak256(["bytes"], [deployInfoPacked]);

  // 4. return last 20 bytes (40 characters) of the hash -- this is the predicted address
  return `0x${hashedDeployInfo.slice(26)}`;
}

/**
 * @public
 */
let ChainId = /*#__PURE__*/function (ChainId) {
  ChainId[ChainId["Mainnet"] = 1] = "Mainnet";
  ChainId[ChainId["Goerli"] = 5] = "Goerli";
  ChainId[ChainId["Polygon"] = 137] = "Polygon";
  ChainId[ChainId["Mumbai"] = 80001] = "Mumbai";
  ChainId[ChainId["Localhost"] = 1337] = "Localhost";
  ChainId[ChainId["Hardhat"] = 31337] = "Hardhat";
  ChainId[ChainId["Fantom"] = 250] = "Fantom";
  ChainId[ChainId["FantomTestnet"] = 4002] = "FantomTestnet";
  ChainId[ChainId["Avalanche"] = 43114] = "Avalanche";
  ChainId[ChainId["AvalancheFujiTestnet"] = 43113] = "AvalancheFujiTestnet";
  ChainId[ChainId["Optimism"] = 10] = "Optimism";
  ChainId[ChainId["OptimismGoerli"] = 420] = "OptimismGoerli";
  ChainId[ChainId["Arbitrum"] = 42161] = "Arbitrum";
  ChainId[ChainId["ArbitrumGoerli"] = 421613] = "ArbitrumGoerli";
  ChainId[ChainId["BinanceSmartChainMainnet"] = 56] = "BinanceSmartChainMainnet";
  ChainId[ChainId["BinanceSmartChainTestnet"] = 97] = "BinanceSmartChainTestnet";
  return ChainId;
}({});

/**
 * @public
 */
const NATIVE_TOKEN_ADDRESS = "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee";

/**
 * @public
 */
const NATIVE_TOKENS = {
  [ChainId.Mainnet]: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.Goerli]: {
    name: "Görli Ether",
    symbol: "GOR",
    decimals: 18,
    wrapped: {
      address: "0xb4fbf271143f4fbf7b91a5ded31805e42b2208d6",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  11155111: {
    name: "Sepolia Ether",
    symbol: "SEP",
    decimals: 18,
    wrapped: {
      address: "0x7b79995e5f793A07Bc00c21412e50Ecae098E7f9",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.Polygon]: {
    name: "Matic",
    symbol: "MATIC",
    decimals: 18,
    wrapped: {
      address: "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270",
      name: "Wrapped Matic",
      symbol: "WMATIC"
    }
  },
  [ChainId.Mumbai]: {
    name: "Matic",
    symbol: "MATIC",
    decimals: 18,
    wrapped: {
      address: "0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889",
      name: "Wrapped Matic",
      symbol: "WMATIC"
    }
  },
  [ChainId.Avalanche]: {
    name: "Avalanche",
    symbol: "AVAX",
    decimals: 18,
    wrapped: {
      address: "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7",
      name: "Wrapped AVAX",
      symbol: "WAVAX"
    }
  },
  [ChainId.AvalancheFujiTestnet]: {
    name: "Avalanche",
    symbol: "AVAX",
    decimals: 18,
    wrapped: {
      address: "0xd00ae08403B9bbb9124bB305C09058E32C39A48c",
      name: "Wrapped AVAX",
      symbol: "WAVAX"
    }
  },
  [ChainId.Fantom]: {
    name: "Fantom",
    symbol: "FTM",
    decimals: 18,
    wrapped: {
      address: "0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83",
      name: "Wrapped Fantom",
      symbol: "WFTM"
    }
  },
  [ChainId.FantomTestnet]: {
    name: "Fantom",
    symbol: "FTM",
    decimals: 18,
    wrapped: {
      address: "0xf1277d1Ed8AD466beddF92ef448A132661956621",
      name: "Wrapped Fantom",
      symbol: "WFTM"
    }
  },
  [ChainId.Arbitrum]: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x82af49447d8a07e3bd95bd0d56f35241523fbab1",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.ArbitrumGoerli]: {
    name: "Arbitrum Goerli Ether",
    symbol: "AGOR",
    decimals: 18,
    wrapped: {
      address: "0xe39Ab88f8A4777030A534146A9Ca3B52bd5D43A3",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.Optimism]: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x4200000000000000000000000000000000000006",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.OptimismGoerli]: {
    name: "Goerli Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x4200000000000000000000000000000000000006",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.BinanceSmartChainMainnet]: {
    name: "Binance Chain Native Token",
    symbol: "BNB",
    decimals: 18,
    wrapped: {
      address: "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
      name: "Wrapped Binance Chain Token",
      symbol: "WBNB"
    }
  },
  [ChainId.BinanceSmartChainTestnet]: {
    name: "Binance Chain Native Token",
    symbol: "TBNB",
    decimals: 18,
    wrapped: {
      address: "0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd",
      name: "Wrapped Binance Chain Testnet Token",
      symbol: "WBNB"
    }
  },
  [ChainId.Hardhat]: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x5FbDB2315678afecb367f032d93F642f64180aa3",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  [ChainId.Localhost]: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x5FbDB2315678afecb367f032d93F642f64180aa3",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  84531: {
    name: "Base Goerli Testnet",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x4200000000000000000000000000000000000006",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  },
  // eslint-disable-next-line no-useless-computed-key
  [280]: {
    name: "zkSync Era Testnet",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: "0x5AEa5775959fBC2557Cc8789bC1bf90A239D9a91",
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  }
};

/**
 * Returns the native token for a given chain
 * @param chainId - the chain id
 * @public
 */
function getNativeTokenByChainId(chainId) {
  const chain = getSupportedChains().find(c => c.chainId === chainId);
  if (chain && chain.nativeCurrency) {
    return {
      name: chain.nativeCurrency.name,
      symbol: chain.nativeCurrency.symbol,
      decimals: 18,
      wrapped: {
        address: ethers.constants.AddressZero,
        name: `Wrapped ${chain.nativeCurrency.name}`,
        symbol: `W${chain.nativeCurrency.symbol}`
      }
    };
  }
  return NATIVE_TOKENS[chainId] || {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    wrapped: {
      address: ethers.constants.AddressZero,
      name: "Wrapped Ether",
      symbol: "WETH"
    }
  };
}
const LINK_TOKEN_ADDRESS = {
  [ChainId.Mainnet]: "0x514910771AF9Ca656af840dff83E8264EcF986CA",
  [ChainId.Goerli]: "0x326C977E6efc84E512bB9C30f76E30c160eD06FB",
  [ChainId.BinanceSmartChainMainnet]: "0x404460C6A5EdE2D891e8297795264fDe62ADBB75",
  [ChainId.Polygon]: "0xb0897686c545045aFc77CF20eC7A532E3120E0F1",
  [ChainId.Mumbai]: "0x326C977E6efc84E512bB9C30f76E30c160eD06FB",
  [ChainId.Avalanche]: "0x5947BB275c521040051D82396192181b413227A3",
  [ChainId.AvalancheFujiTestnet]: "0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846",
  [ChainId.Fantom]: "0x6F43FF82CCA38001B6699a8AC47A2d0E66939407",
  [ChainId.FantomTestnet]: "0xfaFedb041c0DD4fA2Dc0d87a6B0979Ee6FA7af5F"
};

/**
 *
 * @param abi - The abi to extract constructor params from
 * @returns
 * @internal
 */
function extractConstructorParamsFromAbi(abi) {
  const parsedAbi = AbiSchema.parse(abi || []);
  for (const input of parsedAbi) {
    if (input.type === "constructor") {
      return input.inputs || [];
    }
  }
  return [];
}

const caches = {
  deploymentPresets: {}
};

/**
 * Returns the RoyaltyEngineV1 address for a given chain
 * @param chainId - the chain id
 * @public
 */
function getRoyaltyEngineV1ByChainId(chainId) {
  return ROYALTY_ENGINE_V1_ADDRESS[chainId] || ethers.constants.AddressZero;
}
const ROYALTY_ENGINE_V1_ADDRESS = {
  [ChainId.Mainnet]: "0x0385603ab55642cb4dd5de3ae9e306809991804f",
  [ChainId.Goerli]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
  [ChainId.BinanceSmartChainMainnet]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
  [ChainId.Polygon]: "0x28EdFcF0Be7E86b07493466e7631a213bDe8eEF2",
  [ChainId.Mumbai]: "0x0a01E11887f727D1b1Cd81251eeEE9BEE4262D07",
  [ChainId.Avalanche]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
  [ChainId.Optimism]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15",
  [ChainId.Arbitrum]: "0xEF770dFb6D5620977213f55f99bfd781D04BBE15"
};

const AddressZero = "0x0000000000000000000000000000000000000000";

/**
 * @internal
 */
async function computeDeploymentInfo(contractType, provider, storage, create2Factory, contractOptions, clientId, secretKey) {
  const contractName = contractOptions && contractOptions.contractName;
  const version = contractOptions && contractOptions.version;
  let publisherAddress = contractOptions && contractOptions.publisherAddress;
  let metadata = contractOptions && contractOptions.metadata;
  invariant__default["default"](contractName || metadata, "Require contract name or metadata");
  if (contractName && caches.deploymentPresets[contractName]) {
    return caches.deploymentPresets[contractName];
  }

  // Different treatment for WETH contract
  if (contractName === "WETH9") {
    const address = computeDeploymentAddress(bytecode, [], create2Factory);
    const contractDeployed = await isContractDeployed(address, provider);
    let initBytecodeWithSalt = "";
    if (!contractDeployed) {
      initBytecodeWithSalt = getInitBytecodeWithSalt(bytecode, []);
    }
    return {
      name: contractName,
      type: contractType,
      transaction: {
        predictedAddress: address,
        to: create2Factory,
        data: initBytecodeWithSalt
      }
    };
  }
  if (!metadata) {
    invariant__default["default"](contractName, "Require contract name");
    if (!publisherAddress) {
      publisherAddress = THIRDWEB_DEPLOYER;
    }
    const publishedContract = await fetchPublishedContractFromPolygon(publisherAddress, contractName, version, storage, clientId, secretKey);
    metadata = (await fetchAndCacheDeployMetadata(publishedContract.metadataUri, storage)).compilerMetadata;
  }
  const encodedArgs = await encodeConstructorParamsForImplementation(metadata, provider, storage, create2Factory, contractOptions?.constructorParams, clientId, secretKey);
  const address = computeDeploymentAddress(metadata.bytecode, encodedArgs, create2Factory);
  const contractDeployed = await isContractDeployed(address, provider);
  let initBytecodeWithSalt = "";
  if (!contractDeployed) {
    initBytecodeWithSalt = getInitBytecodeWithSalt(metadata.bytecode, encodedArgs);
  }
  return {
    name: contractName,
    type: contractType,
    transaction: {
      predictedAddress: address,
      to: create2Factory,
      data: initBytecodeWithSalt
    },
    encodedArgs
  };
}

/**
 * @internal
 *
 * Determine constructor params required by an implementation contract.
 * Return abi-encoded params.
 */
async function encodeConstructorParamsForImplementation(compilerMetadata, provider, storage, create2Factory, constructorParamMap, clientId, secretKey) {
  const constructorParams = extractConstructorParamsFromAbi(compilerMetadata.abi);
  const constructorParamTypes = constructorParams.map(p => {
    if (p.type === "tuple[]" || p.type === "tuple") {
      return ethers.utils.ParamType.from(p);
    } else {
      return p.type;
    }
  });
  const constructorParamValues = await Promise.all(constructorParams.map(async p => {
    if (constructorParamMap && constructorParamMap[p.name]) {
      if (constructorParamMap[p.name].type) {
        invariant__default["default"](constructorParamMap[p.name].type === p.type, `Provided type ${constructorParamMap[p.name].type} doesn't match the actual type ${p.type} from Abi`);
      }
      return constructorParamMap[p.name].value;
    }
    if (p.name && p.name.includes("nativeTokenWrapper")) {
      return await nativeTokenInputArg(provider, storage, create2Factory, clientId, secretKey);
    } else if (p.name && p.name.includes("trustedForwarder")) {
      if (compilerMetadata.name === "Pack") {
        return AddressZero;
      }
      const deploymentInfo = await computeDeploymentInfo("infra", provider, storage, create2Factory, {
        contractName: "Forwarder"
      }, clientId, secretKey);
      if (!caches.deploymentPresets["Forwarder"]) {
        caches.deploymentPresets["Forwarder"] = deploymentInfo;
      }
      return deploymentInfo.transaction.predictedAddress;
    } else if (p.name && p.name.includes("royaltyEngineAddress")) {
      const chainId = (await provider.getNetwork()).chainId;
      return getRoyaltyEngineV1ByChainId(chainId);
    } else if (p.name && p.name.includes("marketplaceV3Params")) {
      const chainId = (await provider.getNetwork()).chainId;
      const royaltyEngineAddress = getRoyaltyEngineV1ByChainId(chainId);
      const nativeTokenWrapper = await nativeTokenInputArg(provider, storage, create2Factory, clientId, secretKey);
      const extensions = constructorParamMap ? constructorParamMap["_extensions"].value : [];
      return {
        extensions: extensions,
        royaltyEngineAddress: royaltyEngineAddress,
        nativeTokenWrapper: nativeTokenWrapper
      };
    } else {
      throw new Error("Can't resolve constructor arguments");
    }
  }));
  const encodedArgs = ethers.utils.defaultAbiCoder.encode(constructorParamTypes, constructorParamValues);
  return encodedArgs;
}
async function nativeTokenInputArg(provider, storage, create2Factory, clientId, secretKey) {
  const chainId = (await provider.getNetwork()).chainId;
  let nativeTokenWrapperAddress = getNativeTokenByChainId(chainId).wrapped.address;
  if (nativeTokenWrapperAddress === ethers.constants.AddressZero) {
    const deploymentInfo = await computeDeploymentInfo("infra", provider, storage, create2Factory, {
      contractName: "WETH9"
    }, clientId, secretKey);
    if (!caches.deploymentPresets["WETH9"]) {
      caches.deploymentPresets["WETH9"] = deploymentInfo;
    }
    nativeTokenWrapperAddress = deploymentInfo.transaction.predictedAddress;
  }
  return nativeTokenWrapperAddress;
}

/**
 *
 * @internal
 * @param provider - The provider to use
 * @param storage - The storage to use
 * @param create2Factory - The create2 factory to use
 */
async function computeEOAForwarderAddress(provider, storage, create2Factory, clientId, secretKey) {
  if (!create2Factory || create2Factory === "") {
    create2Factory = await getCreate2FactoryAddress(provider);
  }
  return (await computeDeploymentInfo("infra", provider, storage, create2Factory, {
    contractName: "ForwarderEOAOnly"
  }, clientId, secretKey)).transaction.predictedAddress;
}

/**
 *
 * @internal
 * @param provider - The provider to use
 * @param storage - The storage to use
 * @param create2Factory - The create2 factory to use
 */
async function computeForwarderAddress(provider, storage, create2Factory, clientId, secretKey) {
  if (!create2Factory || create2Factory === "") {
    create2Factory = await getCreate2FactoryAddress(provider);
  }
  return (await computeDeploymentInfo("infra", provider, storage, create2Factory, {
    contractName: "Forwarder"
  }, clientId, secretKey)).transaction.predictedAddress;
}

/**
 * Error that may get thrown if IPFS returns nothing for a given uri.
 * @internal
 */
class NotFoundError extends Error {
  /** @internal */
  constructor(identifier) {
    super(identifier ? `Object with id ${identifier} NOT FOUND` : "NOT_FOUND");
  }
}

/**
 * Error that may get thrown if an invalid address was passed
 * @internal
 */
class InvalidAddressError extends Error {
  /** @internal */
  constructor(address) {
    super(address ? `'${address}' is an invalid address` : "Invalid address passed");
  }
}

/**
 * @internal
 */
class MissingRoleError extends Error {
  /** @internal */
  /** @internal */
  constructor(address, role) {
    super(`MISSING ROLE: ${address} does not have the '${role}' role`);
  }
}

/**
 * @internal
 */
class AssetNotFoundError extends Error {
  /** @internal */
  /** @internal */
  constructor() {
    let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "The asset you're trying to use could not be found.";
    super(`message: ${message}`);
  }
}

/**
 * @internal
 */
class UploadError extends Error {
  /** @internal */
  constructor(message) {
    super(`UPLOAD_FAILED: ${message}`);
  }
}

/**
 * @internal
 */
class FileNameMissingError extends Error {
  /** @internal */
  constructor() {
    super("File name is required when object is not a `File` type object.");
  }
}

/**
 * @internal
 */
class DuplicateFileNameError extends Error {
  /** @internal */
  constructor(fileName) {
    super(`DUPLICATE_FILE_NAME_ERROR: File name ${fileName} was passed for more than one file.`);
  }
}

/**
 * @internal
 */
class NotEnoughTokensError extends Error {
  /** @internal */
  constructor(contractAddress, quantity, available) {
    super(`BALANCE ERROR: you do not have enough balance on contract ${contractAddress} to use ${quantity} tokens. You have ${available} tokens available.`);
  }
}

/**
 * @internal
 */
class MissingOwnerRoleError extends Error {
  /** @internal */
  constructor() {
    super(`LIST ERROR: you should be the owner of the token to list it.`);
  }
}

/**
 * @internal
 */
class QuantityAboveLimitError extends Error {
  /** @internal */
  constructor(quantity) {
    super(`BUY ERROR: You cannot buy more than ${quantity} tokens`);
  }
}

/**
 * Thrown when data fails to fetch from storage.
 * @internal
 */
class FetchError extends Error {
  /** @internal */
  constructor(message, innerError) {
    super(`FETCH_FAILED: ${message}`);
    this.innerError = innerError;
  }
}

/**
 * Thrown when attempting to create a snapshot with duplicate leafs
 * @internal
 */
class DuplicateLeafsError extends Error {
  constructor(message) {
    super(`DUPLICATE_LEAFS${message ? ` : ${message}` : ""}`);
  }
}

/**
 * Thrown when attempting to update/cancel an auction that already started
 * @internal
 */
class AuctionAlreadyStartedError extends Error {
  constructor(id) {
    super(`Auction already started with existing bid${id ? `, id: ${id}` : ""}`);
  }
}

/**
 * @internal
 */
class FunctionDeprecatedError extends Error {
  /** @internal */
  constructor(message) {
    super(`FUNCTION DEPRECATED. ${message ? `Use ${message} instead` : ""}`);
  }
}

/**
 * Thrown when trying to retrieve a listing from a marketplace that doesn't exist
 * @internal
 */
class ListingNotFoundError extends Error {
  constructor(marketplaceContractAddress, listingId) {
    super(`Could not find listing.${marketplaceContractAddress ? ` marketplace address: ${marketplaceContractAddress}` : ""}${listingId ? ` listing id: ${listingId}` : ""}`);
  }
}

/**
 * Thrown when trying to retrieve a listing of the wrong type
 * @internal
 */
class WrongListingTypeError extends Error {
  constructor(marketplaceContractAddress, listingId, actualType, expectedType) {
    super(`Incorrect listing type. Are you sure you're using the right method?.${marketplaceContractAddress ? ` marketplace address: ${marketplaceContractAddress}` : ""}${listingId ? ` listing id: ${listingId}` : ""}${expectedType ? ` expected type: ${expectedType}` : ""}${actualType ? ` actual type: ${actualType}` : ""}`);
  }
}

/**
 * Thrown when attempting to transfer an asset that has restricted transferability
 * @internal
 */
class RestrictedTransferError extends Error {
  constructor(assetAddress) {
    super(`Failed to transfer asset, transfer is restricted.${assetAddress ? ` Address : ${assetAddress}` : ""}`);
  }
}

/**
 * Thrown when attempting to execute an admin-role function.
 * @internal
 */
class AdminRoleMissingError extends Error {
  constructor(address, contractAddress) {
    let message = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "Failed to execute transaction";
    super(`${message}, admin role is missing${address ? ` on address: ${address}` : ""}${contractAddress ? ` on contract: ${contractAddress}` : ""}`);
  }
}

/**
 * Thrown when attempting to close an auction that has not ended
 * @internal
 */
class AuctionHasNotEndedError extends Error {
  constructor(id, endTime) {
    super(`Auction has not ended yet${id ? `, id: ${id}` : ""}${endTime ? `, end time: ${endTime.toString()}` : ""}`);
  }
}

/**
 * Thrown when attempting to call a contract function that is not implemented
 * @internal
 */
class ExtensionNotImplementedError extends Error {
  constructor(feature) {
    super(`This functionality is not available because the contract does not implement the '${feature.name}' Extension. Learn how to unlock this functionality at https://portal.thirdweb.com/contracts/build/extensions `);
  }
}

/**
 * @internal
 */

/**
 * @public
 */
class TransactionError extends Error {
  constructor(info, raw) {
    let errorMessage = `\n\n\n╔═══════════════════╗\n║ TRANSACTION ERROR ║\n╚═══════════════════╝\n\n`;
    errorMessage += `Reason: ${info.reason}`;
    errorMessage += `\n\n\n╔═════════════════════════╗\n║ TRANSACTION INFORMATION ║\n╚═════════════════════════╝\n`;
    errorMessage += withSpaces("from", info.from);
    if (info.to) {
      errorMessage += withSpaces("to", info.contractName ? `${info.to} (${info.contractName})` : info.to);
    }
    errorMessage += withSpaces(`chain`, `${info.network.name} (${info.network.chainId})`);
    if (info.rpcUrl) {
      try {
        const url = new URL(info.rpcUrl);
        errorMessage += withSpaces(`rpc`, url.hostname);
      } catch (e2) {
        // ignore if can't parse URL
      }
    }
    if (info.hash) {
      errorMessage += withSpaces(`tx hash`, info.hash);
    }
    if (info.value && info.value.gt(0)) {
      errorMessage += withSpaces("value", `${ethers.utils.formatEther(info.value)} ${NATIVE_TOKENS[info.network.chainId]?.symbol || ""}`);
    }
    errorMessage += withSpaces(`data`, `${info.data}`);
    if (info.method) {
      errorMessage += withSpaces("method", info.method);
    }
    if (info.sources) {
      const revertFile = info.sources.find(file => file.source.includes(info.reason));
      if (revertFile) {
        const lines = revertFile.source.split("\n").map((line, index) => `${index + 1}  ${line}`);
        const revertLine = lines.findIndex(line => line.includes(info.reason));
        lines[revertLine] += "   <-- REVERT";
        const errorLines = lines.slice(revertLine - 8, revertLine + 4);
        errorMessage += `\n\n\n╔══════════════════════╗\n║ SOLIDITY STACK TRACE ║\n╚══════════════════════╝\n\n`;
        errorMessage += `File: ${revertFile.filename.replace("node_modules/", "")}\n\n`;
        errorMessage += errorLines.join("\n");
      }
    }
    errorMessage += `\n\n\n╔═════════════════════╗\n║ DEBUGGING RESOURCES ║\n╚═════════════════════╝\n\n`;
    errorMessage += `Need helping debugging? Visit our support site: https://thirdweb.com/support`;
    errorMessage += `\n\n`;
    super(errorMessage);
    this._reason = info.reason;
    this._info = info;
    this._raw = raw;
  }

  // Keep reason here for backwards compatibility
  get reason() {
    return this._reason;
  }
  get raw() {
    return this._raw;
  }
  get info() {
    return this._info;
  }
}

/**
 * @internal
 */
function parseRevertReason(error) {
  if (error.reason && !error.reason.includes("cannot estimate gas")) {
    return error.reason;
  }
  if (error.error) {
    return error.error;
  }

  // I think this code path should never be hit, but just in case

  let errorString = error;
  if (typeof error === "object") {
    // MetaMask errors come as objects so parse them first
    errorString = JSON.stringify(error);
  } else if (typeof error !== "string") {
    errorString = error.toString();
  }

  // if the error is just too long, just return the message to limit Regexp processing time
  // see: https://cwe.mitre.org/data/definitions/1333.html
  if (errorString.length > 5000) {
    return error.message || "";
  }
  return parseMessageParts(/.*?"message":"([^"\\]*).*?/, errorString) || parseMessageParts(/.*?"reason":"([^"\\]*).*?/, errorString) || error.message || "";
}
function withSpaces(label, content) {
  if (content === "") {
    return content;
  }
  const spaces = Array(10 - label.length).fill(" ").join("");
  if (content.includes("\n")) {
    content = "\n\n  " + content.split("\n").join(`\n  `);
  } else {
    content = `${spaces}${content}`;
  }
  return `\n${label}:${content}`;
}
function parseMessageParts(regex, raw) {
  const msgMatches = raw.match(regex) || [];
  let extracted = "";
  if (msgMatches?.length > 0) {
    extracted += msgMatches[1];
  }
  return extracted;
}

/**
 * @internal
 * @param err - The error to check
 * @param message - The message to check for
 */
function includesErrorMessage(err, message) {
  if (!err) {
    return false;
  }
  return err && err.toString().includes(message) || err && err.message && err.message.toString().includes(message) || err && err.error && err.error.toString().includes(message);
}

/**
 * @internal
 * @param publishedMetadata - The published metadata to fetch the sources for
 * @param storage - The storage to use
 */

async function fetchSourceFilesFromMetadata(publishedMetadata, storage) {
  return await Promise.all(Object.entries(publishedMetadata.metadata.sources).map(async _ref => {
    let [path, info] = _ref;
    const urls = info.urls;
    const ipfsLink = urls ? urls.find(url => url.includes("ipfs")) : undefined;
    if (ipfsLink) {
      const ipfsHash = ipfsLink.split("ipfs/")[1];
      // 3 sec timeout for sources that haven't been uploaded to ipfs
      const timeout = new Promise((_r, rej) => setTimeout(() => rej("timeout"), 3000));
      const source = await Promise.race([(await storage.download(`ipfs://${ipfsHash}`)).text(), timeout]);
      return {
        filename: path,
        source
      };
    } else {
      return {
        filename: path,
        source: info.content || "Could not find source for this contract"
      };
    }
  }));
}

/**
 * @internal
 */
const ForwardRequest = [{
  name: "from",
  type: "address"
}, {
  name: "to",
  type: "address"
}, {
  name: "value",
  type: "uint256"
}, {
  name: "gas",
  type: "uint256"
}, {
  name: "nonce",
  type: "uint256"
}, {
  name: "data",
  type: "bytes"
}];
const ChainAwareForwardRequest = [{
  name: "from",
  type: "address"
}, {
  name: "to",
  type: "address"
}, {
  name: "value",
  type: "uint256"
}, {
  name: "gas",
  type: "uint256"
}, {
  name: "nonce",
  type: "uint256"
}, {
  name: "data",
  type: "bytes"
}, {
  name: "chainid",
  type: "uint256"
}];

/**
 * @internal
 */
const BiconomyForwarderAbi = [{
  inputs: [{
    internalType: "address",
    name: "from",
    type: "address"
  }, {
    internalType: "uint256",
    name: "batchId",
    type: "uint256"
  }],
  name: "getNonce",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}];
const _nonces = {};
const _noncesSyncTimestamp = {};

/**
 * @internal
 */
async function getAndIncrementNonce(forwarder, forwarderFunction, forwarderArgs) {
  // address is only used for internal caching :)
  const address = forwarderArgs.join("|");
  const timestamp = _noncesSyncTimestamp[address];
  // if it's within 2 seconds we're optimistically increment the nonce
  // should we always sync?
  const shouldSync = Date.now() - timestamp >= 2000;
  if (!(address in _nonces) || shouldSync) {
    const nonceResult = await forwarder.functions[forwarderFunction](...forwarderArgs);
    if (Array.isArray(nonceResult) && nonceResult.length > 0) {
      _nonces[address] = ethers.BigNumber.from(nonceResult[0]);
    } else {
      _nonces[address] = ethers.BigNumber.from(nonceResult);
    }
    _noncesSyncTimestamp[address] = Date.now();
  }
  const nonce = _nonces[address];
  _nonces[address] = ethers.BigNumber.from(_nonces[address]).add(1);
  return nonce;
}

async function getDefaultGasOverrides(provider) {
  // handle smart wallet provider
  if (provider.originalProvider) {
    provider = provider.originalProvider;
  }
  const feeData = await getDynamicFeeData(provider);
  if (feeData.maxFeePerGas && feeData.maxPriorityFeePerGas) {
    return {
      maxFeePerGas: feeData.maxFeePerGas,
      maxPriorityFeePerGas: feeData.maxPriorityFeePerGas
    };
  } else {
    return {
      gasPrice: await getGasPrice(provider)
    };
  }
}
async function getDynamicFeeData(provider) {
  let maxFeePerGas = null;
  let maxPriorityFeePerGas = null;
  const [{
    chainId
  }, block, eth_maxPriorityFeePerGas] = await Promise.all([provider.getNetwork(), provider.getBlock("latest"), provider.send("eth_maxPriorityFeePerGas", []).catch(() => null)]);
  const baseBlockFee = block && block.baseFeePerGas ? block.baseFeePerGas : ethers.utils.parseUnits("100", "wei");

  // flag-chain overrides
  if (chainId === chains.Flag.chainId || chainId === chains.FlagTestnet.chainId) {
    // chains does not support eip-1559, return null for all
    return {
      maxFeePerGas: null,
      maxPriorityFeePerGas: null,
      baseFee: null
    };
  } else if (chainId === chains.Mumbai.chainId || chainId === chains.Polygon.chainId) {
    // for polygon, get fee data from gas station
    maxPriorityFeePerGas = await getPolygonGasPriorityFee(chainId);
  } else if (eth_maxPriorityFeePerGas) {
    // prioritize fee from eth_maxPriorityFeePerGas
    maxPriorityFeePerGas = ethers.BigNumber.from(eth_maxPriorityFeePerGas);
  } else {
    // if eth_maxPriorityFeePerGas is not available, use 1.5 gwei default
    const feeData = await provider.getFeeData();
    maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
    if (!maxPriorityFeePerGas) {
      // chain does not support eip-1559, return null for both
      return {
        maxFeePerGas: null,
        maxPriorityFeePerGas: null,
        baseFee: null
      };
    }
  }

  // add 10% tip to maxPriorityFeePerGas for faster processing
  maxPriorityFeePerGas = getPreferredPriorityFee(maxPriorityFeePerGas);
  // eip-1559 formula, doubling the base fee ensures that the tx can be included in the next 6 blocks no matter how busy the network is
  // good article on the subject: https://www.blocknative.com/blog/eip-1559-fees
  maxFeePerGas = baseBlockFee.mul(2).add(maxPriorityFeePerGas);
  return {
    maxFeePerGas,
    maxPriorityFeePerGas,
    baseFee: baseBlockFee
  };
}
function getPreferredPriorityFee(defaultPriorityFeePerGas) {
  let percentMultiplier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;
  const extraTip = defaultPriorityFeePerGas.div(100).mul(percentMultiplier); // + 10%
  const totalPriorityFee = defaultPriorityFeePerGas.add(extraTip);
  return totalPriorityFee;
}
async function getGasPrice(provider) {
  const gasPrice = await provider.getGasPrice();
  const maxGasPrice = ethers.utils.parseUnits("300", "gwei"); // 300 gwei
  const extraTip = gasPrice.div(100).mul(10); // + 10%
  const txGasPrice = gasPrice.add(extraTip);
  if (txGasPrice.gt(maxGasPrice)) {
    return maxGasPrice;
  }
  return txGasPrice;
}
async function estimateTransactionCost(provider, tx) {
  const chainId = (await provider.getNetwork()).chainId;
  let l1GasCost = ethers.BigNumber.from(0);
  if (isOpStackChain(chainId)) {
    const {
      asL2Provider
    } = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@eth-optimism/sdk')); });
    const l2RpcProvider = asL2Provider(provider);
    l1GasCost = await l2RpcProvider.estimateL1GasCost(tx);
  }
  const gasLimit = tx.gasLimit || (await provider.estimateGas(tx));
  const gasPrice = await getGasPrice(provider);
  const gasCost = ethers.BigNumber.from(gasLimit).mul(gasPrice);
  return gasCost.add(l1GasCost);
}
function isOpStackChain(chainId) {
  return chainId === chains.Optimism.chainId || chainId === chains.OpSepoliaTestnet.chainId || chainId === chains.Base.chainId || chainId === chains.BaseSepoliaTestnet.chainId || chainId === chains.Zora.chainId || chainId === chains.ZoraSepoliaTestnet.chainId || chainId === chains.Celo.chainId || chainId === chains.CeloAlfajoresTestnet.chainId;
}

/**
 * @internal
 */
function getGasStationUrl(chainId) {
  switch (chainId) {
    case ChainId.Polygon:
      return "https://gasstation.polygon.technology/v2";
    case ChainId.Mumbai:
      return "https://gasstation-testnet.polygon.technology/v2";
  }
}
const MIN_POLYGON_GAS_PRICE = /* @__PURE__ */(() => ethers.utils.parseUnits("31", "gwei"))();
const MIN_MUMBAI_GAS_PRICE = /* @__PURE__ */(() => ethers.utils.parseUnits("1", "gwei"))();

/**
 * @internal
 */
function getDefaultGasFee(chainId) {
  switch (chainId) {
    case ChainId.Polygon:
      return MIN_POLYGON_GAS_PRICE;
    case ChainId.Mumbai:
      return MIN_MUMBAI_GAS_PRICE;
  }
}

/**
 *
 * @returns The gas price
 * @internal
 */
async function getPolygonGasPriorityFee(chainId) {
  const gasStationUrl = getGasStationUrl(chainId);
  try {
    const data = await (await fetch(gasStationUrl)).json();
    // take the standard speed here, SDK options will define the extra tip
    const priorityFee = data["fast"]["maxPriorityFee"];
    if (priorityFee > 0) {
      const fixedFee = parseFloat(priorityFee).toFixed(9);
      return ethers.utils.parseUnits(fixedFee, "gwei");
    }
  } catch {
    // if the gas station is down, return the default gas fee
  }
  return getDefaultGasFee(chainId);
}

/**
 * @internal
 */

/**
 * @internal
 */

/**
 * @internal
 */

/**
 * eip712 sign typed data with different wallet handling including ledger live
 * @internal
 */
async function signTypedDataInternal(signerInput, domain, types, message) {
  // Handle ERC4337Signer
  let signer = signerInput;
  if (signerInput.originalSigner) {
    signer = signerInput.originalSigner;
  }
  const provider = signer?.provider;
  if (!provider) {
    throw new Error("missing provider");
  }
  const payload = ethers.utils._TypedDataEncoder.getPayload(domain, types, message);
  let signature = "";
  const signerAddress = (await signer.getAddress()).toLowerCase();

  // an indirect way for accessing walletconnect's underlying provider
  if (provider?.provider?.isWalletConnect) {
    signature = await provider.send("eth_signTypedData", [signerAddress, JSON.stringify(payload)]);
  } else {
    try {
      signature = await signer._signTypedData(domain, types, message);
    } catch (err) {
      if (err?.message?.includes("eth_signTypedData_v4")) {
        signature = await provider.send("eth_signTypedData", [signerAddress, JSON.stringify(payload)]);
      } else {
        // magic.link signer only supports this way
        try {
          await provider.send("eth_signTypedData_v4", [signerAddress, JSON.stringify(payload)]);
        } catch (finalErr) {
          throw finalErr;
        }
      }
    }
  }

  // fix ledger live where signature result in v = 0, 1. ethers magically fix it in split/join.
  return {
    payload,
    signature: ethers.utils.joinSignature(ethers.utils.splitSignature(signature))
  };
}

const NAME_ABI = [{
  inputs: [],
  name: "name",
  outputs: [{
    internalType: "string",
    name: "",
    type: "string"
  }],
  stateMutability: "view",
  type: "function"
}];
const DOMAIN_SEPARATOR_ABI = [{
  constant: true,
  inputs: [],
  name: "DOMAIN_SEPARATOR",
  outputs: [{
    internalType: "bytes32",
    name: "",
    type: "bytes32"
  }],
  payable: false,
  stateMutability: "view",
  type: "function"
}, {
  inputs: [],
  name: "getDomainSeperator",
  outputs: [{
    internalType: "bytes32",
    name: "",
    type: "bytes32"
  }],
  stateMutability: "view",
  type: "function"
}];
const NONCES_ABI = [{
  inputs: [{
    internalType: "address",
    name: "owner",
    type: "address"
  }],
  name: "nonces",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "user",
    type: "address"
  }],
  name: "getNonce",
  outputs: [{
    internalType: "uint256",
    name: "nonce",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}];
async function getSignerNonce(signer, contractAddress) {
  const contract = new ethers.Contract(contractAddress, NONCES_ABI, signer);
  try {
    return await contract.nonces(await signer.getAddress());
  } catch (err) {
    return await contract.getNonce(await signer.getAddress());
  }
}
async function getDomainSeperator(signer, contractAddress) {
  const contract = new ethers.Contract(contractAddress, DOMAIN_SEPARATOR_ABI, signer);
  try {
    return await contract.DOMAIN_SEPARATOR();
  } catch (err) {
    try {
      return await contract.getDomainSeperator();
    } catch (err2) {
      console.error("Error getting domain separator", err2);
    }
  }
}
async function getTokenName(signer, contractAddress) {
  return new ethers.Contract(contractAddress, NAME_ABI, signer).name();
}

/**
 * Polygon chain has different EIP712 domain separator for USDC, DAI compared to other chains and slightly different than EIP-2612.
 */
async function getChainDomainSeperator(signer, domain) {
  const contractDomainSeparator = await getDomainSeperator(signer, domain.verifyingContract);
  const polygonDomain = {
    name: domain.name,
    version: domain.version,
    verifyingContract: domain.verifyingContract,
    salt: ethers.utils.hexZeroPad(ethers.BigNumber.from(domain.chainId).toHexString(), 32)
  };
  if (ethers.utils._TypedDataEncoder.hashDomain(polygonDomain) === contractDomainSeparator) {
    return polygonDomain;
  }
  return domain;
}

/**
 * @internal
 */
async function signEIP2612Permit(signer, currencyAddress, owner, spender, value, deadline, nonce, domainSeparatorVersion) {
  const [name, chainId, signerNonce] = await Promise.all([getTokenName(signer, currencyAddress), signer.getChainId(), getSignerNonce(signer, currencyAddress)]);
  const domain = await getChainDomainSeperator(signer, {
    name,
    version: domainSeparatorVersion || "1",
    chainId,
    verifyingContract: currencyAddress
  });
  nonce = nonce || signerNonce.toString();
  deadline = deadline || ethers.constants.MaxUint256;
  const message = {
    owner,
    spender,
    value,
    nonce,
    deadline
  };
  const types = {
    Permit: [{
      name: "owner",
      type: "address"
    }, {
      name: "spender",
      type: "address"
    }, {
      name: "value",
      type: "uint256"
    }, {
      name: "nonce",
      type: "uint256"
    }, {
      name: "deadline",
      type: "uint256"
    }]
  };
  const {
    signature
  } = await signTypedDataInternal(signer, domain, types, message);
  return {
    message,
    signature
  };
}

const TWRegistry_address = "0x7c487845f98938Bb955B1D5AD069d9a30e4131fd";
const TWFactory_address = "0x5DBC7B840baa9daBcBe9D2492E45D7244B54A2A0";

/**
 * @internal
 */
const OZ_DEFENDER_FORWARDER_ADDRESS = "0xc82BbE41f2cF04e3a8efA18F7032BDD7f6d98a81";

/**
 * @internal
 */
const CONTRACT_ADDRESSES = {
  [ChainId.Mainnet]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0x76ce2CB1Ae48Fa067f4fb8c5f803111AE0B24BEA",
    biconomyForwarder: "0x84a0856b038eaAd1cC7E297cF34A7e72685A8693",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: AddressZero
  },
  [ChainId.Goerli]: {
    openzeppelinForwarder: "0x5001A14CA6163143316a7C614e30e6041033Ac20",
    openzeppelinForwarderEOA: "0xe73c50cB9c5B378627ff625BB6e6725A4A5D65d2",
    biconomyForwarder: "0xE041608922d06a4F26C0d4c27d8bCD01daf1f792",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: "0xB1Bd9d7942A250BA2Dce27DD601F2ED4211A60C4"
  },
  [ChainId.Polygon]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0x4f247c69184ad61036EC2Bb3213b69F10FbEDe1F",
    biconomyForwarder: "0x86C80a8aa58e0A4fa09A69624c31Ab2a6CAD56b8",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: "0x308473Be900F4185A56587dE54bDFF5E8f7a6AE7"
  },
  [ChainId.Mumbai]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",
    biconomyForwarder: "0x9399BB24DBB5C4b782C70c2969F58716Ebbd6a3b",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: "0x3F17972CB27506eb4a6a3D59659e0B57a43fd16C"
  },
  [ChainId.Avalanche]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",
    biconomyForwarder: "0x64CD353384109423a966dCd3Aa30D884C9b2E057",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: AddressZero
  },
  [ChainId.AvalancheFujiTestnet]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0xe73c50cB9c5B378627ff625BB6e6725A4A5D65d2",
    biconomyForwarder: "0x6271Ca63D30507f2Dcbf99B52787032506D75BBF",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: "0x3E6eE864f850F5e5A98bc950B68E181Cf4010F23"
  },
  [ChainId.Fantom]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250",
    biconomyForwarder: "0x64CD353384109423a966dCd3Aa30D884C9b2E057",
    twFactory: "0x97EA0Fcc552D5A8Fb5e9101316AAd0D62Ea0876B",
    twRegistry: TWRegistry_address,
    twBYOCRegistry: AddressZero
  },
  [ChainId.FantomTestnet]: {
    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,
    openzeppelinForwarderEOA: "0x42D3048b595B6e1c28a588d70366CcC2AA4dB47b",
    biconomyForwarder: "0x69FB8Dca8067A5D38703b9e8b39cf2D51473E4b4",
    twFactory: TWFactory_address,
    twRegistry: TWRegistry_address,
    twBYOCRegistry: "0x3E6eE864f850F5e5A98bc950B68E181Cf4010F23"
  },
  [ChainId.Arbitrum]: {
    openzeppelinForwarder: "0x4a8AC7f22DeD2CF923A51e4A1c67490bd8868add",
    openzeppelinForwarderEOA: "0x4f247c69184ad61036EC2Bb3213b69F10FbEDe1F",
    biconomyForwarder: "0xfe0fa3C06d03bDC7fb49c892BbB39113B534fB57",
    twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
    twRegistry: TWRegistry_address,
    twBYOCRegistry: AddressZero
  },
  [ChainId.ArbitrumGoerli]: {
    openzeppelinForwarder: "0x8cbc8B5d71702032904750A66AEfE8B603eBC538",
    openzeppelinForwarderEOA: "0x119704314Ef304EaAAE4b3c7C9ABd59272A28310",
    biconomyForwarder: AddressZero,
    twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
    twRegistry: TWRegistry_address,
    twBYOCRegistry: AddressZero
  },
  [ChainId.Optimism]: {
    openzeppelinForwarder: "0xd85da690EF288A6976DE0E85Fb2Aad512eBAfbf7",
    openzeppelinForwarderEOA: "0x7e80648EB2071E26937F9D42A513ccf4815fc702",
    biconomyForwarder: "0xefba8a2a82ec1fb1273806174f5e28fbb917cf95",
    twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
    twRegistry: TWRegistry_address,
    twBYOCRegistry: AddressZero
  },
  [ChainId.OptimismGoerli]: {
    openzeppelinForwarder: "0x8cbc8B5d71702032904750A66AEfE8B603eBC538",
    openzeppelinForwarderEOA: "0x119704314Ef304EaAAE4b3c7C9ABd59272A28310",
    biconomyForwarder: AddressZero,
    twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
    twRegistry: TWRegistry_address,
    twBYOCRegistry: AddressZero
  },
  [ChainId.BinanceSmartChainMainnet]: {
    openzeppelinForwarder: "0x7C4717039B89d5859c4Fbb85EDB19A6E2ce61171",
    openzeppelinForwarderEOA: "0xE8dd2Ff0212F86d3197b4AfDC6dAC6ac47eb10aC",
    biconomyForwarder: "0x86C80a8aa58e0A4fa09A69624c31Ab2a6CAD56b8",
    twBYOCRegistry: AddressZero,
    twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
    twRegistry: TWRegistry_address
  },
  [ChainId.BinanceSmartChainTestnet]: {
    openzeppelinForwarder: "0x44bE9D54B9C8b5e57a3325E8Ec9154640e7c6955",
    openzeppelinForwarderEOA: "0x7e80648EB2071E26937F9D42A513ccf4815fc702",
    biconomyForwarder: "0x61456BF1715C1415730076BB79ae118E806E74d2",
    twBYOCRegistry: AddressZero,
    twFactory: "0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0",
    twRegistry: TWRegistry_address
  },
  [ChainId.Hardhat]: {
    openzeppelinForwarder: AddressZero,
    openzeppelinForwarderEOA: AddressZero,
    biconomyForwarder: AddressZero,
    twFactory: AddressZero,
    twRegistry: AddressZero,
    twBYOCRegistry: AddressZero
  },
  [ChainId.Localhost]: {
    openzeppelinForwarder: AddressZero,
    openzeppelinForwarderEOA: AddressZero,
    biconomyForwarder: AddressZero,
    twFactory: AddressZero,
    twRegistry: AddressZero,
    twBYOCRegistry: AddressZero
  }
};

/**
 * @internal
 */
function getContractAddressByChainId(chainId, contractName) {
  // for testing only
  if (chainId === ChainId.Hardhat || chainId === ChainId.Localhost) {
    if (contractName === "twFactory") {
      return getProcessEnv("factoryAddress");
    } else if (contractName === "twRegistry") {
      return getProcessEnv("registryAddress");
    } else {
      return AddressZero;
    }
  }
  // real output here
  return CONTRACT_ADDRESSES[chainId]?.[contractName];
}

/**
 * @public
 */
let EventType = /*#__PURE__*/function (EventType) {
  EventType["Transaction"] = "transaction";
  EventType["Signature"] = "signature";
  return EventType;
}({});

const CallOverrideSchema = /* @__PURE__ */(() => zod.z.object({
  gasLimit: BigNumberishSchema.optional(),
  gasPrice: BigNumberishSchema.optional(),
  maxFeePerGas: BigNumberishSchema.optional(),
  maxPriorityFeePerGas: BigNumberishSchema.optional(),
  nonce: BigNumberishSchema.optional(),
  value: BigNumberishSchema.optional(),
  blockTag: zod.z.union([zod.z.string(), zod.z.number()]).optional(),
  from: AddressOrEnsSchema.optional(),
  type: zod.z.number().optional()
}).strict())();

/**
 * @internal
 */
class RPCConnectionHandler extends EventEmitter__default["default"] {
  constructor(network, options) {
    super();
    try {
      this.options = SDKOptionsSchema.parse(options);
    } catch (optionParseError) {
      console.error("invalid sdk options object passed, falling back to default options", optionParseError);
      this.options = SDKOptionsSchema.parse({});
    }
    const [signer, provider] = getSignerAndProvider(network, this.options);
    this.network = network;
    this.signer = signer;
    this.provider = provider;
  }
  /**
   * The function to call whenever the network changes, such as when the users connects their wallet, disconnects their wallet, the connected chain changes, etc.
   *
   * @param network - a network, signer or provider that ethers js can interpret
   */
  updateSignerOrProvider(network) {
    const [signer, provider] = getSignerAndProvider(network, this.options);
    this.network = network;
    this.signer = signer;
    this.provider = provider;
  }
  /**
   *
   * @returns whether or not a signer is set, `true` if there is no signer so the class is in "read only" mode
   */
  isReadOnly() {
    return !isSigner(this.signer);
  }

  /**
   * Explicitly get the active signer.
   * @returns The active signer, if there is one
   */
  getSigner() {
    return this.signer;
  }

  /**
   * Explicitly get the active provider.
   * @returns The active provider
   */
  getProvider() {
    return this.provider;
  }

  /**
   *
   * @returns The current signer if there is one, otherwise the active provider
   */
  getSignerOrProvider() {
    return this.getSigner() || this.getProvider();
  }
}

/**
 * @internal
 */
class ContractWrapper extends RPCConnectionHandler {
  isValidContract = false;
  customOverrides = () => ({});
  /**
   * @internal
   */

  constructor(network, contractAddress, contractAbi, options, storage) {
    super(network, options);
    this.abi = AbiSchema.parse(contractAbi);
    this.address = contractAddress;
    // set up the contract
    this.writeContract = new ethers.Contract(contractAddress, contractAbi, this.getSignerOrProvider());
    // setup the read only contract
    this.readContract = this.writeContract.connect(this.getProvider());
    this.storage = storage;
    this.functions = extractFunctionsFromAbi(this.abi);
    this.extensions = detectFeatures(this.abi);
  }
  updateSignerOrProvider(network) {
    // update the underlying base class
    super.updateSignerOrProvider(network);
    // re-connect the contract with the new signer / provider
    this.writeContract = this.writeContract.connect(this.getSignerOrProvider());
    // setup the read only contract
    this.readContract = this.writeContract.connect(this.getProvider());
  }
  updateAbi(updatedAbi) {
    // re-connect the contract with the new signer / provider
    this.writeContract = new ethers.Contract(this.address, updatedAbi, this.getSignerOrProvider());

    // setup the read only contract
    this.readContract = this.writeContract.connect(this.getProvider());
    this.abi = AbiSchema.parse(updatedAbi);
    this.functions = extractFunctionsFromAbi(this.abi);
    this.extensions = detectFeatures(this.abi);
  }

  /**
   * @internal
   */
  async getChainID() {
    const provider = this.getProvider();
    const {
      chainId
    } = await provider.getNetwork();
    return chainId;
  }
  /**
   * @internal
   */
  async getSignerAddress() {
    const signer = this.getSigner();
    if (!signer) {
      throw new Error("This action requires a connected wallet to sign the transaction. Please pass a valid signer to the SDK.");
    }
    return await signer.getAddress();
  }

  /**
   * @internal
   */
  callStatic() {
    return this.writeContract.callStatic;
  }

  /**
   * @internal
   */
  async getCallOverrides() {
    // If we're running in the browser, let users configure gas price in their wallet UI
    if (isBrowser()) {
      return {};
    }
    return getDefaultGasOverrides(this.getProvider());
  }

  /**
   * @internal
   */
  emitTransactionEvent(status, transactionHash) {
    this.emit(EventType.Transaction, {
      status,
      transactionHash
    });
  }

  /**
   * @internal
   */
  async multiCall(encoded) {
    return this.sendTransaction("multicall", [encoded]);
  }

  /**
   * @internal
   */
  async estimateGas(fn, args) {
    return this.writeContract.estimateGas[fn](...args);
  }
  async populateTransaction(fn, args) {
    return this.writeContract.populateTransaction[fn](...args);
  }

  /**
   * @internal
   */
  withTransactionOverride(hook) {
    this.customOverrides = hook;
  }

  /**
   *
   * @param functionName - The function name on the contract to call
   * @param args - The arguments to be passed to the functionName
   * @returns The return value of the function call
   */
  async read(functionName, args) {
    const functions = this.functions.filter(f => f.name === functionName);
    if (!functions.length) {
      throw new Error(`Function "${functionName.toString()}" not found in contract. Check your dashboard for the list of functions available`);
    }
    const fn = functions.find(f => f.name === functionName && f.inputs.length === args.length);

    // TODO extract this and re-use for deploy function to check constructor args
    if (!fn) {
      throw new Error(`Function "${functionName.toString()}" requires ${functions[0].inputs.length} arguments, but ${args.length} were provided.\nExpected function signature: ${functions[0].signature}`);
    }
    const ethersFnName = `${functionName.toString()}(${fn.inputs.map(i => i.type).join()})`;

    // check if the function exists on the contract, otherwise use the name passed in
    const fnName = ethersFnName in this.readContract.functions ? ethersFnName : functionName;
    if (fn.stateMutability === "view" || fn.stateMutability === "pure") {
      // read function
      const result = await this.readContract[fnName.toString()](...args);
      return result;
    }
    throw new Error("Cannot call a write function with read()");
  }

  /**
   * @internal
   */
  async call(functionName) {
    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    let overrides = arguments.length > 2 ? arguments[2] : undefined;
    // parse last arg as tx options if present
    const txOptions = overrides ? await CallOverrideSchema.parseAsync(overrides) : undefined;
    const functions = extractFunctionsFromAbi(AbiSchema.parse(this.abi)).filter(f => f.name === functionName);
    if (!functions.length) {
      throw new Error(`Function "${functionName}" not found in contract. Check your dashboard for the list of functions available`);
    }
    const fn = functions.find(f => f.name === functionName && f.inputs.length === args.length);

    // TODO extract this and re-use for deploy function to check constructor args
    if (!fn) {
      throw new Error(`Function "${functionName}" requires ${functions[0].inputs.length} arguments, but ${args.length} were provided.\nExpected function signature: ${functions[0].signature}`);
    }
    const ethersFnName = `${functionName}(${fn.inputs.map(i => i.type).join()})`;

    // check if the function exists on the contract, otherwise use the name passed in
    const fnName = ethersFnName in this.readContract.functions ? ethersFnName : functionName;

    // TODO validate each argument
    if (fn.stateMutability === "view" || fn.stateMutability === "pure") {
      // read function
      return txOptions ? this.readContract[fnName](...args, txOptions) : this.readContract[fnName](...args);
    } else {
      // write function
      const receipt = await this.sendTransaction(fnName, args, txOptions);
      return {
        receipt
      };
    }
  }

  /**
   * @internal
   */
  async sendTransaction(
  // eslint-disable-next-line @typescript-eslint/ban-types
  fn, args, callOverrides) {
    if (!callOverrides) {
      callOverrides = await this.getCallOverrides();
    }
    // if a custom override is set, merge our override with the custom one
    callOverrides = {
      ...callOverrides,
      ...this.customOverrides()
    };
    // clear up the override (single use)
    this.customOverrides = () => ({});
    if (this.options?.gasless && ("openzeppelin" in this.options.gasless || "biconomy" in this.options.gasless || "engine" in this.options.gasless)) {
      if (fn === "multicall" && Array.isArray(args[0]) && args[0].length > 0) {
        const from = await this.getSignerAddress();
        args[0] = args[0].map(tx => ethers.utils.solidityPack(["bytes", "address"], [tx, from]));
      }
      const provider = this.getProvider();
      const txHash = await this.sendGaslessTransaction(fn, args, callOverrides);
      this.emitTransactionEvent("submitted", txHash);
      const receipt = await provider.waitForTransaction(txHash);
      this.emitTransactionEvent("completed", txHash);
      return receipt;
    } else {
      // one time verification that this is a valid contract (to avoid sending funds to wrong addresses)
      if (!this.isValidContract) {
        const code = await this.getProvider().getCode(this.address);
        this.isValidContract = code !== "0x";
        if (!this.isValidContract) {
          throw new Error("The address you're trying to send a transaction to is not a smart contract. Make sure you are on the correct network and the contract address is correct");
        }
      }
      const tx = await this.sendTransactionByFunction(fn, args, callOverrides);
      this.emitTransactionEvent("submitted", tx.hash);

      // tx.wait() can fail so we need to wrap it with a catch
      let receipt;
      try {
        receipt = await tx.wait();
      } catch (err) {
        try {
          // If tx.wait() fails, it just gives us a generic "transaction failed"
          // error. So instead, we need to call static to get an informative error message
          await this.writeContract.callStatic[fn](...args, ...(callOverrides.value ? [{
            value: callOverrides.value
          }] : []));
        } catch (staticErr) {
          throw await this.formatError(staticErr, fn, args, callOverrides);
        }
        throw await this.formatError(err, fn, args, callOverrides);
      }
      this.emitTransactionEvent("completed", tx.hash);
      return receipt;
    }
  }

  /**
   * @internal
   */
  async sendTransactionByFunction(fn, args, callOverrides) {
    const func = this.writeContract.functions[fn];
    if (!func) {
      throw new Error(`invalid function: "${fn.toString()}"`);
    }

    // First, if no gasLimit is passed, call estimate gas ourselves
    if (!callOverrides.gasLimit) {
      try {
        callOverrides.gasLimit = await this.writeContract.estimateGas[fn](...args, callOverrides);
      } catch (e) {
        // If gas estimation fails, we'll call static to get a better error message
        try {
          await this.writeContract.callStatic[fn](...args, ...(callOverrides.value ? [{
            value: callOverrides.value
          }] : []));
        } catch (err) {
          throw await this.formatError(err, fn, args, callOverrides);
        }
      }
    }

    // Now there should be no gas estimate errors
    try {
      return await func(...args, callOverrides);
    } catch (err) {
      throw await this.formatError(err, fn, args, callOverrides);
    }
  }
  async formatError(error, fn, args, callOverrides) {
    const provider = this.getProvider();

    // Get metadata for transaction to populate into error
    const network = await provider.getNetwork();
    const from = await (callOverrides.from || this.getSignerAddress());
    const to = this.address;
    const data = this.readContract.interface.encodeFunctionData(fn, args);
    const value = ethers.BigNumber.from(callOverrides.value || 0);
    const rpcUrl = provider.connection?.url;

    // Render function signature with arguments filled in
    const functionSignature = this.readContract.interface.getFunction(fn);
    const methodArgs = args.map(arg => {
      if (JSON.stringify(arg).length <= 80) {
        return JSON.stringify(arg);
      }
      return JSON.stringify(arg, undefined, 2);
    });
    const joinedArgs = methodArgs.join(", ").length <= 80 ? methodArgs.join(", ") : "\n" + methodArgs.map(arg => "  " + arg.split("\n").join("\n  ")).join(",\n") + "\n";
    const method = `${functionSignature.name}(${joinedArgs})`;
    const hash = error.transactionHash || error.transaction?.hash || error.receipt?.transactionHash;

    // Parse the revert reason from the error
    const reason = parseRevertReason(error);

    // Get contract sources for stack trace
    let sources = undefined;
    let contractName = undefined;
    try {
      const metadata = await fetchContractMetadataFromAddress(this.address, this.getProvider(), this.storage, this.options);
      if (metadata.name) {
        contractName = metadata.name;
      }
      if (metadata.metadata.sources) {
        sources = await fetchSourceFilesFromMetadata(metadata, this.storage);
      }
    } catch (err) {
      // no-op
    }
    return new TransactionError({
      reason,
      from,
      to,
      method,
      data,
      network,
      rpcUrl,
      value,
      hash,
      contractName,
      sources
    }, error);
  }

  /**
   * @internal
   */
  async sendGaslessTransaction(fn) {
    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    let callOverrides = arguments.length > 2 ? arguments[2] : undefined;
    const signer = this.getSigner();
    invariant__default["default"](signer, "Cannot execute gasless transaction without valid signer");
    const chainId = await this.getChainID();
    const from = await this.getSignerAddress();
    const to = this.writeContract.address;
    const value = callOverrides?.value || 0;
    if (ethers.BigNumber.from(value).gt(0)) {
      throw new Error("Cannot send native token value with gasless transaction");
    }
    const data = this.writeContract.interface.encodeFunctionData(fn, args);
    let gas = ethers.BigNumber.from(0);
    try {
      const gasEstimate = await this.readContract.estimateGas[fn](...args);
      gas = gasEstimate.mul(2);
    } catch (e) {
      // ignore
    }

    // in some cases WalletConnect doesn't properly gives an estimate for how much gas it would actually use.
    // as a fix, we're setting it to a high arbitrary number (500k) as the gas limit that should cover for most function calls.
    if (gas.lt(100000)) {
      gas = ethers.BigNumber.from(500000);
    }

    // check for gas override in callOverrides
    if (callOverrides.gasLimit && ethers.BigNumber.from(callOverrides.gasLimit).gt(gas)) {
      gas = ethers.BigNumber.from(callOverrides.gasLimit);
    }
    const tx = {
      from,
      to,
      data,
      chainId,
      gasLimit: gas,
      functionName: fn.toString(),
      functionArgs: args,
      callOverrides
    };
    return await this.defaultGaslessSendFunction(tx);
  }
  async signTypedData(signer, domain, types, message) {
    this.emit(EventType.Signature, {
      status: "submitted",
      message,
      signature: ""
    });
    const {
      signature: sig
    } = await signTypedDataInternal(signer, domain, types, message);
    this.emit(EventType.Signature, {
      status: "completed",
      message,
      signature: sig
    });
    return sig;
  }
  parseLogs(eventName, logs) {
    if (!logs || logs.length === 0) {
      return [];
    }
    const topic = this.writeContract.interface.getEventTopic(eventName);
    const parsedLogs = logs.filter(x => x.topics.indexOf(topic) >= 0);
    return parsedLogs.map(l => this.writeContract.interface.parseLog(l));
  }
  async defaultGaslessSendFunction(transaction) {
    if (this.options.gasless && "biconomy" in this.options.gasless) {
      return this.biconomySendFunction(transaction);
    } else if (this.options.gasless && "openzeppelin" in this.options.gasless) {
      return this.defenderSendFunction(transaction);
    }
    return this.engineSendFunction(transaction);
  }
  async engineSendFunction(transaction) {
    invariant__default["default"](this.options.gasless && "engine" in this.options.gasless, "calling engine gasless transaction without engine config in the SDK options");
    const request = await this.enginePrepareRequest(transaction);
    const res = await fetch(this.options.gasless.engine.relayerUrl, {
      ...request,
      headers: {
        "Content-Type": "application/json"
      }
    });
    const data = await res.json();
    if (data.error) {
      throw new Error(data.error?.message || JSON.stringify(data.error));
    }
    const queueId = data.result.queueId;
    const engineUrl = this.options.gasless.engine.relayerUrl.split("/relayer/")[0];
    const startTime = Date.now();
    while (true) {
      const txRes = await fetch(`${engineUrl}/transaction/status/${queueId}`);
      const txData = await txRes.json();
      if (txData.result.transactionHash) {
        return txData.result.transactionHash;
      }

      // Time out after 30s
      if (Date.now() - startTime > 30 * 1000) {
        throw new Error("timeout");
      }

      // Poll to check if the transaction was mined
      await new Promise(resolve => setTimeout(resolve, 2000));
    }
  }
  async enginePrepareRequest(transaction) {
    invariant__default["default"](this.options.gasless && "engine" in this.options.gasless, "calling engine gasless transaction without openzeppelin config in the SDK options");
    const signer = this.getSigner();
    const provider = this.getProvider();
    const storage = this.storage;
    invariant__default["default"](signer, "signer is not set");
    try {
      const {
        abi
      } = await fetchContractMetadataFromAddress(transaction.to, provider, storage);
      const chainId = (await provider.getNetwork()).chainId;
      const contract = new ContractWrapper(signer, transaction.to, abi, {}, storage);
      if (abi.find(item => item.name === "executeMetaTransaction")) {
        const name = await contract.call("name", []);
        const domain = {
          name,
          version: "1",
          salt: "0x" + chainId.toString(16).padStart(64, "0"),
          // Use 64 length hex chain id as salt
          verifyingContract: transaction.to
        };
        const types = {
          MetaTransaction: [{
            name: "nonce",
            type: "uint256"
          }, {
            name: "from",
            type: "address"
          }, {
            name: "functionSignature",
            type: "bytes"
          }]
        };
        const nonce = await contract.call("getNonce", [transaction.from]);
        const message = {
          nonce: nonce,
          from: transaction.from,
          functionSignature: transaction.data
        };
        const {
          signature
        } = await signTypedDataInternal(signer, domain, types, message);
        return {
          method: "POST",
          body: JSON.stringify({
            type: "execute-meta-transaction",
            request: {
              from: transaction.from,
              to: transaction.to,
              data: transaction.data
            },
            signature
          })
        };
      }
    } catch {
      // no-op
    }
    if (transaction.functionName === "approve" && transaction.functionArgs.length === 2) {
      const spender = transaction.functionArgs[0];
      const amount = transaction.functionArgs[1];
      // TODO: support DAI permit by signDAIPermit
      const {
        message: permit,
        signature: sig
      } = await signEIP2612Permit(signer, transaction.to, transaction.from, spender, amount, this.options.gasless.engine.domainSeparatorVersion);
      const message = {
        to: transaction.to,
        owner: permit.owner,
        spender: permit.spender,
        value: ethers.BigNumber.from(permit.value).toString(),
        nonce: ethers.BigNumber.from(permit.nonce).toString(),
        deadline: ethers.BigNumber.from(permit.deadline).toString()
      };
      return {
        method: "POST",
        body: JSON.stringify({
          type: "permit",
          request: message,
          signature: sig
        })
      };
    } else {
      const forwarderAddress = this.options.gasless.engine.relayerForwarderAddress || CONTRACT_ADDRESSES[transaction.chainId]?.openzeppelinForwarder || (await computeForwarderAddress(provider, storage));
      const ForwarderABI = (await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@thirdweb-dev/contracts-js/dist/abis/Forwarder.json')); })).default;
      const forwarder = new ethers.Contract(forwarderAddress, ForwarderABI, provider);
      const nonce = await getAndIncrementNonce(forwarder, "getNonce", [transaction.from]);
      let domain;
      let types;
      let message;
      if (this.options.gasless.experimentalChainlessSupport) {
        domain = {
          name: "GSNv2 Forwarder",
          version: "0.0.1",
          verifyingContract: forwarderAddress
        };
        types = {
          ForwardRequest: ChainAwareForwardRequest
        };
        message = {
          from: transaction.from,
          to: transaction.to,
          value: ethers.BigNumber.from(0).toString(),
          gas: ethers.BigNumber.from(transaction.gasLimit).toString(),
          nonce: ethers.BigNumber.from(nonce).toString(),
          data: transaction.data,
          chainid: ethers.BigNumber.from(transaction.chainId).toString()
        };
      } else {
        domain = {
          name: this.options.gasless.engine.domainName,
          version: this.options.gasless.engine.domainVersion,
          chainId: transaction.chainId,
          verifyingContract: forwarderAddress
        };
        types = {
          ForwardRequest
        };
        message = {
          from: transaction.from,
          to: transaction.to,
          value: ethers.BigNumber.from(0).toString(),
          gas: ethers.BigNumber.from(transaction.gasLimit).toString(),
          nonce: ethers.BigNumber.from(nonce).toString(),
          data: transaction.data
        };
      }
      const {
        signature: sig
      } = await signTypedDataInternal(signer, domain, types, message);
      const signature = sig;
      return {
        method: "POST",
        body: JSON.stringify({
          type: "forward",
          request: message,
          signature,
          forwarderAddress
        })
      };
    }
  }
  async biconomySendFunction(transaction) {
    invariant__default["default"](this.options.gasless && "biconomy" in this.options.gasless, "calling biconomySendFunction without biconomy");
    const signer = this.getSigner();
    const provider = this.getProvider();
    invariant__default["default"](signer && provider, "signer and provider must be set");
    const forwarder = new ethers.Contract(getContractAddressByChainId(transaction.chainId, "biconomyForwarder"), BiconomyForwarderAbi, provider);
    const batchId = 0;
    const batchNonce = await getAndIncrementNonce(forwarder, "getNonce", [transaction.from, batchId]);
    const request = {
      from: transaction.from,
      to: transaction.to,
      token: ethers.constants.AddressZero,
      txGas: transaction.gasLimit.toNumber(),
      tokenGasPrice: "0",
      batchId,
      batchNonce: batchNonce.toNumber(),
      deadline: Math.floor(Date.now() / 1000 + (this.options?.gasless && "biconomy" in this.options.gasless && this.options.gasless.biconomy?.deadlineSeconds || 3600)),
      data: transaction.data
    };
    const hashToSign = ethers.utils.arrayify(ethers.utils.solidityKeccak256(["address", "address", "address", "uint256", "uint256", "uint256", "uint256", "uint256", "bytes32"], [request.from, request.to, request.token, request.txGas, request.tokenGasPrice, request.batchId, request.batchNonce, request.deadline, ethers.utils.keccak256(request.data)]));
    this.emit(EventType.Signature, {
      status: "submitted",
      message: hashToSign,
      signature: ""
    });
    const signature = await signer.signMessage(hashToSign);
    this.emit(EventType.Signature, {
      status: "completed",
      message: hashToSign,
      signature
    });
    const response = await fetch("https://api.biconomy.io/api/v2/meta-tx/native", {
      method: "POST",
      body: JSON.stringify({
        from: transaction.from,
        apiId: this.options.gasless.biconomy.apiId,
        params: [request, signature],
        to: transaction.to,
        gasLimit: transaction.gasLimit.toHexString()
      }),
      headers: {
        "x-api-key": this.options.gasless.biconomy.apiKey,
        "Content-Type": "application/json;charset=utf-8"
      }
    });
    if (response.ok) {
      const resp = await response.json();
      if (!resp.txHash) {
        throw new Error(`relay transaction failed: ${resp.log}`);
      }
      return resp.txHash;
    }
    throw new Error(`relay transaction failed with status: ${response.status} (${response.statusText})`);
  }
  async defenderSendFunction(transaction) {
    invariant__default["default"](this.options.gasless && "openzeppelin" in this.options.gasless, "calling openzeppelin gasless transaction without openzeppelin config in the SDK options");
    const signer = this.getSigner();
    const provider = this.getProvider();
    invariant__default["default"](signer, "provider is not set");
    invariant__default["default"](provider, "provider is not set");
    const ForwarderABI = (await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@thirdweb-dev/contracts-js/dist/abis/Forwarder.json')); })).default;
    const forwarderAddress = this.options.gasless.openzeppelin.relayerForwarderAddress || (this.options.gasless.openzeppelin.useEOAForwarder ? CONTRACT_ADDRESSES[transaction.chainId]?.openzeppelinForwarderEOA || (await computeEOAForwarderAddress(this.getProvider(), this.storage, "", this.options.clientId, this.options.secretKey)) : CONTRACT_ADDRESSES[transaction.chainId]?.openzeppelinForwarder || (await computeForwarderAddress(this.getProvider(), this.storage, "", this.options.clientId, this.options.secretKey)));
    const forwarder = new ethers.Contract(forwarderAddress, ForwarderABI, provider);
    const nonce = await getAndIncrementNonce(forwarder, "getNonce", [transaction.from]);
    let domain;
    let types;
    let message;
    if (this.options.gasless.experimentalChainlessSupport) {
      domain = {
        name: "GSNv2 Forwarder",
        version: "0.0.1",
        verifyingContract: forwarderAddress
      };
      types = {
        ForwardRequest: ChainAwareForwardRequest
      };
      message = {
        from: transaction.from,
        to: transaction.to,
        value: ethers.BigNumber.from(0).toString(),
        gas: ethers.BigNumber.from(transaction.gasLimit).toString(),
        nonce: ethers.BigNumber.from(nonce).toString(),
        data: transaction.data,
        chainid: ethers.BigNumber.from(transaction.chainId).toString()
      };
    } else {
      domain = {
        name: this.options.gasless.openzeppelin.domainName,
        version: this.options.gasless.openzeppelin.domainVersion,
        chainId: transaction.chainId,
        verifyingContract: forwarderAddress
      };
      types = {
        ForwardRequest
      };
      message = {
        from: transaction.from,
        to: transaction.to,
        value: ethers.BigNumber.from(0).toString(),
        gas: ethers.BigNumber.from(transaction.gasLimit).toString(),
        nonce: ethers.BigNumber.from(nonce).toString(),
        data: transaction.data
      };
    }
    let signature;
    this.emit(EventType.Signature, {
      status: "submitted",
      message,
      signature: ""
    });

    // if the executing function is "approve" and matches with erc20 approve signature
    // and if the token supports permit, then we use permit for gasless instead of approve.
    if (transaction.functionName === "approve" && transaction.functionArgs.length === 2) {
      const spender = transaction.functionArgs[0];
      const amount = transaction.functionArgs[1];
      // TODO: support DAI permit by signDAIPermit
      const {
        message: permit,
        signature: sig
      } = await signEIP2612Permit(signer, this.writeContract.address, transaction.from, spender, amount, this.options.gasless.openzeppelin.domainSeparatorVersion);
      const {
        r,
        s,
        v
      } = ethers.utils.splitSignature(sig);
      message = {
        to: this.address,
        owner: permit.owner,
        spender: permit.spender,
        value: ethers.BigNumber.from(permit.value).toString(),
        nonce: ethers.BigNumber.from(permit.nonce).toString(),
        deadline: ethers.BigNumber.from(permit.deadline).toString(),
        r,
        s,
        v
      };
      signature = sig;
    } else {
      const {
        signature: sig
      } = await signTypedDataInternal(signer, domain, types, message);
      signature = sig;
    }
    let messageType = "forward";

    // if has owner property then it's permit :)
    if (message?.owner) {
      messageType = "permit";
    }
    const body = JSON.stringify({
      request: message,
      signature,
      forwarderAddress,
      type: messageType
    });
    this.emit(EventType.Signature, {
      status: "completed",
      message,
      signature
    });
    const response = await fetch(this.options.gasless.openzeppelin.relayerUrl, {
      method: "POST",
      body
    });
    if (response.ok) {
      const resp = await response.json();
      if (!resp.result) {
        throw new Error(`Relay transaction failed: ${resp.message}`);
      }
      const result = JSON.parse(resp.result);
      return result.txHash;
    }
    throw new Error(`relay transaction failed with status: ${response.status} (${response.statusText})`);
  }
}

/**
 * Checks whether the given ABI supports a given feature
 * @deprecated use isExtensionEnabled instead
 * @param abi - The abi to check
 * @param featureName - The feature name to check
 * @internal
 */
function isFeatureEnabled(abi, featureName, features) {
  return _featureEnabled(features, featureName);
}

/**
 * Checks whether the given ABI supports a given extension
 * @public
 * @param abi - The abi to check
 * @param featureName - The feature name to check
 */
function isExtensionEnabled(abi, featureName, features) {
  return isFeatureEnabled(abi, featureName, features);
}

/**
 * Searches the feature map for featureName and returns whether its enabled
 * @internal
 * @param features - The feature map to search
 * @param featureName - The feature name to search for
 */
function _featureEnabled(features, featureName) {
  const keys = Object.keys(features);
  if (!keys.includes(featureName)) {
    let found = false;
    for (const key of keys) {
      const f = features[key];
      found = _featureEnabled(f.features, featureName);
      if (found) {
        break;
      }
    }
    return found;
  }
  const feature = features[featureName];
  return feature.enabled;
}

/**
 * @internal
 */
async function getPluginABI(addresses, provider, storage) {
  return (await Promise.all(addresses.map(address => fetchContractMetadataFromAddress(address, provider, storage).catch(err => {
    console.error(`Failed to fetch plug-in for ${address}`, err);
    return {
      abi: []
    };
  })))).map(metadata => metadata.abi);
}

/**
 * @internal
 */
async function getCompositeABI(address, abi, provider, options, storage) {
  let pluginABIs = [];
  try {
    // TODO this should not be needed here, should only be done once in getContract()
    const features = detectFeatures(abi);
    // check if contract is plugin-pattern / dynamic
    const isPluginRouter = isExtensionEnabled(abi, "PluginRouter", features);
    const isbaseRouter = isExtensionEnabled(abi, "DynamicContract", features);
    // check if the contract has fallback function - we'll further check for diamond pattern if needed
    const isFallback = isExtensionEnabled(abi, "Fallback", features);
    if (isbaseRouter) {
      const contract = new ContractWrapper(provider, address, getAllExtensionsAbi, options, storage);
      const plugins = await contract.call("getAllExtensions");

      // get extension addresses
      const pluginAddresses = plugins.map(item => item.metadata.implementation);

      // get ABIs of extension contracts --
      pluginABIs = await getPluginABI(pluginAddresses, provider, storage);
    } else if (isPluginRouter) {
      const contract = new ContractWrapper(provider, address, getAllPluginsAbi, options, storage);
      const pluginMap = await contract.call("getAllPlugins");

      // get extension addresses
      const allPlugins = pluginMap.map(item => item.pluginAddress);
      const plugins = Array.from(new Set(allPlugins));

      // get ABIs of extension contracts
      pluginABIs = await getPluginABI(plugins, provider, storage);
    } else if (isFallback) {
      // check if diamond pattern
      const dimaondAbi = ["function facets() external view returns (tuple(address,bytes4[])[])"];
      const contract = new ethers.Contract(address, dimaondAbi, provider);

      // get facets
      const facets = await contract.facets();

      // filter facet addresses
      const facetAddresses = facets.map(item => item[0]);

      // get ABI of facets
      pluginABIs = await getPluginABI(facetAddresses, provider, storage);
    }
  } catch (err) {}
  return pluginABIs.length > 0 ? joinABIs([...pluginABIs], abi) : abi;
}

/**
 *
 * @internal
 */
const roleMap = {
  admin: "",
  transfer: "TRANSFER_ROLE",
  minter: "MINTER_ROLE",
  pauser: "PAUSER_ROLE",
  lister: "LISTER_ROLE",
  asset: "ASSET_ROLE",
  unwrap: "UNWRAP_ROLE",
  factory: "FACTORY_ROLE",
  signer: "SIGNER_ROLE",
  metadata: "METADATA_ROLE",
  revoke: "REVOKE_ROLE",
  migration: "MIGRATION_ROLE"
};

/**
 * @public
 */

/**
 * @public
 */
const ALL_ROLES = /* @__PURE__ */(() => Object.keys(roleMap))();

/**
 * @internal
 */
function getRoleHash(role) {
  if (role === "admin") {
    return ethers.utils.hexZeroPad([0], 32);
  }
  return ethers.utils.id(roleMap[role]);
}

const DropErc1155ContractInput = /* @__PURE__ */(() => CommonContractSchema.merge(CommonRoyaltySchema).merge(MerkleSchema).merge(CommonSymbolSchema))();
const DropErc1155ContractOutput = /* @__PURE__ */(() => CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(MerkleSchema).merge(CommonSymbolSchema))();
const DropErc1155ContractDeploy = /* @__PURE__ */(() => DropErc1155ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema))();
const DropErc1155ContractSchema = {
  deploy: DropErc1155ContractDeploy,
  output: DropErc1155ContractOutput,
  input: DropErc1155ContractInput
};

const DropErc20ContractInput = /* @__PURE__ */(() => CommonContractSchema.merge(MerkleSchema).merge(CommonSymbolSchema))();
const DropErc20ContractOutput = /* @__PURE__ */(() => CommonContractOutputSchema.merge(MerkleSchema).merge(CommonSymbolSchema))();
const DropErc20ContractDeploy = /* @__PURE__ */(() => DropErc20ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema))();
const DropErc20ContractSchema = {
  deploy: DropErc20ContractDeploy,
  output: DropErc20ContractOutput,
  input: DropErc20ContractInput
};

const DropErc721ContractInput = /* @__PURE__ */(() => CommonContractSchema.merge(CommonRoyaltySchema).merge(MerkleSchema).merge(CommonSymbolSchema))();
const DropErc721ContractOutput = /* @__PURE__ */(() => CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(MerkleSchema).merge(CommonSymbolSchema))();
const DropErc721ContractDeploy = /* @__PURE__ */(() => DropErc721ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema))();
const DropErc721ContractSchema = {
  deploy: DropErc721ContractDeploy,
  output: DropErc721ContractOutput,
  input: DropErc721ContractInput
};

const MarketplaceContractInput = CommonContractSchema;
const MarketplaceContractOutput = CommonContractOutputSchema;
const MarketplaceContractDeploy = /* @__PURE__ */(() => MarketplaceContractInput.merge(CommonPlatformFeeSchema).merge(CommonTrustedForwarderSchema))();
const MarketplaceContractSchema = {
  deploy: MarketplaceContractDeploy,
  output: MarketplaceContractOutput,
  input: MarketplaceContractInput
};

const MultiwrapContractInput = /* @__PURE__ */(() => CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema))();
const MultiwrapContractOutput = /* @__PURE__ */(() => CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema))();
const MultiwrapContractDeploy = /* @__PURE__ */(() => MultiwrapContractInput.merge(CommonTrustedForwarderSchema))();
const MultiwrapContractSchema = {
  deploy: MultiwrapContractDeploy,
  output: MultiwrapContractOutput,
  input: MultiwrapContractInput
};

const PackContractInput = /* @__PURE__ */(() => CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema))();
const PackContractOutput = /* @__PURE__ */(() => CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema))();
const PackContractDeploy = /* @__PURE__ */(() => PackContractInput.merge(CommonPlatformFeeSchema).merge(CommonTrustedForwarderSchema))();
const PackContractSchema = {
  deploy: PackContractDeploy,
  output: PackContractOutput,
  input: PackContractInput
};

const SplitRecipientInputSchema = /* @__PURE__ */(() => zod.z.object({
  address: AddressOrEnsSchema,
  sharesBps: BasisPointsSchema.gt(0, "Shares must be greater than 0")
}))();
const SplitRecipientOuputSchema = /* @__PURE__ */(() => SplitRecipientInputSchema.extend({
  address: AddressOrEnsSchema,
  sharesBps: BasisPointsSchema
}))();
const SplitsContractInput = /* @__PURE__ */(() => CommonContractSchema.extend({
  recipients: zod.z.array(SplitRecipientInputSchema).default([]).superRefine((val, context) => {
    const addressMap = {};
    let totalShares = 0;
    for (let index = 0; index < val.length; index++) {
      const entry = val[index];
      if (addressMap[entry.address]) {
        context.addIssue({
          code: zod.z.ZodIssueCode.custom,
          message: `Duplicate address.`,
          path: [index, `address`]
        });
      }
      addressMap[entry.address] = true;
      totalShares += entry.sharesBps;
      if (totalShares > 10000) {
        context.addIssue({
          code: zod.z.ZodIssueCode.custom,
          message: `Total shares cannot go over 100%.`,
          path: [index, `sharesBps`]
        });
      }
    }
    if (totalShares !== 10000) {
      context.addIssue({
        code: zod.z.ZodIssueCode.custom,
        message: `Total shares need to add up to 100%. Total shares are currently ${totalShares / 100}%`,
        path: []
      });
    }
  })
}))();
const SplitsContractOutput = /* @__PURE__ */(() => CommonContractOutputSchema.extend({
  recipients: zod.z.array(SplitRecipientOuputSchema)
}))();
const SplitsContractDeploy = /* @__PURE__ */(() => SplitsContractInput.merge(SplitsContractInput).merge(CommonTrustedForwarderSchema))();
const SplitsContractSchema = {
  deploy: SplitsContractDeploy,
  output: SplitsContractOutput,
  input: SplitsContractInput
};

const TokenErc1155ContractInput = /* @__PURE__ */(() => CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema))();
const TokenErc1155ContractOutput = /* @__PURE__ */(() => CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema))();
const TokenErc1155ContractDeploy = /* @__PURE__ */(() => TokenErc1155ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema))();
const TokenErc1155ContractSchema = {
  deploy: TokenErc1155ContractDeploy,
  output: TokenErc1155ContractOutput,
  input: TokenErc1155ContractInput
};

const TokenErc20ContractInput = /* @__PURE__ */(() => CommonContractSchema.merge(CommonSymbolSchema))();
const TokenErc20ContractOutput = /* @__PURE__ */(() => CommonContractOutputSchema.merge(CommonSymbolSchema))();
const TokenErc20ContractDeploy = /* @__PURE__ */(() => TokenErc20ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema))();
const TokenErc20ContractSchema = {
  deploy: TokenErc20ContractDeploy,
  output: TokenErc20ContractOutput,
  input: TokenErc20ContractInput
};

const TokenErc721ContractInput = /* @__PURE__ */(() => CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema))();
const TokenErc721ContractOutput = /* @__PURE__ */(() => CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema))();
const TokenErc721ContractDeploy = /* @__PURE__ */(() => TokenErc721ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema))();
const TokenErc721ContractSchema = {
  deploy: TokenErc721ContractDeploy,
  output: TokenErc721ContractOutput,
  input: TokenErc721ContractInput
};

const VoteSettingsInputSchema = /* @__PURE__ */(() => zod.z.object({
  voting_delay_in_blocks: zod.z.number().min(0).default(0),
  voting_period_in_blocks: zod.z.number().min(1).default(1),
  voting_token_address: AddressOrEnsSchema,
  voting_quorum_fraction: PercentSchema.default(0),
  proposal_token_threshold: BigNumberishSchema.default(1)
}))();
const VoteSettingsOuputSchema = /* @__PURE__ */(() => VoteSettingsInputSchema.extend({
  proposal_token_threshold: BigNumberSchema
}))();
const VoteContractInput = /* @__PURE__ */(() => CommonContractSchema.merge(VoteSettingsInputSchema))();
const VoteContractOutput = /* @__PURE__ */(() => CommonContractOutputSchema.merge(VoteSettingsOuputSchema))();
const VoteContractDeploy = /* @__PURE__ */(() => VoteContractInput.merge(CommonTrustedForwarderSchema))();
const VoteContractSchema = {
  deploy: VoteContractDeploy,
  output: VoteContractOutput,
  input: VoteContractInput
};
const ProposalOutputSchema = /* @__PURE__ */(() => zod.z.object({
  proposalId: BigNumberSchema,
  proposer: zod.z.string(),
  targets: zod.z.array(zod.z.string()),
  values: zod.z.array(BigNumberSchema),
  signatures: zod.z.array(zod.z.string()),
  calldatas: zod.z.array(zod.z.string()),
  startBlock: BigNumberSchema,
  endBlock: BigNumberSchema,
  description: zod.z.string()
}))();

const ADMIN_ROLE = ["admin"];
const NFT_BASE_CONTRACT_ROLES = ["admin", "minter", "transfer", "metadata"];
const MARKETPLACE_CONTRACT_ROLES = ["admin", "lister", "asset"];
const PACK_CONTRACT_ROLES = ["admin", "minter", "asset", "transfer"];
const TOKEN_DROP_CONTRACT_ROLES = ["admin", "transfer"];
const MULTIWRAP_CONTRACT_ROLES = ["admin", "transfer", "minter", "unwrap", "asset"];

const prebuiltContractTypes = {
  vote: "vote",
  token: "token",
  "edition-drop": "edition-drop",
  edition: "edition",
  marketplace: "marketplace",
  "marketplace-v3": "marketplace-v3",
  multiwrap: "multiwrap",
  "nft-collection": "nft-collection",
  "nft-drop": "nft-drop",
  pack: "pack",
  "signature-drop": "signature-drop",
  split: "split",
  "token-drop": "token-drop"
};
/**
 * @internal
 */
const EditionDropInitializer = {
  name: "DropERC1155",
  contractType: prebuiltContractTypes["edition-drop"],
  schema: DropErc1155ContractSchema,
  roles: NFT_BASE_CONTRACT_ROLES,
  initialize: async function () {
    for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {
      _ref[_key] = arguments[_key];
    }
    let [network, address, storage, options] = _ref;
    const [, provider] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([EditionDropInitializer.getAbi(address, provider, storage), Promise.resolve().then(function () { return require('./edition-drop-677f9696.cjs.dev.js'); }), provider.getNetwork()]);
    return new contract.EditionDrop(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider, storage) => {
    const abi = await fetchAbiFromAddress(address, provider, storage);
    if (abi) {
      return abi;
    }
    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4
    const contractInfo = await getContractInfo(address, provider);
    return !contractInfo || contractInfo.version > 2 ? (await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@thirdweb-dev/contracts-js/dist/abis/DropERC1155.json')); })).default : (await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@thirdweb-dev/contracts-js/dist/abis/DropERC1155_V2.json')); })).default;
  }
};

/**
 * @internal
 */
const EditionInitializer = {
  name: "TokenERC1155",
  contractType: prebuiltContractTypes["edition"],
  schema: TokenErc1155ContractSchema,
  roles: NFT_BASE_CONTRACT_ROLES,
  initialize: async function () {
    for (var _len2 = arguments.length, _ref2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      _ref2[_key2] = arguments[_key2];
    }
    let [network, address, storage, options] = _ref2;
    const [, provider] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([EditionInitializer.getAbi(address, provider, storage), Promise.resolve().then(function () { return require('./edition-eeceae03.cjs.dev.js'); }), provider.getNetwork()]);
    return new contract.Edition(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider, storage) => {
    const abi = await fetchAbiFromAddress(address, provider, storage);
    if (abi) {
      return abi;
    }
    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4
    return (await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@thirdweb-dev/contracts-js/dist/abis/TokenERC1155.json')); })).default;
  }
};

/**
 * @internal
 */
const MarketplaceInitializer = {
  name: "Marketplace",
  contractType: prebuiltContractTypes.marketplace,
  schema: MarketplaceContractSchema,
  roles: MARKETPLACE_CONTRACT_ROLES,
  initialize: async function () {
    for (var _len3 = arguments.length, _ref3 = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      _ref3[_key3] = arguments[_key3];
    }
    let [network, address, storage, options] = _ref3;
    const [, provider] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([MarketplaceInitializer.getAbi(address, provider, storage), Promise.resolve().then(function () { return require('./marketplace-af63d729.cjs.dev.js'); }), provider.getNetwork()]);
    return new contract.Marketplace(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider, storage) => {
    const abi = await fetchAbiFromAddress(address, provider, storage);
    if (abi) {
      return abi;
    }

    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4
    return (await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@thirdweb-dev/contracts-js/dist/abis/Marketplace.json')); })).default;
  }
};

/**
 * @internal
 */
const MarketplaceV3Initializer = {
  name: "MarketplaceV3",
  contractType: prebuiltContractTypes["marketplace-v3"],
  schema: MarketplaceContractSchema,
  roles: MARKETPLACE_CONTRACT_ROLES,
  initialize: async function () {
    for (var _len4 = arguments.length, _ref4 = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      _ref4[_key4] = arguments[_key4];
    }
    let [network, address, storage, options] = _ref4;
    const [, provider] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([MarketplaceV3Initializer.getAbi(address, provider, storage, options), Promise.resolve().then(function () { return require('./marketplacev3-99aea8ca.cjs.dev.js'); }), provider.getNetwork()]);
    return new contract.MarketplaceV3(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider, storage, options) => {
    const chainId = (await provider.getNetwork()).chainId;
    const isZkSync = chainId === 280 || chainId === 324;

    // Can't resolve IPFS hash from plugin bytecode on ZkSync
    // Thus, pull the composite ABI from the release page
    if (isZkSync) {
      const publishedContract = await fetchPublishedContractFromPolygon(THIRDWEB_DEPLOYER, "MarketplaceV3", "latest", storage, options?.clientId, options?.secretKey);
      const uri = publishedContract.metadataUri;
      const compositeAbi = await getCompositeABIfromRelease(uri, storage);
      return compositeAbi;
    }
    const abi = await fetchAbiFromAddress(address, provider, storage);
    if (abi) {
      return await getCompositeABI(address, abi, provider, {}, storage);
    }

    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4
    const localAbi = (await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@thirdweb-dev/contracts-js/dist/abis/MarketplaceV3.json')); })).default;
    return await getCompositeABI(address, AbiSchema.parse(localAbi || []), provider, {}, storage);
  }
};

/**
 * @internal
 */
const MultiwrapInitializer = {
  name: "Multiwrap",
  contractType: prebuiltContractTypes.multiwrap,
  schema: MultiwrapContractSchema,
  roles: MULTIWRAP_CONTRACT_ROLES,
  initialize: async function () {
    for (var _len5 = arguments.length, _ref5 = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      _ref5[_key5] = arguments[_key5];
    }
    let [network, address, storage, options] = _ref5;
    const [, provider] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([MultiwrapInitializer.getAbi(address, provider, storage), Promise.resolve().then(function () { return require('./multiwrap-dbc8c8f3.cjs.dev.js'); }), provider.getNetwork()]);
    return new contract.Multiwrap(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider, storage) => {
    const abi = await fetchAbiFromAddress(address, provider, storage);
    if (abi) {
      return abi;
    }
    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4
    return (await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@thirdweb-dev/contracts-js/dist/abis/Multiwrap.json')); })).default;
  }
};

/**
 * @internal
 */
const NFTCollectionInitializer = {
  name: "TokenERC721",
  contractType: prebuiltContractTypes["nft-collection"],
  schema: TokenErc721ContractSchema,
  roles: NFT_BASE_CONTRACT_ROLES,
  initialize: async function () {
    for (var _len6 = arguments.length, _ref6 = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      _ref6[_key6] = arguments[_key6];
    }
    let [network, address, storage, options] = _ref6;
    const [, provider] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([NFTCollectionInitializer.getAbi(address, provider, storage), Promise.resolve().then(function () { return require('./nft-collection-85359da4.cjs.dev.js'); }), provider.getNetwork()]);
    return new contract.NFTCollection(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider, storage) => {
    const abi = await fetchAbiFromAddress(address, provider, storage);
    if (abi) {
      return abi;
    }
    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4
    return (await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@thirdweb-dev/contracts-js/dist/abis/TokenERC721.json')); })).default;
  }
};

/**
 * @internal
 */
const NFTDropInitializer = {
  name: "DropERC721",
  contractType: prebuiltContractTypes["nft-drop"],
  schema: DropErc721ContractSchema,
  roles: NFT_BASE_CONTRACT_ROLES,
  initialize: async function () {
    for (var _len7 = arguments.length, _ref7 = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      _ref7[_key7] = arguments[_key7];
    }
    let [network, address, storage, options] = _ref7;
    const [, provider] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([NFTDropInitializer.getAbi(address, provider, storage), Promise.resolve().then(function () { return require('./nft-drop-2a2e975f.cjs.dev.js'); }), provider.getNetwork()]);
    return new contract.NFTDrop(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider, storage) => {
    const abi = await fetchAbiFromAddress(address, provider, storage);
    if (abi) {
      return abi;
    }
    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4
    const contractInfo = await getContractInfo(address, provider);
    return !contractInfo || contractInfo.version > 3 ? (await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@thirdweb-dev/contracts-js/dist/abis/DropERC721.json')); })).default : (await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@thirdweb-dev/contracts-js/dist/abis/DropERC721_V3.json')); })).default;
  }
};

/**
 * @internal
 */
const PackInitializer = {
  name: "Pack",
  contractType: prebuiltContractTypes["pack"],
  schema: PackContractSchema,
  roles: PACK_CONTRACT_ROLES,
  initialize: async function () {
    for (var _len8 = arguments.length, _ref8 = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      _ref8[_key8] = arguments[_key8];
    }
    let [network, address, storage, options] = _ref8;
    const [, provider] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([PackInitializer.getAbi(address, provider, storage), Promise.resolve().then(function () { return require('./pack-84828687.cjs.dev.js'); }), provider.getNetwork()]);
    return new contract.Pack(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider, storage) => {
    const abi = await fetchAbiFromAddress(address, provider, storage);
    if (abi) {
      return abi;
    }
    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4
    return AbiSchema.parse((await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@thirdweb-dev/contracts-js/dist/abis/Pack.json')); })).default || []);
  }
};

/**
 * @internal
 */
const SignatureDropInitializer = {
  name: "SignatureDrop",
  contractType: prebuiltContractTypes["signature-drop"],
  schema: DropErc721ContractSchema,
  roles: NFT_BASE_CONTRACT_ROLES,
  initialize: async function () {
    for (var _len9 = arguments.length, _ref9 = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
      _ref9[_key9] = arguments[_key9];
    }
    let [network, address, storage, options] = _ref9;
    const [, provider] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([SignatureDropInitializer.getAbi(address, provider, storage), Promise.resolve().then(function () { return require('./signature-drop-ee4296a6.cjs.dev.js'); }), provider.getNetwork()]);
    return new contract.SignatureDrop(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider, storage) => {
    const abi = await fetchAbiFromAddress(address, provider, storage);
    if (abi) {
      return abi;
    }
    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4
    const contractInfo = await getContractInfo(address, provider);
    return !contractInfo || contractInfo.version > 4 ? (await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@thirdweb-dev/contracts-js/dist/abis/SignatureDrop.json')); })).default : (await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@thirdweb-dev/contracts-js/dist/abis/SignatureDrop_V4.json')); })).default;
  }
};

/**
 * @internal
 */
const SplitInitializer = {
  name: "Split",
  contractType: prebuiltContractTypes["split"],
  schema: SplitsContractSchema,
  roles: ADMIN_ROLE,
  initialize: async function () {
    for (var _len10 = arguments.length, _ref10 = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
      _ref10[_key10] = arguments[_key10];
    }
    let [network, address, storage, options] = _ref10;
    const [, provider] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([SplitInitializer.getAbi(address, provider, storage), Promise.resolve().then(function () { return require('./split-1cbad045.cjs.dev.js'); }), provider.getNetwork()]);
    return new contract.Split(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider, storage) => {
    const abi = await fetchAbiFromAddress(address, provider, storage);
    if (abi) {
      return abi;
    }
    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4
    return (await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@thirdweb-dev/contracts-js/dist/abis/Split.json')); })).default;
  }
};

/**
 * @internal
 */
const TokenDropInitializer = {
  name: "DropERC20",
  contractType: prebuiltContractTypes["token-drop"],
  schema: DropErc20ContractSchema,
  roles: TOKEN_DROP_CONTRACT_ROLES,
  initialize: async function () {
    for (var _len11 = arguments.length, _ref11 = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
      _ref11[_key11] = arguments[_key11];
    }
    let [network, address, storage, options] = _ref11;
    const [, provider] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([TokenDropInitializer.getAbi(address, provider, storage), Promise.resolve().then(function () { return require('./token-drop-5e55b790.cjs.dev.js'); }), provider.getNetwork()]);
    return new contract.TokenDrop(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider, storage) => {
    const abi = await fetchAbiFromAddress(address, provider, storage);
    if (abi) {
      return abi;
    }
    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4
    const contractInfo = await getContractInfo(address, provider);
    return !contractInfo || contractInfo.version > 2 ? (await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@thirdweb-dev/contracts-js/dist/abis/DropERC20.json')); })).default : (await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@thirdweb-dev/contracts-js/dist/abis/DropERC20_V2.json')); })).default;
  }
};

/**
 * @internal
 */
const TokenInitializer = {
  name: "TokenERC20",
  contractType: prebuiltContractTypes.token,
  schema: TokenErc20ContractSchema,
  roles: NFT_BASE_CONTRACT_ROLES,
  initialize: async function () {
    for (var _len12 = arguments.length, _ref12 = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
      _ref12[_key12] = arguments[_key12];
    }
    let [network, address, storage, options] = _ref12;
    const [, provider] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([TokenInitializer.getAbi(address, provider, storage), Promise.resolve().then(function () { return require('./token-079a7622.cjs.dev.js'); }), provider.getNetwork()]);
    return new contract.Token(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider, storage) => {
    const abi = await fetchAbiFromAddress(address, provider, storage);
    if (abi) {
      return abi;
    }
    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4
    return (await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@thirdweb-dev/contracts-js/dist/abis/TokenERC20.json')); })).default;
  }
};

/**
 * @internal
 */
const VoteInitializer = {
  name: "VoteERC20",
  contractType: prebuiltContractTypes.vote,
  schema: VoteContractSchema,
  roles: [],
  initialize: async function () {
    for (var _len13 = arguments.length, _ref13 = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
      _ref13[_key13] = arguments[_key13];
    }
    let [network, address, storage, options] = _ref13;
    const [, provider] = getSignerAndProvider(network, options);
    const [abi, contract, _network] = await Promise.all([VoteInitializer.getAbi(address, provider, storage), Promise.resolve().then(function () { return require('./vote-3625e119.cjs.dev.js'); }), provider.getNetwork()]);
    return new contract.Vote(network, address, storage, options, abi, _network.chainId);
  },
  getAbi: async (address, provider, storage) => {
    const abi = await fetchAbiFromAddress(address, provider, storage);
    if (abi) {
      return abi;
    }
    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4
    return (await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@thirdweb-dev/contracts-js/dist/abis/VoteERC20.json')); })).default;
  }
};
async function getContractInfo(address, provider) {
  try {
    return await getPrebuiltInfo(address, provider);
  } catch (e) {
    return undefined;
  }
}

/**
 * a map from contractType - contract metadata
 * @internal
 */
const PREBUILT_CONTRACTS_MAP = {
  [prebuiltContractTypes["edition-drop"]]: EditionDropInitializer,
  [prebuiltContractTypes.edition]: EditionInitializer,
  [prebuiltContractTypes.marketplace]: MarketplaceInitializer,
  [prebuiltContractTypes["marketplace-v3"]]: MarketplaceV3Initializer,
  [prebuiltContractTypes.multiwrap]: MultiwrapInitializer,
  [prebuiltContractTypes["nft-collection"]]: NFTCollectionInitializer,
  [prebuiltContractTypes["nft-drop"]]: NFTDropInitializer,
  [prebuiltContractTypes.pack]: PackInitializer,
  [prebuiltContractTypes["signature-drop"]]: SignatureDropInitializer,
  [prebuiltContractTypes.split]: SplitInitializer,
  [prebuiltContractTypes["token-drop"]]: TokenDropInitializer,
  [prebuiltContractTypes.token]: TokenInitializer,
  [prebuiltContractTypes.vote]: VoteInitializer
};

/**
 * @internal
 */
const PREBUILT_CONTRACTS_APPURI_MAP = {
  [prebuiltContractTypes["edition-drop"]]: "ipfs://QmNm3wRzpKYWo1SRtJfgfxtvudp5p2nXD6EttcsQJHwTmk",
  [prebuiltContractTypes.edition]: "",
  [prebuiltContractTypes.marketplace]: "ipfs://QmbAgC8YwY36n8H2kuvSWsRisxDZ15QZw3xGZyk9aDvcv7/marketplace.html",
  [prebuiltContractTypes["marketplace-v3"]]: "ipfs://QmbAgC8YwY36n8H2kuvSWsRisxDZ15QZw3xGZyk9aDvcv7/marketplace-v3.html",
  [prebuiltContractTypes.multiwrap]: "",
  [prebuiltContractTypes["nft-collection"]]: "",
  [prebuiltContractTypes["nft-drop"]]: "ipfs://QmZptmVipc6SGFbKAyXcxGgohzTwYRXZ9LauRX5ite1xDK",
  [prebuiltContractTypes.pack]: "",
  [prebuiltContractTypes["signature-drop"]]: "ipfs://QmZptmVipc6SGFbKAyXcxGgohzTwYRXZ9LauRX5ite1xDK",
  [prebuiltContractTypes.split]: "",
  [prebuiltContractTypes["token-drop"]]: "ipfs://QmbAgC8YwY36n8H2kuvSWsRisxDZ15QZw3xGZyk9aDvcv7/erc20.html",
  [prebuiltContractTypes.token]: "",
  [prebuiltContractTypes.vote]: ""
};
const SmartContract = {
  name: "SmartContract",
  contractType: "custom",
  schema: {},
  roles: ALL_ROLES
};

/**
 * @internal
 */
const CONTRACTS_MAP = {
  ...PREBUILT_CONTRACTS_MAP,
  [SmartContract.contractType]: SmartContract
};

/**
 * @internal
 */
function getContractTypeForRemoteName(name) {
  return Object.values(CONTRACTS_MAP).find(contract => contract.name === name)?.contractType || "custom";
}

/**
 * @internal
 */
function getContractName(type) {
  return Object.values(CONTRACTS_MAP).find(contract => contract.contractType === type)?.name;
}

/**
 * @internal
 */

/**
 * @internal
 */

/**
 * @internal
 */

/**
 * @internal
 */

/**
 * @internal
 */

/**
 * @internal
 */

/**
 * @internal
 */

/**
 * @internal
 */

exports.ADMIN_ROLE = ADMIN_ROLE;
exports.ALL_ROLES = ALL_ROLES;
exports.AbiObjectSchema = AbiObjectSchema;
exports.AbiSchema = AbiSchema;
exports.AbiTypeSchema = AbiTypeSchema;
exports.AddressOrEnsSchema = AddressOrEnsSchema;
exports.AddressSchema = AddressSchema;
exports.AddressZero = AddressZero;
exports.AdminRoleMissingError = AdminRoleMissingError;
exports.AmountSchema = AmountSchema;
exports.AssetNotFoundError = AssetNotFoundError;
exports.AuctionAlreadyStartedError = AuctionAlreadyStartedError;
exports.AuctionHasNotEndedError = AuctionHasNotEndedError;
exports.BYOCContractMetadataSchema = BYOCContractMetadataSchema;
exports.BasisPointsSchema = BasisPointsSchema;
exports.BiconomyForwarderAbi = BiconomyForwarderAbi;
exports.BigNumberSchema = BigNumberSchema;
exports.BigNumberTransformSchema = BigNumberTransformSchema;
exports.BigNumberTransformSchema$1 = BigNumberTransformSchema$1;
exports.BigNumberishSchema = BigNumberishSchema;
exports.BytesLikeSchema = BytesLikeSchema;
exports.COMMON_FACTORY = COMMON_FACTORY;
exports.CONTRACTS_MAP = CONTRACTS_MAP;
exports.CONTRACT_ADDRESSES = CONTRACT_ADDRESSES;
exports.CREATE2_FACTORY_BYTECODE = CREATE2_FACTORY_BYTECODE;
exports.CallOverrideSchema = CallOverrideSchema;
exports.ChainAwareForwardRequest = ChainAwareForwardRequest;
exports.ChainId = ChainId;
exports.ChainIdToAddressSchema = ChainIdToAddressSchema;
exports.CommonContractOutputSchema = CommonContractOutputSchema;
exports.CommonContractSchema = CommonContractSchema;
exports.CommonPlatformFeeSchema = CommonPlatformFeeSchema;
exports.CommonPrimarySaleSchema = CommonPrimarySaleSchema;
exports.CommonRoyaltySchema = CommonRoyaltySchema;
exports.CommonSymbolSchema = CommonSymbolSchema;
exports.CommonTrustedForwarderSchema = CommonTrustedForwarderSchema;
exports.CompilerMetadataFetchedSchema = CompilerMetadataFetchedSchema;
exports.CompilerTypeInput = CompilerTypeInput;
exports.ContractInfoSchema = ContractInfoSchema;
exports.ContractWrapper = ContractWrapper;
exports.CustomContractDeploy = CustomContractDeploy;
exports.CustomContractInput = CustomContractInput;
exports.CustomContractOutput = CustomContractOutput;
exports.CustomContractSchema = CustomContractSchema;
exports.CustomFactoryInput = CustomFactoryInput;
exports.DEPLOYER_ABI = DEPLOYER_ABI;
exports.DEPLOYER_BYTECODE = DEPLOYER_BYTECODE;
exports.DeployTypeInput = DeployTypeInput;
exports.DeploymentNetworkInput = DeploymentNetworkInput;
exports.DropErc1155ContractDeploy = DropErc1155ContractDeploy;
exports.DropErc1155ContractInput = DropErc1155ContractInput;
exports.DropErc1155ContractOutput = DropErc1155ContractOutput;
exports.DropErc1155ContractSchema = DropErc1155ContractSchema;
exports.DropErc20ContractSchema = DropErc20ContractSchema;
exports.DropErc721ContractDeploy = DropErc721ContractDeploy;
exports.DropErc721ContractInput = DropErc721ContractInput;
exports.DropErc721ContractOutput = DropErc721ContractOutput;
exports.DropErc721ContractSchema = DropErc721ContractSchema;
exports.DuplicateFileNameError = DuplicateFileNameError;
exports.DuplicateLeafsError = DuplicateLeafsError;
exports.EditionDropInitializer = EditionDropInitializer;
exports.EditionInitializer = EditionInitializer;
exports.EventType = EventType;
exports.ExtensionNotImplementedError = ExtensionNotImplementedError;
exports.ExtraPublishMetadataSchemaInput = ExtraPublishMetadataSchemaInput;
exports.ExtraPublishMetadataSchemaOutput = ExtraPublishMetadataSchemaOutput;
exports.FEATURE_ACCOUNT = FEATURE_ACCOUNT;
exports.FEATURE_ACCOUNT_FACTORY = FEATURE_ACCOUNT_FACTORY;
exports.FEATURE_ACCOUNT_PERMISSIONS = FEATURE_ACCOUNT_PERMISSIONS;
exports.FEATURE_AIRDROP_ERC1155 = FEATURE_AIRDROP_ERC1155;
exports.FEATURE_AIRDROP_ERC20 = FEATURE_AIRDROP_ERC20;
exports.FEATURE_AIRDROP_ERC721 = FEATURE_AIRDROP_ERC721;
exports.FEATURE_APPURI = FEATURE_APPURI;
exports.FEATURE_DIRECT_LISTINGS = FEATURE_DIRECT_LISTINGS;
exports.FEATURE_DYNAMIC_CONTRACT = FEATURE_DYNAMIC_CONTRACT;
exports.FEATURE_EDITION = FEATURE_EDITION;
exports.FEATURE_EDITION_BATCH_MINTABLE = FEATURE_EDITION_BATCH_MINTABLE;
exports.FEATURE_EDITION_BURNABLE = FEATURE_EDITION_BURNABLE;
exports.FEATURE_EDITION_CLAIM_CONDITIONS_V2 = FEATURE_EDITION_CLAIM_CONDITIONS_V2;
exports.FEATURE_EDITION_CLAIM_CUSTOM = FEATURE_EDITION_CLAIM_CUSTOM;
exports.FEATURE_EDITION_ENUMERABLE = FEATURE_EDITION_ENUMERABLE;
exports.FEATURE_EDITION_LAZY_MINTABLE_V2 = FEATURE_EDITION_LAZY_MINTABLE_V2;
exports.FEATURE_EDITION_MINTABLE = FEATURE_EDITION_MINTABLE;
exports.FEATURE_EDITION_REVEALABLE = FEATURE_EDITION_REVEALABLE;
exports.FEATURE_EDITION_SIGNATURE_MINTABLE = FEATURE_EDITION_SIGNATURE_MINTABLE;
exports.FEATURE_EDITION_SUPPLY = FEATURE_EDITION_SUPPLY;
exports.FEATURE_EDITION_UPDATABLE_METADATA = FEATURE_EDITION_UPDATABLE_METADATA;
exports.FEATURE_ENGLISH_AUCTIONS = FEATURE_ENGLISH_AUCTIONS;
exports.FEATURE_METADATA = FEATURE_METADATA;
exports.FEATURE_NFT = FEATURE_NFT;
exports.FEATURE_NFT_BATCH_MINTABLE = FEATURE_NFT_BATCH_MINTABLE;
exports.FEATURE_NFT_BURNABLE = FEATURE_NFT_BURNABLE;
exports.FEATURE_NFT_CLAIM_CONDITIONS_V2 = FEATURE_NFT_CLAIM_CONDITIONS_V2;
exports.FEATURE_NFT_CLAIM_CUSTOM = FEATURE_NFT_CLAIM_CUSTOM;
exports.FEATURE_NFT_CLAIM_ZORA = FEATURE_NFT_CLAIM_ZORA;
exports.FEATURE_NFT_ENUMERABLE = FEATURE_NFT_ENUMERABLE;
exports.FEATURE_NFT_LAZY_MINTABLE = FEATURE_NFT_LAZY_MINTABLE;
exports.FEATURE_NFT_LOYALTY_CARD = FEATURE_NFT_LOYALTY_CARD;
exports.FEATURE_NFT_MINTABLE = FEATURE_NFT_MINTABLE;
exports.FEATURE_NFT_QUERYABLE = FEATURE_NFT_QUERYABLE;
exports.FEATURE_NFT_REVEALABLE = FEATURE_NFT_REVEALABLE;
exports.FEATURE_NFT_SHARED_METADATA = FEATURE_NFT_SHARED_METADATA;
exports.FEATURE_NFT_SIGNATURE_MINTABLE_V2 = FEATURE_NFT_SIGNATURE_MINTABLE_V2;
exports.FEATURE_NFT_SUPPLY = FEATURE_NFT_SUPPLY;
exports.FEATURE_NFT_TIERED_DROP = FEATURE_NFT_TIERED_DROP;
exports.FEATURE_NFT_UPDATABLE_METADATA = FEATURE_NFT_UPDATABLE_METADATA;
exports.FEATURE_OFFERS = FEATURE_OFFERS;
exports.FEATURE_OWNER = FEATURE_OWNER;
exports.FEATURE_PACK_VRF = FEATURE_PACK_VRF;
exports.FEATURE_PERMISSIONS = FEATURE_PERMISSIONS;
exports.FEATURE_PLATFORM_FEE = FEATURE_PLATFORM_FEE;
exports.FEATURE_PRIMARY_SALE = FEATURE_PRIMARY_SALE;
exports.FEATURE_ROYALTY = FEATURE_ROYALTY;
exports.FEATURE_TOKEN = FEATURE_TOKEN;
exports.FEATURE_TOKEN_BATCH_MINTABLE = FEATURE_TOKEN_BATCH_MINTABLE;
exports.FEATURE_TOKEN_BURNABLE = FEATURE_TOKEN_BURNABLE;
exports.FEATURE_TOKEN_CLAIM_CONDITIONS_V2 = FEATURE_TOKEN_CLAIM_CONDITIONS_V2;
exports.FEATURE_TOKEN_MINTABLE = FEATURE_TOKEN_MINTABLE;
exports.FEATURE_TOKEN_SIGNATURE_MINTABLE = FEATURE_TOKEN_SIGNATURE_MINTABLE;
exports.FactoryDeploymentSchema = FactoryDeploymentSchema;
exports.FetchError = FetchError;
exports.FileNameMissingError = FileNameMissingError;
exports.FileOrBufferOrStringSchema = FileOrBufferOrStringSchema;
exports.ForwardRequest = ForwardRequest;
exports.FullPublishMetadataSchemaInput = FullPublishMetadataSchemaInput;
exports.FullPublishMetadataSchemaOutput = FullPublishMetadataSchemaOutput;
exports.FunctionDeprecatedError = FunctionDeprecatedError;
exports.GAS_LIMIT_FOR_DEPLOYER = GAS_LIMIT_FOR_DEPLOYER;
exports.HexColor = HexColor;
exports.InvalidAddressError = InvalidAddressError;
exports.LINK_TOKEN_ADDRESS = LINK_TOKEN_ADDRESS;
exports.ListingNotFoundError = ListingNotFoundError;
exports.MARKETPLACE_CONTRACT_ROLES = MARKETPLACE_CONTRACT_ROLES;
exports.MAX_BPS = MAX_BPS;
exports.MULTIWRAP_CONTRACT_ROLES = MULTIWRAP_CONTRACT_ROLES;
exports.MarketplaceContractDeploy = MarketplaceContractDeploy;
exports.MarketplaceContractInput = MarketplaceContractInput;
exports.MarketplaceContractOutput = MarketplaceContractOutput;
exports.MarketplaceContractSchema = MarketplaceContractSchema;
exports.MarketplaceInitializer = MarketplaceInitializer;
exports.MarketplaceV3Initializer = MarketplaceV3Initializer;
exports.MerkleSchema = MerkleSchema;
exports.MissingOwnerRoleError = MissingOwnerRoleError;
exports.MissingRoleError = MissingRoleError;
exports.MultiwrapContractSchema = MultiwrapContractSchema;
exports.MultiwrapInitializer = MultiwrapInitializer;
exports.NATIVE_TOKENS = NATIVE_TOKENS;
exports.NATIVE_TOKEN_ADDRESS = NATIVE_TOKEN_ADDRESS;
exports.NFTCollectionInitializer = NFTCollectionInitializer;
exports.NFTDropInitializer = NFTDropInitializer;
exports.NFT_BASE_CONTRACT_ROLES = NFT_BASE_CONTRACT_ROLES;
exports.NotEnoughTokensError = NotEnoughTokensError;
exports.NotFoundError = NotFoundError;
exports.OZ_DEFENDER_FORWARDER_ADDRESS = OZ_DEFENDER_FORWARDER_ADDRESS;
exports.PACK_CONTRACT_ROLES = PACK_CONTRACT_ROLES;
exports.PREBUILT_CONTRACTS_APPURI_MAP = PREBUILT_CONTRACTS_APPURI_MAP;
exports.PREBUILT_CONTRACTS_MAP = PREBUILT_CONTRACTS_MAP;
exports.PackContractDeploy = PackContractDeploy;
exports.PackContractInput = PackContractInput;
exports.PackContractOutput = PackContractOutput;
exports.PackContractSchema = PackContractSchema;
exports.PackInitializer = PackInitializer;
exports.PreDeployMetadata = PreDeployMetadata;
exports.PreDeployMetadataFetchedSchema = PreDeployMetadataFetchedSchema;
exports.ProfileSchemaInput = ProfileSchemaInput;
exports.ProfileSchemaOutput = ProfileSchemaOutput;
exports.ProposalOutputSchema = ProposalOutputSchema;
exports.PublishedContractSchema = PublishedContractSchema;
exports.QuantityAboveLimitError = QuantityAboveLimitError;
exports.QuantitySchema = QuantitySchema;
exports.RPCConnectionHandler = RPCConnectionHandler;
exports.RestrictedTransferError = RestrictedTransferError;
exports.RouterTypeInput = RouterTypeInput;
exports.SDKOptionsSchema = SDKOptionsSchema;
exports.SIGNATURE = SIGNATURE;
exports.SUPPORTED_FEATURES = SUPPORTED_FEATURES;
exports.SignatureDropInitializer = SignatureDropInitializer;
exports.SnapshotEntryInput = SnapshotEntryInput;
exports.SnapshotEntryWithProofSchema = SnapshotEntryWithProofSchema;
exports.SnapshotInfoSchema = SnapshotInfoSchema;
exports.SnapshotInputSchema = SnapshotInputSchema;
exports.SnapshotSchema = SnapshotSchema;
exports.SplitInitializer = SplitInitializer;
exports.SplitsContractDeploy = SplitsContractDeploy;
exports.SplitsContractInput = SplitsContractInput;
exports.SplitsContractOutput = SplitsContractOutput;
exports.SplitsContractSchema = SplitsContractSchema;
exports.StaticJsonRpcBatchProvider = StaticJsonRpcBatchProvider;
exports.THIRDWEB_DEPLOYER = THIRDWEB_DEPLOYER;
exports.TOKEN_DROP_CONTRACT_ROLES = TOKEN_DROP_CONTRACT_ROLES;
exports.TokenDropInitializer = TokenDropInitializer;
exports.TokenErc1155ContractDeploy = TokenErc1155ContractDeploy;
exports.TokenErc1155ContractInput = TokenErc1155ContractInput;
exports.TokenErc1155ContractOutput = TokenErc1155ContractOutput;
exports.TokenErc1155ContractSchema = TokenErc1155ContractSchema;
exports.TokenErc20ContractDeploy = TokenErc20ContractDeploy;
exports.TokenErc20ContractInput = TokenErc20ContractInput;
exports.TokenErc20ContractOutput = TokenErc20ContractOutput;
exports.TokenErc20ContractSchema = TokenErc20ContractSchema;
exports.TokenErc721ContractDeploy = TokenErc721ContractDeploy;
exports.TokenErc721ContractInput = TokenErc721ContractInput;
exports.TokenErc721ContractOutput = TokenErc721ContractOutput;
exports.TokenErc721ContractSchema = TokenErc721ContractSchema;
exports.TokenInitializer = TokenInitializer;
exports.TransactionError = TransactionError;
exports.UploadError = UploadError;
exports.VoteContractDeploy = VoteContractDeploy;
exports.VoteContractInput = VoteContractInput;
exports.VoteContractOutput = VoteContractOutput;
exports.VoteContractSchema = VoteContractSchema;
exports.VoteInitializer = VoteInitializer;
exports.VoteSettingsInputSchema = VoteSettingsInputSchema;
exports.VoteSettingsOuputSchema = VoteSettingsOuputSchema;
exports.WrongListingTypeError = WrongListingTypeError;
exports.caches = caches;
exports.computeCreate2FactoryTransaction = computeCreate2FactoryTransaction;
exports.computeDeploymentAddress = computeDeploymentAddress;
exports.computeDeploymentInfo = computeDeploymentInfo;
exports.computeEOAForwarderAddress = computeEOAForwarderAddress;
exports.computeForwarderAddress = computeForwarderAddress;
exports.constructAbiFromBytecode = constructAbiFromBytecode;
exports.createLruCache = createLruCache;
exports.detectFeatures = detectFeatures;
exports.detectFeaturesFromBytecode = detectFeaturesFromBytecode;
exports.encodeConstructorParamsForImplementation = encodeConstructorParamsForImplementation;
exports.estimateTransactionCost = estimateTransactionCost;
exports.extractCommentFromMetadata = extractCommentFromMetadata;
exports.extractConstructorParamsFromAbi = extractConstructorParamsFromAbi;
exports.extractFeatures = extractFeatures;
exports.extractFunctionsFromAbi = extractFunctionsFromAbi;
exports.extractIPFSHashFromBytecode = extractIPFSHashFromBytecode;
exports.extractMinimalProxyImplementationAddress = extractMinimalProxyImplementationAddress;
exports.fetchAbiFromAddress = fetchAbiFromAddress;
exports.fetchAndCacheDeployMetadata = fetchAndCacheDeployMetadata;
exports.fetchContractMetadata = fetchContractMetadata;
exports.fetchContractMetadataFromAddress = fetchContractMetadataFromAddress;
exports.fetchContractMetadataFromBytecode = fetchContractMetadataFromBytecode;
exports.fetchExtendedReleaseMetadata = fetchExtendedReleaseMetadata;
exports.fetchPreDeployMetadata = fetchPreDeployMetadata;
exports.fetchPublishedContractFromPolygon = fetchPublishedContractFromPolygon;
exports.fetchRawPredeployMetadata = fetchRawPredeployMetadata;
exports.fetchSourceFilesFromMetadata = fetchSourceFilesFromMetadata;
exports.formatCompilerMetadata = formatCompilerMetadata;
exports.getAllDetectedExtensions = getAllDetectedExtensions;
exports.getAllDetectedExtensionsFromBytecode = getAllDetectedExtensionsFromBytecode;
exports.getAllDetectedFeatures = getAllDetectedFeatures;
exports.getAndIncrementNonce = getAndIncrementNonce;
exports.getChainIdFromNetwork = getChainIdFromNetwork;
exports.getChainIdOrName = getChainIdOrName;
exports.getChainProvider = getChainProvider;
exports.getCompositeABI = getCompositeABI;
exports.getContractAddressByChainId = getContractAddressByChainId;
exports.getContractMetadataFromCache = getContractMetadataFromCache;
exports.getContractName = getContractName;
exports.getContractPublisherAddress = getContractPublisherAddress;
exports.getContractTypeForRemoteName = getContractTypeForRemoteName;
exports.getCreate2FactoryAddress = getCreate2FactoryAddress;
exports.getCreate2FactoryDeploymentInfo = getCreate2FactoryDeploymentInfo;
exports.getDefaultGasOverrides = getDefaultGasOverrides;
exports.getDynamicFeeData = getDynamicFeeData;
exports.getGasPrice = getGasPrice;
exports.getInitBytecodeWithSalt = getInitBytecodeWithSalt;
exports.getKeylessTxn = getKeylessTxn;
exports.getMultichainRegistryAddress = getMultichainRegistryAddress;
exports.getNativeTokenByChainId = getNativeTokenByChainId;
exports.getPolygonGasPriorityFee = getPolygonGasPriorityFee;
exports.getPrebuiltInfo = getPrebuiltInfo;
exports.getProcessEnv = getProcessEnv;
exports.getProviderFromRpcUrl = getProviderFromRpcUrl;
exports.getRoleHash = getRoleHash;
exports.getRoyaltyEngineV1ByChainId = getRoyaltyEngineV1ByChainId;
exports.getSaltHash = getSaltHash;
exports.getSignerAndProvider = getSignerAndProvider;
exports.getSupportedChains = getSupportedChains;
exports.hasMatchingAbi = hasMatchingAbi;
exports.includesErrorMessage = includesErrorMessage;
exports.isChainConfig = isChainConfig;
exports.isContractDeployed = isContractDeployed;
exports.isDowngradeVersion = isDowngradeVersion;
exports.isEIP155Enforced = isEIP155Enforced;
exports.isExtensionEnabled = isExtensionEnabled;
exports.isFeatureEnabled = isFeatureEnabled;
exports.isIncrementalVersion = isIncrementalVersion;
exports.isNode = isNode;
exports.isProvider = isProvider;
exports.isSigner = isSigner;
exports.joinABIs = joinABIs;
exports.matchesAbiFromBytecode = matchesAbiFromBytecode;
exports.parseRevertReason = parseRevertReason;
exports.resolveAddress = resolveAddress;
exports.resolveContractUriAndBytecode = resolveContractUriAndBytecode;
exports.resolveContractUriFromAddress = resolveContractUriFromAddress;
exports.resolveEns = resolveEns;
exports.resolveImplementation = resolveImplementation;
exports.setSupportedChains = setSupportedChains;
exports.signEIP2612Permit = signEIP2612Permit;
exports.signTypedDataInternal = signTypedDataInternal;
exports.toSemver = toSemver;
