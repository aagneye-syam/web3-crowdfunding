"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var N=require("@walletconnect/core"),k=require("@walletconnect/logger"),oe=require("@walletconnect/types"),s=require("@walletconnect/utils"),ae=require("events"),w=require("@walletconnect/time"),u=require("@walletconnect/jsonrpc-utils");function fe(y){return y&&typeof y=="object"&&"default"in y?y:{default:y}}var qe=fe(ae);const ee="wc",te=2,ie="client",F=`${ee}@${te}:${ie}:`,Y={name:ie,logger:"error",controller:!1,relayUrl:"wss://relay.walletconnect.com"},Pe={session_proposal:"session_proposal",session_update:"session_update",session_extend:"session_extend",session_ping:"session_ping",session_delete:"session_delete",session_expire:"session_expire",session_request:"session_request",session_request_sent:"session_request_sent",session_event:"session_event",proposal_expire:"proposal_expire",session_authenticate:"session_authenticate",session_request_expire:"session_request_expire"},Te={database:":memory:"},se="WALLETCONNECT_DEEPLINK_CHOICE",ve={created:"history_created",updated:"history_updated",deleted:"history_deleted",sync:"history_sync"},Oe="history",Ae="0.3",ce="proposal",Ve=w.THIRTY_DAYS,le="Proposal expired",he="session",V=w.SEVEN_DAYS,pe="engine",q={wc_sessionPropose:{req:{ttl:w.FIVE_MINUTES,prompt:!0,tag:1100},res:{ttl:w.FIVE_MINUTES,prompt:!1,tag:1101}},wc_sessionSettle:{req:{ttl:w.FIVE_MINUTES,prompt:!1,tag:1102},res:{ttl:w.FIVE_MINUTES,prompt:!1,tag:1103}},wc_sessionUpdate:{req:{ttl:w.ONE_DAY,prompt:!1,tag:1104},res:{ttl:w.ONE_DAY,prompt:!1,tag:1105}},wc_sessionExtend:{req:{ttl:w.ONE_DAY,prompt:!1,tag:1106},res:{ttl:w.ONE_DAY,prompt:!1,tag:1107}},wc_sessionRequest:{req:{ttl:w.FIVE_MINUTES,prompt:!0,tag:1108},res:{ttl:w.FIVE_MINUTES,prompt:!1,tag:1109}},wc_sessionEvent:{req:{ttl:w.FIVE_MINUTES,prompt:!0,tag:1110},res:{ttl:w.FIVE_MINUTES,prompt:!1,tag:1111}},wc_sessionDelete:{req:{ttl:w.ONE_DAY,prompt:!1,tag:1112},res:{ttl:w.ONE_DAY,prompt:!1,tag:1113}},wc_sessionPing:{req:{ttl:w.ONE_DAY,prompt:!1,tag:1114},res:{ttl:w.ONE_DAY,prompt:!1,tag:1115}},wc_sessionAuthenticate:{req:{ttl:w.ONE_HOUR,prompt:!0,tag:1116},res:{ttl:w.ONE_HOUR,prompt:!1,tag:1117}}},H={min:w.FIVE_MINUTES,max:w.SEVEN_DAYS},A={idle:"IDLE",active:"ACTIVE"},de="request",ue=["wc_sessionPropose","wc_sessionRequest","wc_authRequest"],ge="wc",De=1.5,Ee="auth",we="authKeys",ye="pairingTopics",me="requests",L=`${ge}@${1.5}:${Ee}:`,U=`${L}:PUB_KEY`;var Ce=Object.defineProperty,xe=Object.defineProperties,be=Object.getOwnPropertyDescriptors,Se=Object.getOwnPropertySymbols,Me=Object.prototype.hasOwnProperty,Le=Object.prototype.propertyIsEnumerable,Ie=(y,o,t)=>o in y?Ce(y,o,{enumerable:!0,configurable:!0,writable:!0,value:t}):y[o]=t,S=(y,o)=>{for(var t in o||(o={}))Me.call(o,t)&&Ie(y,t,o[t]);if(Se)for(var t of Se(o))Le.call(o,t)&&Ie(y,t,o[t]);return y},C=(y,o)=>xe(y,be(o));class Ue extends oe.IEngine{constructor(o){super(o),this.name=pe,this.events=new qe.default,this.initialized=!1,this.requestQueue={state:A.idle,queue:[]},this.sessionRequestQueue={state:A.idle,queue:[]},this.requestQueueDelay=w.ONE_SECOND,this.expectedPairingMethodMap=new Map,this.recentlyDeletedMap=new Map,this.recentlyDeletedLimit=200,this.init=async()=>{this.initialized||(await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.registerPairingEvents(),this.client.core.pairing.register({methods:Object.keys(q)}),this.initialized=!0,setTimeout(()=>{this.sessionRequestQueue.queue=this.getPendingSessionRequests(),this.processSessionRequestQueue()},w.toMiliseconds(this.requestQueueDelay)))},this.connect=async t=>{await this.isInitialized();const e=C(S({},t),{requiredNamespaces:t.requiredNamespaces||{},optionalNamespaces:t.optionalNamespaces||{}});await this.isValidConnect(e);const{pairingTopic:i,requiredNamespaces:r,optionalNamespaces:n,sessionProperties:a,relays:c}=e;let l=i,d,p=!1;try{l&&(p=this.client.core.pairing.pairings.get(l).active)}catch(f){throw this.client.logger.error(`connect() -> pairing.get(${l}) failed`),f}if(!l||!p){const{topic:f,uri:T}=await this.client.core.pairing.create();l=f,d=T}if(!l){const{message:f}=s.getInternalError("NO_MATCHING_KEY",`connect() pairing topic: ${l}`);throw new Error(f)}const g=await this.client.core.crypto.generateKeyPair(),h=q.wc_sessionPropose.req.ttl||w.FIVE_MINUTES,m=s.calcExpiry(h),E=S({requiredNamespaces:r,optionalNamespaces:n,relays:c??[{protocol:N.RELAYER_DEFAULT_PROTOCOL}],proposer:{publicKey:g,metadata:this.client.metadata},expiryTimestamp:m},a&&{sessionProperties:a}),{reject:R,resolve:O,done:I}=s.createDelayedPromise(h,le);this.events.once(s.engineEvent("session_connect"),async({error:f,session:T})=>{if(f)R(f);else if(T){T.self.publicKey=g;const x=C(S({},T),{requiredNamespaces:E.requiredNamespaces,optionalNamespaces:E.optionalNamespaces});await this.client.session.set(T.topic,x),await this.setExpiry(T.topic,T.expiry),l&&await this.client.core.pairing.updateMetadata({topic:l,metadata:T.peer.metadata}),O(x)}});const P=await this.sendRequest({topic:l,method:"wc_sessionPropose",params:E,throwOnFailedPublish:!0});return await this.setProposal(P,S({id:P},E)),{uri:d,approval:I}},this.pair=async t=>{await this.isInitialized();try{return await this.client.core.pairing.pair(t)}catch(e){throw this.client.logger.error("pair() failed"),e}},this.approve=async t=>{await this.isInitialized();try{await this.isValidApprove(t)}catch(I){throw this.client.logger.error("approve() -> isValidApprove() failed"),I}const{id:e,relayProtocol:i,namespaces:r,sessionProperties:n,sessionConfig:a}=t;let c;try{c=this.client.proposal.get(e)}catch(I){throw this.client.logger.error(`approve() -> proposal.get(${e}) failed`),I}let{pairingTopic:l,proposer:d,requiredNamespaces:p,optionalNamespaces:g}=c;l=l||"";const h=await this.client.core.crypto.generateKeyPair(),m=d.publicKey,E=await this.client.core.crypto.generateSharedKey(h,m),R=S(S({relay:{protocol:i??"irn"},namespaces:r,pairingTopic:l,controller:{publicKey:h,metadata:this.client.metadata},expiry:s.calcExpiry(V)},n&&{sessionProperties:n}),a&&{sessionConfig:a});await this.client.core.relayer.subscribe(E);const O=C(S({},R),{topic:E,requiredNamespaces:p,optionalNamespaces:g,pairingTopic:l,acknowledged:!1,self:R.controller,peer:{publicKey:d.publicKey,metadata:d.metadata},controller:h});await this.client.session.set(E,O);try{await this.sendResult({id:e,topic:l,result:{relay:{protocol:i??"irn"},responderPublicKey:h},throwOnFailedPublish:!0}),await this.sendRequest({topic:E,method:"wc_sessionSettle",params:R,throwOnFailedPublish:!0})}catch(I){throw this.client.logger.error(I),this.client.session.delete(E,s.getSdkError("USER_DISCONNECTED")),await this.client.core.relayer.unsubscribe(E),I}return await this.client.core.pairing.updateMetadata({topic:l,metadata:d.metadata}),await this.client.proposal.delete(e,s.getSdkError("USER_DISCONNECTED")),await this.client.core.pairing.activate({topic:l}),await this.setExpiry(E,s.calcExpiry(V)),{topic:E,acknowledged:()=>new Promise(I=>setTimeout(()=>I(this.client.session.get(E)),500))}},this.reject=async t=>{await this.isInitialized();try{await this.isValidReject(t)}catch(n){throw this.client.logger.error("reject() -> isValidReject() failed"),n}const{id:e,reason:i}=t;let r;try{r=this.client.proposal.get(e).pairingTopic}catch(n){throw this.client.logger.error(`reject() -> proposal.get(${e}) failed`),n}r&&(await this.sendError({id:e,topic:r,error:i}),await this.client.proposal.delete(e,s.getSdkError("USER_DISCONNECTED")))},this.update=async t=>{await this.isInitialized();try{await this.isValidUpdate(t)}catch(p){throw this.client.logger.error("update() -> isValidUpdate() failed"),p}const{topic:e,namespaces:i}=t,{done:r,resolve:n,reject:a}=s.createDelayedPromise(),c=u.payloadId(),l=u.getBigIntRpcId().toString(),d=this.client.session.get(e).namespaces;return this.events.once(s.engineEvent("session_update",c),({error:p})=>{p?a(p):n()}),await this.client.session.update(e,{namespaces:i}),this.sendRequest({topic:e,method:"wc_sessionUpdate",params:{namespaces:i},throwOnFailedPublish:!0,clientRpcId:c,relayRpcId:l}).catch(p=>{this.client.logger.error(p),this.client.session.update(e,{namespaces:d}),a(p)}),{acknowledged:r}},this.extend=async t=>{await this.isInitialized();try{await this.isValidExtend(t)}catch(c){throw this.client.logger.error("extend() -> isValidExtend() failed"),c}const{topic:e}=t,i=u.payloadId(),{done:r,resolve:n,reject:a}=s.createDelayedPromise();return this.events.once(s.engineEvent("session_extend",i),({error:c})=>{c?a(c):n()}),await this.setExpiry(e,s.calcExpiry(V)),this.sendRequest({topic:e,method:"wc_sessionExtend",params:{},clientRpcId:i,throwOnFailedPublish:!0}).catch(c=>{a(c)}),{acknowledged:r}},this.request=async t=>{await this.isInitialized();try{await this.isValidRequest(t)}catch(h){throw this.client.logger.error("request() -> isValidRequest() failed"),h}const{chainId:e,request:i,topic:r,expiry:n=q.wc_sessionRequest.req.ttl}=t,a=this.client.session.get(r),c=u.payloadId(),l=u.getBigIntRpcId().toString(),{done:d,resolve:p,reject:g}=s.createDelayedPromise(n,"Request expired. Please try again.");return this.events.once(s.engineEvent("session_request",c),({error:h,result:m})=>{h?g(h):p(m)}),await Promise.all([new Promise(async h=>{await this.sendRequest({clientRpcId:c,relayRpcId:l,topic:r,method:"wc_sessionRequest",params:{request:C(S({},i),{expiryTimestamp:s.calcExpiry(n)}),chainId:e},expiry:n,throwOnFailedPublish:!0}).catch(m=>g(m)),this.client.events.emit("session_request_sent",{topic:r,request:i,chainId:e,id:c}),h()}),new Promise(async h=>{var m;if(!((m=a.sessionConfig)!=null&&m.disableDeepLink)){const E=await s.getDeepLink(this.client.core.storage,se);s.handleDeeplinkRedirect({id:c,topic:r,wcDeepLink:E})}h()}),d()]).then(h=>h[2])},this.respond=async t=>{await this.isInitialized(),await this.isValidRespond(t);const{topic:e,response:i}=t,{id:r}=i;u.isJsonRpcResult(i)?await this.sendResult({id:r,topic:e,result:i.result,throwOnFailedPublish:!0}):u.isJsonRpcError(i)&&await this.sendError({id:r,topic:e,error:i.error}),this.cleanupAfterResponse(t)},this.ping=async t=>{await this.isInitialized();try{await this.isValidPing(t)}catch(i){throw this.client.logger.error("ping() -> isValidPing() failed"),i}const{topic:e}=t;if(this.client.session.keys.includes(e)){const i=u.payloadId(),r=u.getBigIntRpcId().toString(),{done:n,resolve:a,reject:c}=s.createDelayedPromise();this.events.once(s.engineEvent("session_ping",i),({error:l})=>{l?c(l):a()}),await Promise.all([this.sendRequest({topic:e,method:"wc_sessionPing",params:{},throwOnFailedPublish:!0,clientRpcId:i,relayRpcId:r}),n()])}else this.client.core.pairing.pairings.keys.includes(e)&&await this.client.core.pairing.ping({topic:e})},this.emit=async t=>{await this.isInitialized(),await this.isValidEmit(t);const{topic:e,event:i,chainId:r}=t,n=u.getBigIntRpcId().toString();await this.sendRequest({topic:e,method:"wc_sessionEvent",params:{event:i,chainId:r},throwOnFailedPublish:!0,relayRpcId:n})},this.disconnect=async t=>{await this.isInitialized(),await this.isValidDisconnect(t);const{topic:e}=t;if(this.client.session.keys.includes(e))await this.sendRequest({topic:e,method:"wc_sessionDelete",params:s.getSdkError("USER_DISCONNECTED"),throwOnFailedPublish:!0}),await this.deleteSession({topic:e,emitEvent:!1});else if(this.client.core.pairing.pairings.keys.includes(e))await this.client.core.pairing.disconnect({topic:e});else{const{message:i}=s.getInternalError("MISMATCHED_TOPIC",`Session or pairing topic not found: ${e}`);throw new Error(i)}},this.find=t=>(this.isInitialized(),this.client.session.getAll().filter(e=>s.isSessionCompatible(e,t))),this.getPendingSessionRequests=()=>this.client.pendingRequest.getAll(),this.authenticate=async t=>{this.isInitialized(),this.isValidAuthenticate(t);const{chains:e,statement:i="",uri:r,domain:n,nonce:a,type:c,exp:l,nbf:d,methods:p=[]}=t,g=[...t.resources||[]],{topic:h,uri:m}=await this.client.core.pairing.create({methods:["wc_sessionAuthenticate"]});this.client.logger.info({message:"Generated new pairing",pairing:{topic:h,uri:m}});const E=await this.client.core.crypto.generateKeyPair(),R=s.hashKey(E);if(await Promise.all([this.client.auth.authKeys.set(U,{responseTopic:R,publicKey:E}),this.client.auth.pairingTopics.set(R,{topic:R,pairingTopic:h})]),await this.client.core.relayer.subscribe(R),this.client.logger.info(`sending request to new pairing topic: ${h}`),p.length>0){const{namespace:v}=s.parseChainId(e[0]);let _=s.createEncodedRecap(v,"request",p);s.getRecapFromResources(g)&&(_=s.mergeEncodedRecaps(_,g.pop())),g.push(_)}const O=s.calcExpiry(q.wc_sessionPropose.req.ttl),I={authPayload:{type:c??"caip122",chains:e,statement:i,aud:r,domain:n,version:"1",nonce:a,iat:new Date().toISOString(),exp:l,nbf:d,resources:g},requester:{publicKey:E,metadata:this.client.metadata},expiryTimestamp:O},P={eip155:{chains:e,methods:[...new Set(["personal_sign",...p])],events:["chainChanged","accountsChanged"]}},f={requiredNamespaces:{},optionalNamespaces:P,relays:[{protocol:"irn"}],proposer:{publicKey:E,metadata:this.client.metadata},expiryTimestamp:O},{done:T,resolve:x,reject:Q}=s.createDelayedPromise(q.wc_sessionAuthenticate.req.ttl,"Request expired"),$=async({error:v,session:_})=>{if(this.events.off(s.engineEvent("session_request",D),X),v)Q(v);else if(_){_.self.publicKey=E,await this.client.session.set(_.topic,_),await this.setExpiry(_.topic,_.expiry),h&&await this.client.core.pairing.updateMetadata({topic:h,metadata:_.peer.metadata});const b=this.client.session.get(_.topic);x({session:b})}},X=async v=>{if(v.error){const M=s.getSdkError("WC_METHOD_UNSUPPORTED","wc_sessionAuthenticate");return v.error.code===M.code?void 0:(this.events.off(s.engineEvent("session_connect"),$),Q(v.error.message))}this.events.off(s.engineEvent("session_connect"),$);const{cacaos:_,responder:b}=v.result,z=[],re=[];for(const M of _){await s.validateSignedCacao({cacao:M,projectId:this.client.core.projectId})||(this.client.logger.error(M,"Signature verification failed"),Q(s.getSdkError("SESSION_SETTLEMENT_FAILED","Signature verification failed")));const{p:B}=M,W=s.getRecapFromResources(B.resources),ne=[s.getNamespacedDidChainId(B.iss)],Re=s.getDidAddress(B.iss);if(W){const Z=s.getMethodsFromRecap(W),Ne=s.getChainsFromRecap(W);z.push(...Z),ne.push(...Ne)}for(const Z of ne)re.push(`${Z}:${Re}`)}const G=await this.client.core.crypto.generateSharedKey(E,b.publicKey);let K;z.length>0&&(K={topic:G,acknowledged:!0,self:{publicKey:E,metadata:this.client.metadata},peer:b,controller:b.publicKey,expiry:s.calcExpiry(V),requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:h,namespaces:s.buildNamespacesFromAuth([...new Set(z)],[...new Set(re)])},await this.client.core.relayer.subscribe(G),await this.client.session.set(G,K),K=this.client.session.get(G)),x({auths:_,session:K})},D=u.payloadId(),J=u.payloadId();this.events.once(s.engineEvent("session_connect"),$),this.events.once(s.engineEvent("session_request",D),X);try{await Promise.all([this.sendRequest({topic:h,method:"wc_sessionAuthenticate",params:I,expiry:t.expiry,throwOnFailedPublish:!0,clientRpcId:D}),this.sendRequest({topic:h,method:"wc_sessionPropose",params:f,expiry:q.wc_sessionPropose.req.ttl,throwOnFailedPublish:!0,clientRpcId:J})])}catch(v){throw this.events.off(s.engineEvent("session_connect"),$),this.events.off(s.engineEvent("session_request",D),X),v}return await this.setProposal(J,S({id:J},f)),await this.client.auth.requests.set(D,{authPayload:I.authPayload,requester:I.requester,expiryTimestamp:O,id:D,pairingTopic:h,verifyContext:{}}),{uri:m,response:T}},this.approveSessionAuthenticate=async t=>{this.isInitialized();const{id:e,auths:i}=t,r=this.getPendingAuthRequest(e);if(!r)throw new Error(`Could not find pending auth request with id ${e}`);const n=r.requester.publicKey,a=await this.client.core.crypto.generateKeyPair(),c=s.hashKey(n),l={type:s.TYPE_1,receiverPublicKey:n,senderPublicKey:a},d=[],p=[];for(const m of i){if(!await s.validateSignedCacao({cacao:m,projectId:this.client.core.projectId})){const P=s.getSdkError("SESSION_SETTLEMENT_FAILED","Signature verification failed");throw await this.sendError({id:e,topic:c,error:P,encodeOpts:l}),new Error(P.message)}const{p:E}=m,R=s.getRecapFromResources(E.resources),O=[s.getNamespacedDidChainId(E.iss)],I=s.getDidAddress(E.iss);if(R){const P=s.getMethodsFromRecap(R),f=s.getChainsFromRecap(R);d.push(...P),O.push(...f)}for(const P of O)p.push(`${P}:${I}`)}const g=await this.client.core.crypto.generateSharedKey(a,n);let h;return d?.length>0&&(h={topic:g,acknowledged:!0,self:{publicKey:a,metadata:this.client.metadata},peer:{publicKey:n,metadata:r.requester.metadata},controller:n,expiry:s.calcExpiry(V),authentication:i,requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:"",namespaces:s.buildNamespacesFromAuth([...new Set(d)],[...new Set(p)])},await this.client.core.relayer.subscribe(g),await this.client.session.set(g,h)),await this.sendResult({topic:c,id:e,result:{cacaos:i,responder:{publicKey:a,metadata:this.client.metadata}},encodeOpts:l,throwOnFailedPublish:!0}),await this.client.auth.requests.delete(e,{message:"fullfilled",code:0}),await this.client.core.pairing.activate({topic:r.pairingTopic}),{session:h}},this.rejectSessionAuthenticate=async t=>{await this.isInitialized();const{id:e,reason:i}=t,r=this.getPendingAuthRequest(e);if(!r)throw new Error(`Could not find pending auth request with id ${e}`);const n=r.requester.publicKey,a=await this.client.core.crypto.generateKeyPair(),c=s.hashKey(n),l={type:s.TYPE_1,receiverPublicKey:n,senderPublicKey:a};await this.sendError({id:e,topic:c,error:i,encodeOpts:l}),await this.client.auth.requests.delete(e,{message:"rejected",code:0}),await this.client.proposal.delete(e,s.getSdkError("USER_DISCONNECTED"))},this.formatAuthMessage=t=>{this.isInitialized();const{request:e,iss:i}=t;return s.formatMessage(e,i)},this.cleanupDuplicatePairings=async t=>{if(t.pairingTopic)try{const e=this.client.core.pairing.pairings.get(t.pairingTopic),i=this.client.core.pairing.pairings.getAll().filter(r=>{var n,a;return((n=r.peerMetadata)==null?void 0:n.url)&&((a=r.peerMetadata)==null?void 0:a.url)===t.peer.metadata.url&&r.topic&&r.topic!==e.topic});if(i.length===0)return;this.client.logger.info(`Cleaning up ${i.length} duplicate pairing(s)`),await Promise.all(i.map(r=>this.client.core.pairing.disconnect({topic:r.topic}))),this.client.logger.info("Duplicate pairings clean up finished")}catch(e){this.client.logger.error(e)}},this.deleteSession=async t=>{const{topic:e,expirerHasDeleted:i=!1,emitEvent:r=!0,id:n=0}=t,{self:a}=this.client.session.get(e);await this.client.core.relayer.unsubscribe(e),await this.client.session.delete(e,s.getSdkError("USER_DISCONNECTED")),this.addToRecentlyDeleted(e,"session"),this.client.core.crypto.keychain.has(a.publicKey)&&await this.client.core.crypto.deleteKeyPair(a.publicKey),this.client.core.crypto.keychain.has(e)&&await this.client.core.crypto.deleteSymKey(e),i||this.client.core.expirer.del(e),this.client.core.storage.removeItem(se).catch(c=>this.client.logger.warn(c)),this.getPendingSessionRequests().forEach(c=>{c.topic===e&&this.deletePendingSessionRequest(c.id,s.getSdkError("USER_DISCONNECTED"))}),r&&this.client.events.emit("session_delete",{id:n,topic:e})},this.deleteProposal=async(t,e)=>{await Promise.all([this.client.proposal.delete(t,s.getSdkError("USER_DISCONNECTED")),e?Promise.resolve():this.client.core.expirer.del(t)]),this.addToRecentlyDeleted(t,"proposal")},this.deletePendingSessionRequest=async(t,e,i=!1)=>{await Promise.all([this.client.pendingRequest.delete(t,e),i?Promise.resolve():this.client.core.expirer.del(t)]),this.addToRecentlyDeleted(t,"request"),this.sessionRequestQueue.queue=this.sessionRequestQueue.queue.filter(r=>r.id!==t),i&&(this.sessionRequestQueue.state=A.idle,this.client.events.emit("session_request_expire",{id:t}))},this.setExpiry=async(t,e)=>{this.client.session.keys.includes(t)&&await this.client.session.update(t,{expiry:e}),this.client.core.expirer.set(t,e)},this.setProposal=async(t,e)=>{await this.client.proposal.set(t,e),this.client.core.expirer.set(t,s.calcExpiry(q.wc_sessionPropose.req.ttl))},this.setPendingSessionRequest=async t=>{const{id:e,topic:i,params:r,verifyContext:n}=t,a=r.request.expiryTimestamp||s.calcExpiry(q.wc_sessionRequest.req.ttl);await this.client.pendingRequest.set(e,{id:e,topic:i,params:r,verifyContext:n}),a&&this.client.core.expirer.set(e,a)},this.sendRequest=async t=>{const{topic:e,method:i,params:r,expiry:n,relayRpcId:a,clientRpcId:c,throwOnFailedPublish:l}=t,d=u.formatJsonRpcRequest(i,r,c);if(s.isBrowser()&&ue.includes(i)){const h=s.hashMessage(JSON.stringify(d));this.client.core.verify.register({attestationId:h})}let p;try{p=await this.client.core.crypto.encode(e,d)}catch(h){throw await this.cleanup(),this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${e} failed`),h}const g=q[i].req;return n&&(g.ttl=n),a&&(g.id=a),this.client.core.history.set(e,d),l?(g.internal=C(S({},g.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(e,p,g)):this.client.core.relayer.publish(e,p,g).catch(h=>this.client.logger.error(h)),d.id},this.sendResult=async t=>{const{id:e,topic:i,result:r,throwOnFailedPublish:n,encodeOpts:a}=t,c=u.formatJsonRpcResult(e,r);let l;try{l=await this.client.core.crypto.encode(i,c,a)}catch(g){throw await this.cleanup(),this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${i} failed`),g}let d;try{d=await this.client.core.history.get(i,e)}catch(g){throw this.client.logger.error(`sendResult() -> history.get(${i}, ${e}) failed`),g}const p=q[d.request.method].res;n?(p.internal=C(S({},p.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(i,l,p)):this.client.core.relayer.publish(i,l,p).catch(g=>this.client.logger.error(g)),await this.client.core.history.resolve(c)},this.sendError=async t=>{const{id:e,topic:i,error:r,encodeOpts:n}=t,a=u.formatJsonRpcError(e,r);let c;try{c=await this.client.core.crypto.encode(i,a,n)}catch(p){throw await this.cleanup(),this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${i} failed`),p}let l;try{l=await this.client.core.history.get(i,e)}catch(p){throw this.client.logger.error(`sendError() -> history.get(${i}, ${e}) failed`),p}const d=q[l.request.method].res;this.client.core.relayer.publish(i,c,d),await this.client.core.history.resolve(a)},this.cleanup=async()=>{const t=[],e=[];this.client.session.getAll().forEach(i=>{let r=!1;s.isExpired(i.expiry)&&(r=!0),this.client.core.crypto.keychain.has(i.topic)||(r=!0),r&&t.push(i.topic)}),this.client.proposal.getAll().forEach(i=>{s.isExpired(i.expiryTimestamp)&&e.push(i.id)}),await Promise.all([...t.map(i=>this.deleteSession({topic:i})),...e.map(i=>this.deleteProposal(i))])},this.onRelayEventRequest=async t=>{this.requestQueue.queue.push(t),await this.processRequestsQueue()},this.processRequestsQueue=async()=>{if(this.requestQueue.state===A.active){this.client.logger.info("Request queue already active, skipping...");return}for(this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`);this.requestQueue.queue.length>0;){this.requestQueue.state=A.active;const t=this.requestQueue.queue.shift();if(t)try{this.processRequest(t),await new Promise(e=>setTimeout(e,300))}catch(e){this.client.logger.warn(e)}}this.requestQueue.state=A.idle},this.processRequest=t=>{const{topic:e,payload:i}=t,r=i.method;if(!this.shouldIgnorePairingRequest({topic:e,requestMethod:r}))switch(r){case"wc_sessionPropose":return this.onSessionProposeRequest(e,i);case"wc_sessionSettle":return this.onSessionSettleRequest(e,i);case"wc_sessionUpdate":return this.onSessionUpdateRequest(e,i);case"wc_sessionExtend":return this.onSessionExtendRequest(e,i);case"wc_sessionPing":return this.onSessionPingRequest(e,i);case"wc_sessionDelete":return this.onSessionDeleteRequest(e,i);case"wc_sessionRequest":return this.onSessionRequest(e,i);case"wc_sessionEvent":return this.onSessionEventRequest(e,i);case"wc_sessionAuthenticate":return this.onSessionAuthenticateRequest(e,i);default:return this.client.logger.info(`Unsupported request method ${r}`)}},this.onRelayEventResponse=async t=>{const{topic:e,payload:i}=t,r=(await this.client.core.history.get(e,i.id)).request.method;switch(r){case"wc_sessionPropose":return this.onSessionProposeResponse(e,i);case"wc_sessionSettle":return this.onSessionSettleResponse(e,i);case"wc_sessionUpdate":return this.onSessionUpdateResponse(e,i);case"wc_sessionExtend":return this.onSessionExtendResponse(e,i);case"wc_sessionPing":return this.onSessionPingResponse(e,i);case"wc_sessionRequest":return this.onSessionRequestResponse(e,i);case"wc_sessionAuthenticate":return this.onSessionAuthenticateResponse(e,i);default:return this.client.logger.info(`Unsupported response method ${r}`)}},this.onRelayEventUnknownPayload=t=>{const{topic:e}=t,{message:i}=s.getInternalError("MISSING_OR_INVALID",`Decoded payload on topic ${e} is not identifiable as a JSON-RPC request or a response.`);throw new Error(i)},this.shouldIgnorePairingRequest=t=>{const{topic:e,requestMethod:i}=t,r=this.expectedPairingMethodMap.get(e);return!r||r.includes(i)?!1:!!(r.includes("wc_sessionAuthenticate")&&this.client.events.listenerCount("session_authenticate")>0)},this.onSessionProposeRequest=async(t,e)=>{const{params:i,id:r}=e;try{this.isValidConnect(S({},e.params));const n=i.expiryTimestamp||s.calcExpiry(q.wc_sessionPropose.req.ttl),a=S({id:r,pairingTopic:t,expiryTimestamp:n},i);await this.setProposal(r,a);const c=s.hashMessage(JSON.stringify(e)),l=await this.getVerifyContext(c,a.proposer.metadata);this.client.events.emit("session_proposal",{id:r,params:a,verifyContext:l})}catch(n){await this.sendError({id:r,topic:t,error:n}),this.client.logger.error(n)}},this.onSessionProposeResponse=async(t,e)=>{const{id:i}=e;if(u.isJsonRpcResult(e)){const{result:r}=e;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",result:r});const n=this.client.proposal.get(i);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",proposal:n});const a=n.proposer.publicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",selfPublicKey:a});const c=r.responderPublicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",peerPublicKey:c});const l=await this.client.core.crypto.generateSharedKey(a,c);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",sessionTopic:l});const d=await this.client.core.relayer.subscribe(l);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",subscriptionId:d}),await this.client.core.pairing.activate({topic:t})}else if(u.isJsonRpcError(e)){await this.client.proposal.delete(i,s.getSdkError("USER_DISCONNECTED"));const r=s.engineEvent("session_connect");if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners, 954`);this.events.emit(s.engineEvent("session_connect"),{error:e.error})}},this.onSessionSettleRequest=async(t,e)=>{const{id:i,params:r}=e;try{this.isValidSessionSettleRequest(r);const{relay:n,controller:a,expiry:c,namespaces:l,sessionProperties:d,pairingTopic:p,sessionConfig:g}=e.params,h=S(S({topic:t,relay:n,expiry:c,namespaces:l,acknowledged:!0,pairingTopic:p,requiredNamespaces:{},optionalNamespaces:{},controller:a.publicKey,self:{publicKey:"",metadata:this.client.metadata},peer:{publicKey:a.publicKey,metadata:a.metadata}},d&&{sessionProperties:d}),g&&{sessionConfig:g});await this.sendResult({id:e.id,topic:t,result:!0,throwOnFailedPublish:!0});const m=s.engineEvent("session_connect");if(this.events.listenerCount(m)===0)throw new Error(`emitting ${m} without any listeners 997`);this.events.emit(s.engineEvent("session_connect"),{session:h}),this.cleanupDuplicatePairings(h)}catch(n){await this.sendError({id:i,topic:t,error:n}),this.client.logger.error(n)}},this.onSessionSettleResponse=async(t,e)=>{const{id:i}=e;u.isJsonRpcResult(e)?(await this.client.session.update(t,{acknowledged:!0}),this.events.emit(s.engineEvent("session_approve",i),{})):u.isJsonRpcError(e)&&(await this.client.session.delete(t,s.getSdkError("USER_DISCONNECTED")),this.events.emit(s.engineEvent("session_approve",i),{error:e.error}))},this.onSessionUpdateRequest=async(t,e)=>{const{params:i,id:r}=e;try{const n=`${t}_session_update`,a=s.MemoryStore.get(n);if(a&&this.isRequestOutOfSync(a,r)){this.client.logger.info(`Discarding out of sync request - ${r}`),this.sendError({id:r,topic:t,error:s.getSdkError("INVALID_UPDATE_REQUEST")});return}this.isValidUpdate(S({topic:t},i));try{s.MemoryStore.set(n,r),await this.client.session.update(t,{namespaces:i.namespaces}),await this.sendResult({id:r,topic:t,result:!0,throwOnFailedPublish:!0})}catch(c){throw s.MemoryStore.delete(n),c}this.client.events.emit("session_update",{id:r,topic:t,params:i})}catch(n){await this.sendError({id:r,topic:t,error:n}),this.client.logger.error(n)}},this.isRequestOutOfSync=(t,e)=>parseInt(e.toString().slice(0,-3))<=parseInt(t.toString().slice(0,-3)),this.onSessionUpdateResponse=(t,e)=>{const{id:i}=e,r=s.engineEvent("session_update",i);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);u.isJsonRpcResult(e)?this.events.emit(s.engineEvent("session_update",i),{}):u.isJsonRpcError(e)&&this.events.emit(s.engineEvent("session_update",i),{error:e.error})},this.onSessionExtendRequest=async(t,e)=>{const{id:i}=e;try{this.isValidExtend({topic:t}),await this.setExpiry(t,s.calcExpiry(V)),await this.sendResult({id:i,topic:t,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_extend",{id:i,topic:t})}catch(r){await this.sendError({id:i,topic:t,error:r}),this.client.logger.error(r)}},this.onSessionExtendResponse=(t,e)=>{const{id:i}=e,r=s.engineEvent("session_extend",i);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);u.isJsonRpcResult(e)?this.events.emit(s.engineEvent("session_extend",i),{}):u.isJsonRpcError(e)&&this.events.emit(s.engineEvent("session_extend",i),{error:e.error})},this.onSessionPingRequest=async(t,e)=>{const{id:i}=e;try{this.isValidPing({topic:t}),await this.sendResult({id:i,topic:t,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_ping",{id:i,topic:t})}catch(r){await this.sendError({id:i,topic:t,error:r}),this.client.logger.error(r)}},this.onSessionPingResponse=(t,e)=>{const{id:i}=e,r=s.engineEvent("session_ping",i);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);setTimeout(()=>{u.isJsonRpcResult(e)?this.events.emit(s.engineEvent("session_ping",i),{}):u.isJsonRpcError(e)&&this.events.emit(s.engineEvent("session_ping",i),{error:e.error})},500)},this.onSessionDeleteRequest=async(t,e)=>{const{id:i}=e;try{this.isValidDisconnect({topic:t,reason:e.params}),await Promise.all([new Promise(r=>{this.client.core.relayer.once(N.RELAYER_EVENTS.publish,async()=>{r(await this.deleteSession({topic:t,id:i}))})}),this.sendResult({id:i,topic:t,result:!0,throwOnFailedPublish:!0}),this.cleanupPendingSentRequestsForTopic({topic:t,error:s.getSdkError("USER_DISCONNECTED")})])}catch(r){this.client.logger.error(r)}},this.onSessionRequest=async(t,e)=>{const{id:i,params:r}=e;try{await this.isValidRequest(S({topic:t},r));const n=s.hashMessage(JSON.stringify(u.formatJsonRpcRequest("wc_sessionRequest",r,i))),a=this.client.session.get(t),c=await this.getVerifyContext(n,a.peer.metadata),l={id:i,topic:t,params:r,verifyContext:c};await this.setPendingSessionRequest(l),this.addSessionRequestToSessionRequestQueue(l),this.processSessionRequestQueue()}catch(n){await this.sendError({id:i,topic:t,error:n}),this.client.logger.error(n)}},this.onSessionRequestResponse=(t,e)=>{const{id:i}=e,r=s.engineEvent("session_request",i);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);u.isJsonRpcResult(e)?this.events.emit(s.engineEvent("session_request",i),{result:e.result}):u.isJsonRpcError(e)&&this.events.emit(s.engineEvent("session_request",i),{error:e.error})},this.onSessionEventRequest=async(t,e)=>{const{id:i,params:r}=e;try{const n=`${t}_session_event_${r.event.name}`,a=s.MemoryStore.get(n);if(a&&this.isRequestOutOfSync(a,i)){this.client.logger.info(`Discarding out of sync request - ${i}`);return}this.isValidEmit(S({topic:t},r)),this.client.events.emit("session_event",{id:i,topic:t,params:r}),s.MemoryStore.set(n,i)}catch(n){await this.sendError({id:i,topic:t,error:n}),this.client.logger.error(n)}},this.onSessionAuthenticateResponse=(t,e)=>{const{id:i}=e;this.client.logger.trace({type:"method",method:"onSessionAuthenticateResponse",topic:t,payload:e}),u.isJsonRpcResult(e)?this.events.emit(s.engineEvent("session_request",i),{result:e.result}):u.isJsonRpcError(e)&&this.events.emit(s.engineEvent("session_request",i),{error:e.error})},this.onSessionAuthenticateRequest=async(t,e)=>{const{requester:i,authPayload:r,expiryTimestamp:n}=e.params,a=s.hashMessage(JSON.stringify(e)),c=await this.getVerifyContext(a,this.client.metadata),l={requester:i,pairingTopic:t,id:e.id,authPayload:r,verifyContext:c,expiryTimestamp:n};await this.client.auth.requests.set(e.id,l),this.client.events.emit("session_authenticate",{topic:t,params:e.params,id:e.id})},this.addSessionRequestToSessionRequestQueue=t=>{this.sessionRequestQueue.queue.push(t)},this.cleanupAfterResponse=t=>{this.deletePendingSessionRequest(t.response.id,{message:"fulfilled",code:0}),setTimeout(()=>{this.sessionRequestQueue.state=A.idle,this.processSessionRequestQueue()},w.toMiliseconds(this.requestQueueDelay))},this.cleanupPendingSentRequestsForTopic=({topic:t,error:e})=>{const i=this.client.core.history.pending;i.length>0&&i.filter(r=>r.topic===t&&r.request.method==="wc_sessionRequest").forEach(r=>{const n=r.request.id,a=s.engineEvent("session_request",n);if(this.events.listenerCount(a)===0)throw new Error(`emitting ${a} without any listeners`);this.events.emit(s.engineEvent("session_request",r.request.id),{error:e})})},this.processSessionRequestQueue=()=>{if(this.sessionRequestQueue.state===A.active){this.client.logger.info("session request queue is already active.");return}const t=this.sessionRequestQueue.queue[0];if(!t){this.client.logger.info("session request queue is empty.");return}try{this.sessionRequestQueue.state=A.active,this.client.events.emit("session_request",t)}catch(e){this.client.logger.error(e)}},this.onPairingCreated=t=>{if(t.methods&&this.expectedPairingMethodMap.set(t.topic,t.methods),t.active)return;const e=this.client.proposal.getAll().find(i=>i.pairingTopic===t.topic);e&&this.onSessionProposeRequest(t.topic,u.formatJsonRpcRequest("wc_sessionPropose",{requiredNamespaces:e.requiredNamespaces,optionalNamespaces:e.optionalNamespaces,relays:e.relays,proposer:e.proposer,sessionProperties:e.sessionProperties},e.id))},this.isValidConnect=async t=>{if(!s.isValidParams(t)){const{message:c}=s.getInternalError("MISSING_OR_INVALID",`connect() params: ${JSON.stringify(t)}`);throw new Error(c)}const{pairingTopic:e,requiredNamespaces:i,optionalNamespaces:r,sessionProperties:n,relays:a}=t;if(s.isUndefined(e)||await this.isValidPairingTopic(e),!s.isValidRelays(a,!0)){const{message:c}=s.getInternalError("MISSING_OR_INVALID",`connect() relays: ${a}`);throw new Error(c)}!s.isUndefined(i)&&s.isValidObject(i)!==0&&this.validateNamespaces(i,"requiredNamespaces"),!s.isUndefined(r)&&s.isValidObject(r)!==0&&this.validateNamespaces(r,"optionalNamespaces"),s.isUndefined(n)||this.validateSessionProps(n,"sessionProperties")},this.validateNamespaces=(t,e)=>{const i=s.isValidRequiredNamespaces(t,"connect()",e);if(i)throw new Error(i.message)},this.isValidApprove=async t=>{if(!s.isValidParams(t))throw new Error(s.getInternalError("MISSING_OR_INVALID",`approve() params: ${t}`).message);const{id:e,namespaces:i,relayProtocol:r,sessionProperties:n}=t;this.checkRecentlyDeleted(e),await this.isValidProposalId(e);const a=this.client.proposal.get(e),c=s.isValidNamespaces(i,"approve()");if(c)throw new Error(c.message);const l=s.isConformingNamespaces(a.requiredNamespaces,i,"approve()");if(l)throw new Error(l.message);if(!s.isValidString(r,!0)){const{message:d}=s.getInternalError("MISSING_OR_INVALID",`approve() relayProtocol: ${r}`);throw new Error(d)}s.isUndefined(n)||this.validateSessionProps(n,"sessionProperties")},this.isValidReject=async t=>{if(!s.isValidParams(t)){const{message:r}=s.getInternalError("MISSING_OR_INVALID",`reject() params: ${t}`);throw new Error(r)}const{id:e,reason:i}=t;if(this.checkRecentlyDeleted(e),await this.isValidProposalId(e),!s.isValidErrorReason(i)){const{message:r}=s.getInternalError("MISSING_OR_INVALID",`reject() reason: ${JSON.stringify(i)}`);throw new Error(r)}},this.isValidSessionSettleRequest=t=>{if(!s.isValidParams(t)){const{message:l}=s.getInternalError("MISSING_OR_INVALID",`onSessionSettleRequest() params: ${t}`);throw new Error(l)}const{relay:e,controller:i,namespaces:r,expiry:n}=t;if(!s.isValidRelay(e)){const{message:l}=s.getInternalError("MISSING_OR_INVALID","onSessionSettleRequest() relay protocol should be a string");throw new Error(l)}const a=s.isValidController(i,"onSessionSettleRequest()");if(a)throw new Error(a.message);const c=s.isValidNamespaces(r,"onSessionSettleRequest()");if(c)throw new Error(c.message);if(s.isExpired(n)){const{message:l}=s.getInternalError("EXPIRED","onSessionSettleRequest()");throw new Error(l)}},this.isValidUpdate=async t=>{if(!s.isValidParams(t)){const{message:c}=s.getInternalError("MISSING_OR_INVALID",`update() params: ${t}`);throw new Error(c)}const{topic:e,namespaces:i}=t;this.checkRecentlyDeleted(e),await this.isValidSessionTopic(e);const r=this.client.session.get(e),n=s.isValidNamespaces(i,"update()");if(n)throw new Error(n.message);const a=s.isConformingNamespaces(r.requiredNamespaces,i,"update()");if(a)throw new Error(a.message)},this.isValidExtend=async t=>{if(!s.isValidParams(t)){const{message:i}=s.getInternalError("MISSING_OR_INVALID",`extend() params: ${t}`);throw new Error(i)}const{topic:e}=t;this.checkRecentlyDeleted(e),await this.isValidSessionTopic(e)},this.isValidRequest=async t=>{if(!s.isValidParams(t)){const{message:c}=s.getInternalError("MISSING_OR_INVALID",`request() params: ${t}`);throw new Error(c)}const{topic:e,request:i,chainId:r,expiry:n}=t;this.checkRecentlyDeleted(e),await this.isValidSessionTopic(e);const{namespaces:a}=this.client.session.get(e);if(!s.isValidNamespacesChainId(a,r)){const{message:c}=s.getInternalError("MISSING_OR_INVALID",`request() chainId: ${r}`);throw new Error(c)}if(!s.isValidRequest(i)){const{message:c}=s.getInternalError("MISSING_OR_INVALID",`request() ${JSON.stringify(i)}`);throw new Error(c)}if(!s.isValidNamespacesRequest(a,r,i.method)){const{message:c}=s.getInternalError("MISSING_OR_INVALID",`request() method: ${i.method}`);throw new Error(c)}if(n&&!s.isValidRequestExpiry(n,H)){const{message:c}=s.getInternalError("MISSING_OR_INVALID",`request() expiry: ${n}. Expiry must be a number (in seconds) between ${H.min} and ${H.max}`);throw new Error(c)}},this.isValidRespond=async t=>{var e;if(!s.isValidParams(t)){const{message:n}=s.getInternalError("MISSING_OR_INVALID",`respond() params: ${t}`);throw new Error(n)}const{topic:i,response:r}=t;try{await this.isValidSessionTopic(i)}catch(n){throw(e=t?.response)!=null&&e.id&&this.cleanupAfterResponse(t),n}if(!s.isValidResponse(r)){const{message:n}=s.getInternalError("MISSING_OR_INVALID",`respond() response: ${JSON.stringify(r)}`);throw new Error(n)}},this.isValidPing=async t=>{if(!s.isValidParams(t)){const{message:i}=s.getInternalError("MISSING_OR_INVALID",`ping() params: ${t}`);throw new Error(i)}const{topic:e}=t;await this.isValidSessionOrPairingTopic(e)},this.isValidEmit=async t=>{if(!s.isValidParams(t)){const{message:a}=s.getInternalError("MISSING_OR_INVALID",`emit() params: ${t}`);throw new Error(a)}const{topic:e,event:i,chainId:r}=t;await this.isValidSessionTopic(e);const{namespaces:n}=this.client.session.get(e);if(!s.isValidNamespacesChainId(n,r)){const{message:a}=s.getInternalError("MISSING_OR_INVALID",`emit() chainId: ${r}`);throw new Error(a)}if(!s.isValidEvent(i)){const{message:a}=s.getInternalError("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(i)}`);throw new Error(a)}if(!s.isValidNamespacesEvent(n,r,i.name)){const{message:a}=s.getInternalError("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(i)}`);throw new Error(a)}},this.isValidDisconnect=async t=>{if(!s.isValidParams(t)){const{message:i}=s.getInternalError("MISSING_OR_INVALID",`disconnect() params: ${t}`);throw new Error(i)}const{topic:e}=t;await this.isValidSessionOrPairingTopic(e)},this.isValidAuthenticate=t=>{const{chains:e,uri:i,domain:r,nonce:n}=t;if(!Array.isArray(e)||e.length===0)throw new Error("chains is required and must be a non-empty array");if(!s.isValidString(i,!1))throw new Error("uri is required parameter");if(!s.isValidString(r,!1))throw new Error("domain is required parameter");if(!s.isValidString(n,!1))throw new Error("nonce is required parameter");if([...new Set(e.map(c=>s.parseChainId(c).namespace))].length>1)throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");const{namespace:a}=s.parseChainId(e[0]);if(a!=="eip155")throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.")},this.getVerifyContext=async(t,e)=>{const i={verified:{verifyUrl:e.verifyUrl||N.VERIFY_SERVER,validation:"UNKNOWN",origin:e.url||""}};try{const r=await this.client.core.verify.resolve({attestationId:t,verifyUrl:e.verifyUrl});r&&(i.verified.origin=r.origin,i.verified.isScam=r.isScam,i.verified.validation=r.origin===new URL(e.url).origin?"VALID":"INVALID")}catch(r){this.client.logger.info(r)}return this.client.logger.info(`Verify context: ${JSON.stringify(i)}`),i},this.validateSessionProps=(t,e)=>{Object.values(t).forEach(i=>{if(!s.isValidString(i,!1)){const{message:r}=s.getInternalError("MISSING_OR_INVALID",`${e} must be in Record<string, string> format. Received: ${JSON.stringify(i)}`);throw new Error(r)}})},this.getPendingAuthRequest=t=>{const e=this.client.auth.requests.get(t);return typeof e=="object"?e:void 0},this.addToRecentlyDeleted=(t,e)=>{if(this.recentlyDeletedMap.set(t,e),this.recentlyDeletedMap.size>=this.recentlyDeletedLimit){let i=0;const r=this.recentlyDeletedLimit/2;for(const n of this.recentlyDeletedMap.keys()){if(i++>=r)break;this.recentlyDeletedMap.delete(n)}}},this.checkRecentlyDeleted=t=>{const e=this.recentlyDeletedMap.get(t);if(e){const{message:i}=s.getInternalError("MISSING_OR_INVALID",`Record was recently deleted - ${e}: ${t}`);throw new Error(i)}}}async isInitialized(){if(!this.initialized){const{message:o}=s.getInternalError("NOT_INITIALIZED",this.name);throw new Error(o)}await this.client.core.relayer.confirmOnlineStateOrThrow()}registerRelayerEvents(){this.client.core.relayer.on(N.RELAYER_EVENTS.message,async o=>{const{topic:t,message:e}=o,{publicKey:i}=this.client.auth.authKeys.keys.includes(U)?this.client.auth.authKeys.get(U):{responseTopic:void 0,publicKey:void 0},r=await this.client.core.crypto.decode(t,e,{receiverPublicKey:i});try{u.isJsonRpcRequest(r)?(this.client.core.history.set(t,r),this.onRelayEventRequest({topic:t,payload:r})):u.isJsonRpcResponse(r)?(await this.client.core.history.resolve(r),await this.onRelayEventResponse({topic:t,payload:r}),this.client.core.history.delete(t,r.id)):this.onRelayEventUnknownPayload({topic:t,payload:r})}catch(n){this.client.logger.error(n)}})}registerExpirerEvents(){this.client.core.expirer.on(N.EXPIRER_EVENTS.expired,async o=>{const{topic:t,id:e}=s.parseExpirerTarget(o.target);if(e&&this.client.pendingRequest.keys.includes(e))return await this.deletePendingSessionRequest(e,s.getInternalError("EXPIRED"),!0);t?this.client.session.keys.includes(t)&&(await this.deleteSession({topic:t,expirerHasDeleted:!0}),this.client.events.emit("session_expire",{topic:t})):e&&(await this.deleteProposal(e,!0),this.client.events.emit("proposal_expire",{id:e}))})}registerPairingEvents(){this.client.core.pairing.events.on(N.PAIRING_EVENTS.create,o=>this.onPairingCreated(o)),this.client.core.pairing.events.on(N.PAIRING_EVENTS.delete,o=>{this.addToRecentlyDeleted(o.topic,"pairing")})}isValidPairingTopic(o){if(!s.isValidString(o,!1)){const{message:t}=s.getInternalError("MISSING_OR_INVALID",`pairing topic should be a string: ${o}`);throw new Error(t)}if(!this.client.core.pairing.pairings.keys.includes(o)){const{message:t}=s.getInternalError("NO_MATCHING_KEY",`pairing topic doesn't exist: ${o}`);throw new Error(t)}if(s.isExpired(this.client.core.pairing.pairings.get(o).expiry)){const{message:t}=s.getInternalError("EXPIRED",`pairing topic: ${o}`);throw new Error(t)}}async isValidSessionTopic(o){if(!s.isValidString(o,!1)){const{message:t}=s.getInternalError("MISSING_OR_INVALID",`session topic should be a string: ${o}`);throw new Error(t)}if(this.checkRecentlyDeleted(o),!this.client.session.keys.includes(o)){const{message:t}=s.getInternalError("NO_MATCHING_KEY",`session topic doesn't exist: ${o}`);throw new Error(t)}if(s.isExpired(this.client.session.get(o).expiry)){await this.deleteSession({topic:o});const{message:t}=s.getInternalError("EXPIRED",`session topic: ${o}`);throw new Error(t)}if(!this.client.core.crypto.keychain.has(o)){const{message:t}=s.getInternalError("MISSING_OR_INVALID",`session topic does not exist in keychain: ${o}`);throw await this.deleteSession({topic:o}),new Error(t)}}async isValidSessionOrPairingTopic(o){if(this.checkRecentlyDeleted(o),this.client.session.keys.includes(o))await this.isValidSessionTopic(o);else if(this.client.core.pairing.pairings.keys.includes(o))this.isValidPairingTopic(o);else if(s.isValidString(o,!1)){const{message:t}=s.getInternalError("NO_MATCHING_KEY",`session or pairing topic doesn't exist: ${o}`);throw new Error(t)}else{const{message:t}=s.getInternalError("MISSING_OR_INVALID",`session or pairing topic should be a string: ${o}`);throw new Error(t)}}async isValidProposalId(o){if(!s.isValidId(o)){const{message:t}=s.getInternalError("MISSING_OR_INVALID",`proposal id should be a number: ${o}`);throw new Error(t)}if(!this.client.proposal.keys.includes(o)){const{message:t}=s.getInternalError("NO_MATCHING_KEY",`proposal id doesn't exist: ${o}`);throw new Error(t)}if(s.isExpired(this.client.proposal.get(o).expiryTimestamp)){await this.deleteProposal(o);const{message:t}=s.getInternalError("EXPIRED",`proposal id: ${o}`);throw new Error(t)}}}class $e extends N.Store{constructor(o,t){super(o,t,ce,F),this.core=o,this.logger=t}}class _e extends N.Store{constructor(o,t){super(o,t,he,F),this.core=o,this.logger=t}}class Ge extends N.Store{constructor(o,t){super(o,t,de,F,e=>e.id),this.core=o,this.logger=t}}class Ke extends N.Store{constructor(o,t){super(o,t,we,L,()=>U),this.core=o,this.logger=t}}class ke extends N.Store{constructor(o,t){super(o,t,ye,L),this.core=o,this.logger=t}}class Fe extends N.Store{constructor(o,t){super(o,t,me,L,e=>e.id),this.core=o,this.logger=t}}class Ye{constructor(o,t){this.core=o,this.logger=t,this.authKeys=new Ke(this.core,this.logger),this.pairingTopics=new ke(this.core,this.logger),this.requests=new Fe(this.core,this.logger)}async init(){await this.authKeys.init(),await this.pairingTopics.init(),await this.requests.init()}}class j extends oe.ISignClient{constructor(o){super(o),this.protocol=ee,this.version=te,this.name=Y.name,this.events=new ae.EventEmitter,this.on=(e,i)=>this.events.on(e,i),this.once=(e,i)=>this.events.once(e,i),this.off=(e,i)=>this.events.off(e,i),this.removeListener=(e,i)=>this.events.removeListener(e,i),this.removeAllListeners=e=>this.events.removeAllListeners(e),this.connect=async e=>{try{return await this.engine.connect(e)}catch(i){throw this.logger.error(i.message),i}},this.pair=async e=>{try{return await this.engine.pair(e)}catch(i){throw this.logger.error(i.message),i}},this.approve=async e=>{try{return await this.engine.approve(e)}catch(i){throw this.logger.error(i.message),i}},this.reject=async e=>{try{return await this.engine.reject(e)}catch(i){throw this.logger.error(i.message),i}},this.update=async e=>{try{return await this.engine.update(e)}catch(i){throw this.logger.error(i.message),i}},this.extend=async e=>{try{return await this.engine.extend(e)}catch(i){throw this.logger.error(i.message),i}},this.request=async e=>{try{return await this.engine.request(e)}catch(i){throw this.logger.error(i.message),i}},this.respond=async e=>{try{return await this.engine.respond(e)}catch(i){throw this.logger.error(i.message),i}},this.ping=async e=>{try{return await this.engine.ping(e)}catch(i){throw this.logger.error(i.message),i}},this.emit=async e=>{try{return await this.engine.emit(e)}catch(i){throw this.logger.error(i.message),i}},this.disconnect=async e=>{try{return await this.engine.disconnect(e)}catch(i){throw this.logger.error(i.message),i}},this.find=e=>{try{return this.engine.find(e)}catch(i){throw this.logger.error(i.message),i}},this.getPendingSessionRequests=()=>{try{return this.engine.getPendingSessionRequests()}catch(e){throw this.logger.error(e.message),e}},this.authenticate=async e=>{try{return await this.engine.authenticate(e)}catch(i){throw this.logger.error(i.message),i}},this.formatAuthMessage=e=>{try{return this.engine.formatAuthMessage(e)}catch(i){throw this.logger.error(i.message),i}},this.approveSessionAuthenticate=async e=>{try{return await this.engine.approveSessionAuthenticate(e)}catch(i){throw this.logger.error(i.message),i}},this.rejectSessionAuthenticate=async e=>{try{return await this.engine.rejectSessionAuthenticate(e)}catch(i){throw this.logger.error(i.message),i}},this.name=o?.name||Y.name,this.metadata=o?.metadata||s.getAppMetadata();const t=typeof o?.logger<"u"&&typeof o?.logger!="string"?o.logger:k.pino(k.getDefaultLoggerOptions({level:o?.logger||Y.logger}));this.core=o?.core||new N.Core(o),this.logger=k.generateChildLogger(t,this.name),this.session=new _e(this.core,this.logger),this.proposal=new $e(this.core,this.logger),this.pendingRequest=new Ge(this.core,this.logger),this.engine=new Ue(this),this.auth=new Ye(this.core,this.logger)}static async init(o){const t=new j(o);return await t.initialize(),t}get context(){return k.getLoggerContext(this.logger)}get pairing(){return this.core.pairing.pairings}async initialize(){this.logger.trace("Initialized");try{await this.core.start(),await this.session.init(),await this.proposal.init(),await this.pendingRequest.init(),await this.engine.init(),await this.auth.init(),this.core.verify.init({verifyUrl:this.metadata.verifyUrl}),this.logger.info("SignClient Initialization Success")}catch(o){throw this.logger.info("SignClient Initialization Failure"),this.logger.error(o.message),o}}}const He=_e,je=j;exports.AUTH_CONTEXT=Ee,exports.AUTH_KEYS_CONTEXT=we,exports.AUTH_PAIRING_TOPIC_CONTEXT=ye,exports.AUTH_PROTOCOL=ge,exports.AUTH_PUBLIC_KEY_NAME=U,exports.AUTH_REQUEST_CONTEXT=me,exports.AUTH_STORAGE_PREFIX=L,exports.AUTH_VERSION=De,exports.ENGINE_CONTEXT=pe,exports.ENGINE_QUEUE_STATES=A,exports.ENGINE_RPC_OPTS=q,exports.HISTORY_CONTEXT=Oe,exports.HISTORY_EVENTS=ve,exports.HISTORY_STORAGE_VERSION=Ae,exports.METHODS_TO_VERIFY=ue,exports.PROPOSAL_CONTEXT=ce,exports.PROPOSAL_EXPIRY=Ve,exports.PROPOSAL_EXPIRY_MESSAGE=le,exports.REQUEST_CONTEXT=de,exports.SESSION_CONTEXT=he,exports.SESSION_EXPIRY=V,exports.SESSION_REQUEST_EXPIRY_BOUNDARIES=H,exports.SIGN_CLIENT_CONTEXT=ie,exports.SIGN_CLIENT_DEFAULT=Y,exports.SIGN_CLIENT_EVENTS=Pe,exports.SIGN_CLIENT_PROTOCOL=ee,exports.SIGN_CLIENT_STORAGE_OPTIONS=Te,exports.SIGN_CLIENT_STORAGE_PREFIX=F,exports.SIGN_CLIENT_VERSION=te,exports.SessionStore=He,exports.SignClient=je,exports.WALLETCONNECT_DEEPLINK_CHOICE=se,exports.default=j;
//# sourceMappingURL=index.cjs.js.map
