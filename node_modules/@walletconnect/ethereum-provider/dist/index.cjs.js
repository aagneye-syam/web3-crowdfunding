"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var M=require("events"),p=require("@walletconnect/utils"),P=require("@walletconnect/universal-provider");function A(n){if(n&&n.__esModule)return n;var t=Object.create(null);return n&&Object.keys(n).forEach(function(s){if(s!=="default"){var e=Object.getOwnPropertyDescriptor(n,s);Object.defineProperty(t,s,e.get?e:{enumerable:!0,get:function(){return n[s]}})}}),t.default=n,Object.freeze(t)}const T="wc",R="ethereum_provider",S=`${T}@2:${R}:`,j="https://rpc.walletconnect.com/v1/",g=["eth_sendTransaction","personal_sign"],_=["eth_accounts","eth_requestAccounts","eth_sendRawTransaction","eth_sign","eth_signTransaction","eth_signTypedData","eth_signTypedData_v3","eth_signTypedData_v4","eth_sendTransaction","personal_sign","wallet_switchEthereumChain","wallet_addEthereumChain","wallet_getPermissions","wallet_requestPermissions","wallet_registerOnboarding","wallet_watchAsset","wallet_scanQRCode"],m=["chainChanged","accountsChanged"],y=["chainChanged","accountsChanged","message","disconnect","connect"];var N=Object.defineProperty,q=Object.defineProperties,D=Object.getOwnPropertyDescriptors,O=Object.getOwnPropertySymbols,$=Object.prototype.hasOwnProperty,U=Object.prototype.propertyIsEnumerable,b=(n,t,s)=>t in n?N(n,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):n[t]=s,u=(n,t)=>{for(var s in t||(t={}))$.call(t,s)&&b(n,s,t[s]);if(O)for(var s of O(t))U.call(t,s)&&b(n,s,t[s]);return n},E=(n,t)=>q(n,D(t));function v(n){return Number(n[0].split(":")[1])}function I(n){return`0x${n.toString(16)}`}function Q(n){const{chains:t,optionalChains:s,methods:e,optionalMethods:i,events:a,optionalEvents:o,rpcMap:r}=n;if(!p.isValidArray(t))throw new Error("Invalid chains");const h={chains:t,methods:e||g,events:a||m,rpcMap:u({},t.length?{[v(t)]:r[v(t)]}:{})},c=a?.filter(l=>!m.includes(l)),d=e?.filter(l=>!g.includes(l));if(!s&&!o&&!i&&!(c!=null&&c.length)&&!(d!=null&&d.length))return{required:t.length?h:void 0};const w=c?.length&&d?.length||!s,f={chains:[...new Set(w?h.chains.concat(s||[]):s)],methods:[...new Set(h.methods.concat(i!=null&&i.length?i:_))],events:[...new Set(h.events.concat(o!=null&&o.length?o:y))],rpcMap:r};return{required:t.length?h:void 0,optional:s.length?f:void 0}}class C{constructor(){this.events=new M.EventEmitter,this.namespace="eip155",this.accounts=[],this.chainId=1,this.STORAGE_KEY=S,this.on=(t,s)=>(this.events.on(t,s),this),this.once=(t,s)=>(this.events.once(t,s),this),this.removeListener=(t,s)=>(this.events.removeListener(t,s),this),this.off=(t,s)=>(this.events.off(t,s),this),this.parseAccount=t=>this.isCompatibleChainId(t)?this.parseAccountId(t).address:t,this.signer={},this.rpc={}}static async init(t){const s=new C;return await s.initialize(t),s}async request(t,s){return await this.signer.request(t,this.formatChainId(this.chainId),s)}sendAsync(t,s,e){this.signer.sendAsync(t,s,this.formatChainId(this.chainId),e)}get connected(){return this.signer.client?this.signer.client.core.relayer.connected:!1}get connecting(){return this.signer.client?this.signer.client.core.relayer.connecting:!1}async enable(){return this.session||await this.connect(),await this.request({method:"eth_requestAccounts"})}async connect(t){if(!this.signer.client)throw new Error("Provider not initialized. Call init() first");this.loadConnectOpts(t);const{required:s,optional:e}=Q(this.rpc);try{const i=await new Promise(async(o,r)=>{var h;this.rpc.showQrModal&&((h=this.modal)==null||h.subscribeModal(c=>{!c.open&&!this.signer.session&&(this.signer.abortPairingAttempt(),r(new Error("Connection request reset. Please try again.")))})),await this.signer.connect(E(u({namespaces:u({},s&&{[this.namespace]:s})},e&&{optionalNamespaces:{[this.namespace]:e}}),{pairingTopic:t?.pairingTopic})).then(c=>{o(c)}).catch(c=>{r(new Error(c.message))})});if(!i)return;const a=p.getAccountsFromNamespaces(i.namespaces,[this.namespace]);this.setChainIds(this.rpc.chains.length?this.rpc.chains:a),this.setAccounts(a),this.events.emit("connect",{chainId:I(this.chainId)})}catch(i){throw this.signer.logger.error(i),i}finally{this.modal&&this.modal.closeModal()}}async authenticate(t){if(!this.signer.client)throw new Error("Provider not initialized. Call init() first");this.loadConnectOpts({chains:t?.chains});try{const s=await new Promise(async(i,a)=>{var o;this.rpc.showQrModal&&((o=this.modal)==null||o.subscribeModal(r=>{!r.open&&!this.signer.session&&(this.signer.abortPairingAttempt(),a(new Error("Connection request reset. Please try again.")))})),await this.signer.authenticate(E(u({},t),{chains:this.rpc.chains})).then(r=>{i(r)}).catch(r=>{a(new Error(r.message))})}),e=s.session;if(e){const i=p.getAccountsFromNamespaces(e.namespaces,[this.namespace]);this.setChainIds(this.rpc.chains.length?this.rpc.chains:i),this.setAccounts(i),this.events.emit("connect",{chainId:I(this.chainId)})}return s}catch(s){throw this.signer.logger.error(s),s}finally{this.modal&&this.modal.closeModal()}}async disconnect(){this.session&&await this.signer.disconnect(),this.reset()}get isWalletConnect(){return!0}get session(){return this.signer.session}registerEventListeners(){this.signer.on("session_event",t=>{const{params:s}=t,{event:e}=s;e.name==="accountsChanged"?(this.accounts=this.parseAccounts(e.data),this.events.emit("accountsChanged",this.accounts)):e.name==="chainChanged"?this.setChainId(this.formatChainId(e.data)):this.events.emit(e.name,e.data),this.events.emit("session_event",t)}),this.signer.on("chainChanged",t=>{const s=parseInt(t);this.chainId=s,this.events.emit("chainChanged",I(this.chainId)),this.persist()}),this.signer.on("session_update",t=>{this.events.emit("session_update",t)}),this.signer.on("session_delete",t=>{this.reset(),this.events.emit("session_delete",t),this.events.emit("disconnect",E(u({},p.getSdkError("USER_DISCONNECTED")),{data:t.topic,name:"USER_DISCONNECTED"}))}),this.signer.on("display_uri",t=>{var s,e;this.rpc.showQrModal&&((s=this.modal)==null||s.closeModal(),(e=this.modal)==null||e.openModal({uri:t})),this.events.emit("display_uri",t)})}switchEthereumChain(t){this.request({method:"wallet_switchEthereumChain",params:[{chainId:t.toString(16)}]})}isCompatibleChainId(t){return typeof t=="string"?t.startsWith(`${this.namespace}:`):!1}formatChainId(t){return`${this.namespace}:${t}`}parseChainId(t){return Number(t.split(":")[1])}setChainIds(t){const s=t.filter(e=>this.isCompatibleChainId(e)).map(e=>this.parseChainId(e));s.length&&(this.chainId=s[0],this.events.emit("chainChanged",I(this.chainId)),this.persist())}setChainId(t){if(this.isCompatibleChainId(t)){const s=this.parseChainId(t);this.chainId=s,this.switchEthereumChain(s)}}parseAccountId(t){const[s,e,i]=t.split(":");return{chainId:`${s}:${e}`,address:i}}setAccounts(t){this.accounts=t.filter(s=>this.parseChainId(this.parseAccountId(s).chainId)===this.chainId).map(s=>this.parseAccountId(s).address),this.events.emit("accountsChanged",this.accounts)}getRpcConfig(t){var s,e;const i=(s=t?.chains)!=null?s:[],a=(e=t?.optionalChains)!=null?e:[],o=i.concat(a);if(!o.length)throw new Error("No chains specified in either `chains` or `optionalChains`");const r=i.length?t?.methods||g:[],h=i.length?t?.events||m:[],c=t?.optionalMethods||[],d=t?.optionalEvents||[],w=t?.rpcMap||this.buildRpcMap(o,t.projectId),f=t?.qrModalOptions||void 0;return{chains:i?.map(l=>this.formatChainId(l)),optionalChains:a.map(l=>this.formatChainId(l)),methods:r,events:h,optionalMethods:c,optionalEvents:d,rpcMap:w,showQrModal:!!(t!=null&&t.showQrModal),qrModalOptions:f,projectId:t.projectId,metadata:t.metadata}}buildRpcMap(t,s){const e={};return t.forEach(i=>{e[i]=this.getRpcUrl(i,s)}),e}async initialize(t){if(this.rpc=this.getRpcConfig(t),this.chainId=this.rpc.chains.length?v(this.rpc.chains):v(this.rpc.optionalChains),this.signer=await P.UniversalProvider.init({projectId:this.rpc.projectId,metadata:this.rpc.metadata,disableProviderPing:t.disableProviderPing,relayUrl:t.relayUrl,storageOptions:t.storageOptions}),this.registerEventListeners(),await this.loadPersistedSession(),this.rpc.showQrModal){let s;try{const{WalletConnectModal:e}=await Promise.resolve().then(function(){return A(require("@walletconnect/modal"))});s=e}catch{throw new Error("To use QR modal, please install @walletconnect/modal package")}if(s)try{this.modal=new s(u({projectId:this.rpc.projectId},this.rpc.qrModalOptions))}catch(e){throw this.signer.logger.error(e),new Error("Could not generate WalletConnectModal Instance")}}}loadConnectOpts(t){if(!t)return;const{chains:s,optionalChains:e,rpcMap:i}=t;s&&p.isValidArray(s)&&(this.rpc.chains=s.map(a=>this.formatChainId(a)),s.forEach(a=>{this.rpc.rpcMap[a]=i?.[a]||this.getRpcUrl(a)})),e&&p.isValidArray(e)&&(this.rpc.optionalChains=[],this.rpc.optionalChains=e?.map(a=>this.formatChainId(a)),e.forEach(a=>{this.rpc.rpcMap[a]=i?.[a]||this.getRpcUrl(a)}))}getRpcUrl(t,s){var e;return((e=this.rpc.rpcMap)==null?void 0:e[t])||`${j}?chainId=eip155:${t}&projectId=${s||this.rpc.projectId}`}async loadPersistedSession(){if(this.session)try{const t=await this.signer.client.core.storage.getItem(`${this.STORAGE_KEY}/chainId`),s=this.session.namespaces[`${this.namespace}:${t}`]?this.session.namespaces[`${this.namespace}:${t}`]:this.session.namespaces[this.namespace];this.setChainIds(t?[this.formatChainId(t)]:s?.accounts),this.setAccounts(s?.accounts)}catch(t){this.signer.logger.error("Failed to load persisted session, clearing state..."),this.signer.logger.error(t),await this.disconnect().catch(s=>this.signer.logger.warn(s))}}reset(){this.chainId=1,this.accounts=[]}persist(){this.session&&this.signer.client.core.storage.setItem(`${this.STORAGE_KEY}/chainId`,this.chainId)}parseAccounts(t){return typeof t=="string"||t instanceof String?[this.parseAccount(t)]:t.map(s=>this.parseAccount(s))}}const L=C;exports.EthereumProvider=L,exports.OPTIONAL_EVENTS=y,exports.OPTIONAL_METHODS=_,exports.REQUIRED_EVENTS=m,exports.REQUIRED_METHODS=g,exports.default=C;
//# sourceMappingURL=index.cjs.js.map
